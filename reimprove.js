(function (f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f()
    } else if (typeof define === "function" && define.amd) {
        define([], f)
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window
        } else if (typeof global !== "undefined") {
            g = global
        } else if (typeof self !== "undefined") {
            g = self
        } else {
            g = this
        }
        g.ReImprove = f()
    }
})(function () {
    var define, module, exports;
    return function () {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw a.code = "MODULE_NOT_FOUND", a
                    }
                    var p = n[i] = {exports: {}};
                    e[i][0].call(p.exports, function (r) {
                        var n = e[i][1][r];
                        return o(n || r)
                    }, p, p.exports, r, e, n, t)
                }
                return n[i].exports
            }

            for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
            return o
        }

        return r
    }()({
        1: [function (require, module, exports) {
            "use strict";
            module.exports = asPromise;

            function asPromise(fn, ctx) {
                var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
                while (index < arguments.length) params[offset++] = arguments[index++];
                return new Promise(function executor(resolve, reject) {
                    params[offset] = function callback(err) {
                        if (pending) {
                            pending = false;
                            if (err) reject(err); else {
                                var params = new Array(arguments.length - 1), offset = 0;
                                while (offset < params.length) params[offset++] = arguments[offset];
                                resolve.apply(null, params)
                            }
                        }
                    };
                    try {
                        fn.apply(ctx || null, params)
                    } catch (err) {
                        if (pending) {
                            pending = false;
                            reject(err)
                        }
                    }
                })
            }
        }, {}],
        2: [function (require, module, exports) {
            "use strict";
            var base64 = exports;
            base64.length = function length(string) {
                var p = string.length;
                if (!p) return 0;
                var n = 0;
                while (--p % 4 > 1 && string.charAt(p) === "=") ++n;
                return Math.ceil(string.length * 3) / 4 - n
            };
            var b64 = new Array(64);
            var s64 = new Array(123);
            for (var i = 0; i < 64;) s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
            base64.encode = function encode(buffer, start, end) {
                var parts = null, chunk = [];
                var i = 0, j = 0, t;
                while (start < end) {
                    var b = buffer[start++];
                    switch (j) {
                        case 0:
                            chunk[i++] = b64[b >> 2];
                            t = (b & 3) << 4;
                            j = 1;
                            break;
                        case 1:
                            chunk[i++] = b64[t | b >> 4];
                            t = (b & 15) << 2;
                            j = 2;
                            break;
                        case 2:
                            chunk[i++] = b64[t | b >> 6];
                            chunk[i++] = b64[b & 63];
                            j = 0;
                            break
                    }
                    if (i > 8191) {
                        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                        i = 0
                    }
                }
                if (j) {
                    chunk[i++] = b64[t];
                    chunk[i++] = 61;
                    if (j === 1) chunk[i++] = 61
                }
                if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("")
                }
                return String.fromCharCode.apply(String, chunk.slice(0, i))
            };
            var invalidEncoding = "invalid encoding";
            base64.decode = function decode(string, buffer, offset) {
                var start = offset;
                var j = 0, t;
                for (var i = 0; i < string.length;) {
                    var c = string.charCodeAt(i++);
                    if (c === 61 && j > 1) break;
                    if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
                    switch (j) {
                        case 0:
                            t = c;
                            j = 1;
                            break;
                        case 1:
                            buffer[offset++] = t << 2 | (c & 48) >> 4;
                            t = c;
                            j = 2;
                            break;
                        case 2:
                            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                            t = c;
                            j = 3;
                            break;
                        case 3:
                            buffer[offset++] = (t & 3) << 6 | c;
                            j = 0;
                            break
                    }
                }
                if (j === 1) throw Error(invalidEncoding);
                return offset - start
            };
            base64.test = function test(string) {
                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string)
            }
        }, {}],
        3: [function (require, module, exports) {
            "use strict";
            module.exports = EventEmitter;

            function EventEmitter() {
                this._listeners = {}
            }

            EventEmitter.prototype.on = function on(evt, fn, ctx) {
                (this._listeners[evt] || (this._listeners[evt] = [])).push({fn: fn, ctx: ctx || this});
                return this
            };
            EventEmitter.prototype.off = function off(evt, fn) {
                if (evt === undefined) this._listeners = {}; else {
                    if (fn === undefined) this._listeners[evt] = []; else {
                        var listeners = this._listeners[evt];
                        for (var i = 0; i < listeners.length;) if (listeners[i].fn === fn) listeners.splice(i, 1); else ++i
                    }
                }
                return this
            };
            EventEmitter.prototype.emit = function emit(evt) {
                var listeners = this._listeners[evt];
                if (listeners) {
                    var args = [], i = 1;
                    for (; i < arguments.length;) args.push(arguments[i++]);
                    for (i = 0; i < listeners.length;) listeners[i].fn.apply(listeners[i++].ctx, args)
                }
                return this
            }
        }, {}],
        4: [function (require, module, exports) {
            "use strict";
            module.exports = factory(factory);

            function factory(exports) {
                if (typeof Float32Array !== "undefined") (function () {
                    var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;

                    function writeFloat_f32_cpy(val, buf, pos) {
                        f32[0] = val;
                        buf[pos] = f8b[0];
                        buf[pos + 1] = f8b[1];
                        buf[pos + 2] = f8b[2];
                        buf[pos + 3] = f8b[3]
                    }

                    function writeFloat_f32_rev(val, buf, pos) {
                        f32[0] = val;
                        buf[pos] = f8b[3];
                        buf[pos + 1] = f8b[2];
                        buf[pos + 2] = f8b[1];
                        buf[pos + 3] = f8b[0]
                    }

                    exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
                    exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

                    function readFloat_f32_cpy(buf, pos) {
                        f8b[0] = buf[pos];
                        f8b[1] = buf[pos + 1];
                        f8b[2] = buf[pos + 2];
                        f8b[3] = buf[pos + 3];
                        return f32[0]
                    }

                    function readFloat_f32_rev(buf, pos) {
                        f8b[3] = buf[pos];
                        f8b[2] = buf[pos + 1];
                        f8b[1] = buf[pos + 2];
                        f8b[0] = buf[pos + 3];
                        return f32[0]
                    }

                    exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
                    exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy
                })(); else (function () {
                    function writeFloat_ieee754(writeUint, val, buf, pos) {
                        var sign = val < 0 ? 1 : 0;
                        if (sign) val = -val;
                        if (val === 0) writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos); else if (isNaN(val)) writeUint(2143289344, buf, pos); else if (val > 34028234663852886e22) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos); else if (val < 11754943508222875e-54) writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos); else {
                            var exponent = Math.floor(Math.log(val) / Math.LN2),
                                mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos)
                        }
                    }

                    exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
                    exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

                    function readFloat_ieee754(readUint, buf, pos) {
                        var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255,
                            mantissa = uint & 8388607;
                        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608)
                    }

                    exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
                    exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE)
                })();
                if (typeof Float64Array !== "undefined") (function () {
                    var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;

                    function writeDouble_f64_cpy(val, buf, pos) {
                        f64[0] = val;
                        buf[pos] = f8b[0];
                        buf[pos + 1] = f8b[1];
                        buf[pos + 2] = f8b[2];
                        buf[pos + 3] = f8b[3];
                        buf[pos + 4] = f8b[4];
                        buf[pos + 5] = f8b[5];
                        buf[pos + 6] = f8b[6];
                        buf[pos + 7] = f8b[7]
                    }

                    function writeDouble_f64_rev(val, buf, pos) {
                        f64[0] = val;
                        buf[pos] = f8b[7];
                        buf[pos + 1] = f8b[6];
                        buf[pos + 2] = f8b[5];
                        buf[pos + 3] = f8b[4];
                        buf[pos + 4] = f8b[3];
                        buf[pos + 5] = f8b[2];
                        buf[pos + 6] = f8b[1];
                        buf[pos + 7] = f8b[0]
                    }

                    exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
                    exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

                    function readDouble_f64_cpy(buf, pos) {
                        f8b[0] = buf[pos];
                        f8b[1] = buf[pos + 1];
                        f8b[2] = buf[pos + 2];
                        f8b[3] = buf[pos + 3];
                        f8b[4] = buf[pos + 4];
                        f8b[5] = buf[pos + 5];
                        f8b[6] = buf[pos + 6];
                        f8b[7] = buf[pos + 7];
                        return f64[0]
                    }

                    function readDouble_f64_rev(buf, pos) {
                        f8b[7] = buf[pos];
                        f8b[6] = buf[pos + 1];
                        f8b[5] = buf[pos + 2];
                        f8b[4] = buf[pos + 3];
                        f8b[3] = buf[pos + 4];
                        f8b[2] = buf[pos + 5];
                        f8b[1] = buf[pos + 6];
                        f8b[0] = buf[pos + 7];
                        return f64[0]
                    }

                    exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
                    exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy
                })(); else (function () {
                    function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
                        var sign = val < 0 ? 1 : 0;
                        if (sign) val = -val;
                        if (val === 0) {
                            writeUint(0, buf, pos + off0);
                            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1)
                        } else if (isNaN(val)) {
                            writeUint(0, buf, pos + off0);
                            writeUint(2146959360, buf, pos + off1)
                        } else if (val > 17976931348623157e292) {
                            writeUint(0, buf, pos + off0);
                            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1)
                        } else {
                            var mantissa;
                            if (val < 22250738585072014e-324) {
                                mantissa = val / 5e-324;
                                writeUint(mantissa >>> 0, buf, pos + off0);
                                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1)
                            } else {
                                var exponent = Math.floor(Math.log(val) / Math.LN2);
                                if (exponent === 1024) exponent = 1023;
                                mantissa = val * Math.pow(2, -exponent);
                                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1)
                            }
                        }
                    }

                    exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
                    exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

                    function readDouble_ieee754(readUint, off0, off1, buf, pos) {
                        var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
                        var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047,
                            mantissa = 4294967296 * (hi & 1048575) + lo;
                        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496)
                    }

                    exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
                    exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0)
                })();
                return exports
            }

            function writeUintLE(val, buf, pos) {
                buf[pos] = val & 255;
                buf[pos + 1] = val >>> 8 & 255;
                buf[pos + 2] = val >>> 16 & 255;
                buf[pos + 3] = val >>> 24
            }

            function writeUintBE(val, buf, pos) {
                buf[pos] = val >>> 24;
                buf[pos + 1] = val >>> 16 & 255;
                buf[pos + 2] = val >>> 8 & 255;
                buf[pos + 3] = val & 255
            }

            function readUintLE(buf, pos) {
                return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0
            }

            function readUintBE(buf, pos) {
                return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0
            }
        }, {}],
        5: [function (require, module, exports) {
            "use strict";
            module.exports = inquire;

            function inquire(moduleName) {
                try {
                    var mod = eval("quire".replace(/^/, "re"))(moduleName);
                    if (mod && (mod.length || Object.keys(mod).length)) return mod
                } catch (e) {
                }
                return null
            }
        }, {}],
        6: [function (require, module, exports) {
            "use strict";
            module.exports = pool;

            function pool(alloc, slice, size) {
                var SIZE = size || 8192;
                var MAX = SIZE >>> 1;
                var slab = null;
                var offset = SIZE;
                return function pool_alloc(size) {
                    if (size < 1 || size > MAX) return alloc(size);
                    if (offset + size > SIZE) {
                        slab = alloc(SIZE);
                        offset = 0
                    }
                    var buf = slice.call(slab, offset, offset += size);
                    if (offset & 7) offset = (offset | 7) + 1;
                    return buf
                }
            }
        }, {}],
        7: [function (require, module, exports) {
            "use strict";
            var utf8 = exports;
            utf8.length = function utf8_length(string) {
                var len = 0, c = 0;
                for (var i = 0; i < string.length; ++i) {
                    c = string.charCodeAt(i);
                    if (c < 128) len += 1; else if (c < 2048) len += 2; else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
                        ++i;
                        len += 4
                    } else len += 3
                }
                return len
            };
            utf8.read = function utf8_read(buffer, start, end) {
                var len = end - start;
                if (len < 1) return "";
                var parts = null, chunk = [], i = 0, t;
                while (start < end) {
                    t = buffer[start++];
                    if (t < 128) chunk[i++] = t; else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63; else if (t > 239 && t < 365) {
                        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
                        chunk[i++] = 55296 + (t >> 10);
                        chunk[i++] = 56320 + (t & 1023)
                    } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
                    if (i > 8191) {
                        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                        i = 0
                    }
                }
                if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("")
                }
                return String.fromCharCode.apply(String, chunk.slice(0, i))
            };
            utf8.write = function utf8_write(string, buffer, offset) {
                var start = offset, c1, c2;
                for (var i = 0; i < string.length; ++i) {
                    c1 = string.charCodeAt(i);
                    if (c1 < 128) {
                        buffer[offset++] = c1
                    } else if (c1 < 2048) {
                        buffer[offset++] = c1 >> 6 | 192;
                        buffer[offset++] = c1 & 63 | 128
                    } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
                        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                        ++i;
                        buffer[offset++] = c1 >> 18 | 240;
                        buffer[offset++] = c1 >> 12 & 63 | 128;
                        buffer[offset++] = c1 >> 6 & 63 | 128;
                        buffer[offset++] = c1 & 63 | 128
                    } else {
                        buffer[offset++] = c1 >> 12 | 224;
                        buffer[offset++] = c1 >> 6 & 63 | 128;
                        buffer[offset++] = c1 & 63 | 128
                    }
                }
                return offset - start
            }
        }, {}],
        8: [function (require, module, exports) {
            "use strict";
            var $protobuf = require("protobufjs/minimal");
            var $Reader = $protobuf.Reader, $util = $protobuf.util;
            var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
            $root.tensorflow = function () {
                var tensorflow = {};
                tensorflow.Any = function () {
                    function Any(p) {
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    Any.prototype.typeUrl = "";
                    Any.prototype.value = $util.newBuffer([]);
                    Any.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.Any;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.typeUrl = r.string();
                                    break;
                                case 2:
                                    m.value = r.bytes();
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return Any
                }();
                tensorflow.DataType = function () {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DT_INVALID"] = 0;
                    values[valuesById[1] = "DT_FLOAT"] = 1;
                    values[valuesById[2] = "DT_DOUBLE"] = 2;
                    values[valuesById[3] = "DT_INT32"] = 3;
                    values[valuesById[4] = "DT_UINT8"] = 4;
                    values[valuesById[5] = "DT_INT16"] = 5;
                    values[valuesById[6] = "DT_INT8"] = 6;
                    values[valuesById[7] = "DT_STRING"] = 7;
                    values[valuesById[8] = "DT_COMPLEX64"] = 8;
                    values[valuesById[9] = "DT_INT64"] = 9;
                    values[valuesById[10] = "DT_BOOL"] = 10;
                    values[valuesById[11] = "DT_QINT8"] = 11;
                    values[valuesById[12] = "DT_QUINT8"] = 12;
                    values[valuesById[13] = "DT_QINT32"] = 13;
                    values[valuesById[14] = "DT_BFLOAT16"] = 14;
                    values[valuesById[101] = "DT_FLOAT_REF"] = 101;
                    values[valuesById[102] = "DT_DOUBLE_REF"] = 102;
                    values[valuesById[103] = "DT_INT32_REF"] = 103;
                    values[valuesById[104] = "DT_UINT8_REF"] = 104;
                    values[valuesById[105] = "DT_INT16_REF"] = 105;
                    values[valuesById[106] = "DT_INT8_REF"] = 106;
                    values[valuesById[107] = "DT_STRING_REF"] = 107;
                    values[valuesById[108] = "DT_COMPLEX64_REF"] = 108;
                    values[valuesById[109] = "DT_INT64_REF"] = 109;
                    values[valuesById[110] = "DT_BOOL_REF"] = 110;
                    values[valuesById[111] = "DT_QINT8_REF"] = 111;
                    values[valuesById[112] = "DT_QUINT8_REF"] = 112;
                    values[valuesById[113] = "DT_QINT32_REF"] = 113;
                    values[valuesById[114] = "DT_BFLOAT16_REF"] = 114;
                    return values
                }();
                tensorflow.TensorShape = function () {
                    function TensorShape(p) {
                        this.dim = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    TensorShape.prototype.dim = $util.emptyArray;
                    TensorShape.prototype.unknownRank = false;
                    TensorShape.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorShape;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 2:
                                    if (!(m.dim && m.dim.length)) m.dim = [];
                                    m.dim.push($root.tensorflow.TensorShape.Dim.decode(r, r.uint32()));
                                    break;
                                case 3:
                                    m.unknownRank = r.bool();
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    TensorShape.Dim = function () {
                        function Dim(p) {
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        Dim.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                        Dim.prototype.name = "";
                        Dim.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorShape.Dim;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        m.size = r.int64();
                                        break;
                                    case 2:
                                        m.name = r.string();
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return Dim
                    }();
                    return TensorShape
                }();
                tensorflow.Tensor = function () {
                    function Tensor(p) {
                        this.floatVal = [];
                        this.doubleVal = [];
                        this.intVal = [];
                        this.stringVal = [];
                        this.scomplexVal = [];
                        this.int64Val = [];
                        this.boolVal = [];
                        this.uint32Val = [];
                        this.uint64Val = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    Tensor.prototype.dtype = 0;
                    Tensor.prototype.tensorShape = null;
                    Tensor.prototype.versionNumber = 0;
                    Tensor.prototype.tensorContent = $util.newBuffer([]);
                    Tensor.prototype.floatVal = $util.emptyArray;
                    Tensor.prototype.doubleVal = $util.emptyArray;
                    Tensor.prototype.intVal = $util.emptyArray;
                    Tensor.prototype.stringVal = $util.emptyArray;
                    Tensor.prototype.scomplexVal = $util.emptyArray;
                    Tensor.prototype.int64Val = $util.emptyArray;
                    Tensor.prototype.boolVal = $util.emptyArray;
                    Tensor.prototype.uint32Val = $util.emptyArray;
                    Tensor.prototype.uint64Val = $util.emptyArray;
                    Tensor.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.Tensor;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.dtype = r.int32();
                                    break;
                                case 2:
                                    m.tensorShape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                                    break;
                                case 3:
                                    m.versionNumber = r.int32();
                                    break;
                                case 4:
                                    m.tensorContent = r.bytes();
                                    break;
                                case 5:
                                    if (!(m.floatVal && m.floatVal.length)) m.floatVal = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.floatVal.push(r.float())
                                    } else m.floatVal.push(r.float());
                                    break;
                                case 6:
                                    if (!(m.doubleVal && m.doubleVal.length)) m.doubleVal = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.doubleVal.push(r.double())
                                    } else m.doubleVal.push(r.double());
                                    break;
                                case 7:
                                    if (!(m.intVal && m.intVal.length)) m.intVal = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.intVal.push(r.int32())
                                    } else m.intVal.push(r.int32());
                                    break;
                                case 8:
                                    if (!(m.stringVal && m.stringVal.length)) m.stringVal = [];
                                    m.stringVal.push(r.bytes());
                                    break;
                                case 9:
                                    if (!(m.scomplexVal && m.scomplexVal.length)) m.scomplexVal = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.scomplexVal.push(r.float())
                                    } else m.scomplexVal.push(r.float());
                                    break;
                                case 10:
                                    if (!(m.int64Val && m.int64Val.length)) m.int64Val = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.int64Val.push(r.int64())
                                    } else m.int64Val.push(r.int64());
                                    break;
                                case 11:
                                    if (!(m.boolVal && m.boolVal.length)) m.boolVal = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.boolVal.push(r.bool())
                                    } else m.boolVal.push(r.bool());
                                    break;
                                case 16:
                                    if (!(m.uint32Val && m.uint32Val.length)) m.uint32Val = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.uint32Val.push(r.uint32())
                                    } else m.uint32Val.push(r.uint32());
                                    break;
                                case 17:
                                    if (!(m.uint64Val && m.uint64Val.length)) m.uint64Val = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.uint64Val.push(r.uint64())
                                    } else m.uint64Val.push(r.uint64());
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return Tensor
                }();
                tensorflow.AttrValue = function () {
                    function AttrValue(p) {
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    AttrValue.prototype.list = null;
                    AttrValue.prototype.s = $util.newBuffer([]);
                    AttrValue.prototype.i = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                    AttrValue.prototype.f = 0;
                    AttrValue.prototype.b = false;
                    AttrValue.prototype.type = 0;
                    AttrValue.prototype.shape = null;
                    AttrValue.prototype.tensor = null;
                    AttrValue.prototype.placeholder = "";
                    AttrValue.prototype.func = null;
                    var $oneOfFields;
                    Object.defineProperty(AttrValue.prototype, "value", {
                        get: $util.oneOfGetter($oneOfFields = ["list", "s", "i", "f", "b", "type", "shape", "tensor", "placeholder", "func"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
                    AttrValue.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AttrValue;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.list = $root.tensorflow.AttrValue.ListValue.decode(r, r.uint32());
                                    break;
                                case 2:
                                    m.s = r.bytes();
                                    break;
                                case 3:
                                    m.i = r.int64();
                                    break;
                                case 4:
                                    m.f = r.float();
                                    break;
                                case 5:
                                    m.b = r.bool();
                                    break;
                                case 6:
                                    m.type = r.int32();
                                    break;
                                case 7:
                                    m.shape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                                    break;
                                case 8:
                                    m.tensor = $root.tensorflow.Tensor.decode(r, r.uint32());
                                    break;
                                case 9:
                                    m.placeholder = r.string();
                                    break;
                                case 10:
                                    m.func = $root.tensorflow.NameAttrList.decode(r, r.uint32());
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    AttrValue.ListValue = function () {
                        function ListValue(p) {
                            this.s = [];
                            this.i = [];
                            this.f = [];
                            this.b = [];
                            this.type = [];
                            this.shape = [];
                            this.tensor = [];
                            this.func = [];
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        ListValue.prototype.s = $util.emptyArray;
                        ListValue.prototype.i = $util.emptyArray;
                        ListValue.prototype.f = $util.emptyArray;
                        ListValue.prototype.b = $util.emptyArray;
                        ListValue.prototype.type = $util.emptyArray;
                        ListValue.prototype.shape = $util.emptyArray;
                        ListValue.prototype.tensor = $util.emptyArray;
                        ListValue.prototype.func = $util.emptyArray;
                        ListValue.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AttrValue.ListValue;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 2:
                                        if (!(m.s && m.s.length)) m.s = [];
                                        m.s.push(r.bytes());
                                        break;
                                    case 3:
                                        if (!(m.i && m.i.length)) m.i = [];
                                        if ((t & 7) === 2) {
                                            var c2 = r.uint32() + r.pos;
                                            while (r.pos < c2) m.i.push(r.int64())
                                        } else m.i.push(r.int64());
                                        break;
                                    case 4:
                                        if (!(m.f && m.f.length)) m.f = [];
                                        if ((t & 7) === 2) {
                                            var c2 = r.uint32() + r.pos;
                                            while (r.pos < c2) m.f.push(r.float())
                                        } else m.f.push(r.float());
                                        break;
                                    case 5:
                                        if (!(m.b && m.b.length)) m.b = [];
                                        if ((t & 7) === 2) {
                                            var c2 = r.uint32() + r.pos;
                                            while (r.pos < c2) m.b.push(r.bool())
                                        } else m.b.push(r.bool());
                                        break;
                                    case 6:
                                        if (!(m.type && m.type.length)) m.type = [];
                                        if ((t & 7) === 2) {
                                            var c2 = r.uint32() + r.pos;
                                            while (r.pos < c2) m.type.push(r.int32())
                                        } else m.type.push(r.int32());
                                        break;
                                    case 7:
                                        if (!(m.shape && m.shape.length)) m.shape = [];
                                        m.shape.push($root.tensorflow.TensorShape.decode(r, r.uint32()));
                                        break;
                                    case 8:
                                        if (!(m.tensor && m.tensor.length)) m.tensor = [];
                                        m.tensor.push($root.tensorflow.Tensor.decode(r, r.uint32()));
                                        break;
                                    case 9:
                                        if (!(m.func && m.func.length)) m.func = [];
                                        m.func.push($root.tensorflow.NameAttrList.decode(r, r.uint32()));
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return ListValue
                    }();
                    return AttrValue
                }();
                tensorflow.NameAttrList = function () {
                    function NameAttrList(p) {
                        this.attr = {};
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    NameAttrList.prototype.name = "";
                    NameAttrList.prototype.attr = $util.emptyObject;
                    NameAttrList.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.NameAttrList, k;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.name = r.string();
                                    break;
                                case 2:
                                    r.skip().pos++;
                                    if (m.attr === $util.emptyObject) m.attr = {};
                                    k = r.string();
                                    r.pos++;
                                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return NameAttrList
                }();
                tensorflow.NodeDef = function () {
                    function NodeDef(p) {
                        this.input = [];
                        this.attr = {};
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    NodeDef.prototype.name = "";
                    NodeDef.prototype.op = "";
                    NodeDef.prototype.input = $util.emptyArray;
                    NodeDef.prototype.device = "";
                    NodeDef.prototype.attr = $util.emptyObject;
                    NodeDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.NodeDef, k;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.name = r.string();
                                    break;
                                case 2:
                                    m.op = r.string();
                                    break;
                                case 3:
                                    if (!(m.input && m.input.length)) m.input = [];
                                    m.input.push(r.string());
                                    break;
                                case 4:
                                    m.device = r.string();
                                    break;
                                case 5:
                                    r.skip().pos++;
                                    if (m.attr === $util.emptyObject) m.attr = {};
                                    k = r.string();
                                    r.pos++;
                                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return NodeDef
                }();
                tensorflow.VersionDef = function () {
                    function VersionDef(p) {
                        this.badConsumers = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    VersionDef.prototype.producer = 0;
                    VersionDef.prototype.minConsumer = 0;
                    VersionDef.prototype.badConsumers = $util.emptyArray;
                    VersionDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.VersionDef;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.producer = r.int32();
                                    break;
                                case 2:
                                    m.minConsumer = r.int32();
                                    break;
                                case 3:
                                    if (!(m.badConsumers && m.badConsumers.length)) m.badConsumers = [];
                                    if ((t & 7) === 2) {
                                        var c2 = r.uint32() + r.pos;
                                        while (r.pos < c2) m.badConsumers.push(r.int32())
                                    } else m.badConsumers.push(r.int32());
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return VersionDef
                }();
                tensorflow.GraphDef = function () {
                    function GraphDef(p) {
                        this.node = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    GraphDef.prototype.node = $util.emptyArray;
                    GraphDef.prototype.versions = null;
                    GraphDef.prototype.library = null;
                    GraphDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.GraphDef;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    if (!(m.node && m.node.length)) m.node = [];
                                    m.node.push($root.tensorflow.NodeDef.decode(r, r.uint32()));
                                    break;
                                case 4:
                                    m.versions = $root.tensorflow.VersionDef.decode(r, r.uint32());
                                    break;
                                case 2:
                                    m.library = $root.tensorflow.FunctionDefLibrary.decode(r, r.uint32());
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return GraphDef
                }();
                tensorflow.CollectionDef = function () {
                    function CollectionDef(p) {
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    CollectionDef.prototype.nodeList = null;
                    CollectionDef.prototype.bytesList = null;
                    CollectionDef.prototype.int64List = null;
                    CollectionDef.prototype.floatList = null;
                    CollectionDef.prototype.anyList = null;
                    var $oneOfFields;
                    Object.defineProperty(CollectionDef.prototype, "kind", {
                        get: $util.oneOfGetter($oneOfFields = ["nodeList", "bytesList", "int64List", "floatList", "anyList"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
                    CollectionDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.nodeList = $root.tensorflow.CollectionDef.NodeList.decode(r, r.uint32());
                                    break;
                                case 2:
                                    m.bytesList = $root.tensorflow.CollectionDef.BytesList.decode(r, r.uint32());
                                    break;
                                case 3:
                                    m.int64List = $root.tensorflow.CollectionDef.Int64List.decode(r, r.uint32());
                                    break;
                                case 4:
                                    m.floatList = $root.tensorflow.CollectionDef.FloatList.decode(r, r.uint32());
                                    break;
                                case 5:
                                    m.anyList = $root.tensorflow.CollectionDef.AnyList.decode(r, r.uint32());
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    CollectionDef.NodeList = function () {
                        function NodeList(p) {
                            this.value = [];
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        NodeList.prototype.value = $util.emptyArray;
                        NodeList.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l,
                                m = new $root.tensorflow.CollectionDef.NodeList;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        if (!(m.value && m.value.length)) m.value = [];
                                        m.value.push(r.string());
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return NodeList
                    }();
                    CollectionDef.BytesList = function () {
                        function BytesList(p) {
                            this.value = [];
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        BytesList.prototype.value = $util.emptyArray;
                        BytesList.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l,
                                m = new $root.tensorflow.CollectionDef.BytesList;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        if (!(m.value && m.value.length)) m.value = [];
                                        m.value.push(r.bytes());
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return BytesList
                    }();
                    CollectionDef.Int64List = function () {
                        function Int64List(p) {
                            this.value = [];
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        Int64List.prototype.value = $util.emptyArray;
                        Int64List.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l,
                                m = new $root.tensorflow.CollectionDef.Int64List;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        if (!(m.value && m.value.length)) m.value = [];
                                        if ((t & 7) === 2) {
                                            var c2 = r.uint32() + r.pos;
                                            while (r.pos < c2) m.value.push(r.int64())
                                        } else m.value.push(r.int64());
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return Int64List
                    }();
                    CollectionDef.FloatList = function () {
                        function FloatList(p) {
                            this.value = [];
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        FloatList.prototype.value = $util.emptyArray;
                        FloatList.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l,
                                m = new $root.tensorflow.CollectionDef.FloatList;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        if (!(m.value && m.value.length)) m.value = [];
                                        if ((t & 7) === 2) {
                                            var c2 = r.uint32() + r.pos;
                                            while (r.pos < c2) m.value.push(r.float())
                                        } else m.value.push(r.float());
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return FloatList
                    }();
                    CollectionDef.AnyList = function () {
                        function AnyList(p) {
                            this.value = [];
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        AnyList.prototype.value = $util.emptyArray;
                        AnyList.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.CollectionDef.AnyList;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        if (!(m.value && m.value.length)) m.value = [];
                                        m.value.push($root.tensorflow.Any.decode(r, r.uint32()));
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return AnyList
                    }();
                    return CollectionDef
                }();
                tensorflow.SaverDef = function () {
                    function SaverDef(p) {
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    SaverDef.prototype.filenameTensorName = "";
                    SaverDef.prototype.saveTensorName = "";
                    SaverDef.prototype.restoreOpName = "";
                    SaverDef.prototype.maxToKeep = 0;
                    SaverDef.prototype.sharded = false;
                    SaverDef.prototype.keepCheckpointEveryNHours = 0;
                    SaverDef.prototype.version = 0;
                    SaverDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SaverDef;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.filenameTensorName = r.string();
                                    break;
                                case 2:
                                    m.saveTensorName = r.string();
                                    break;
                                case 3:
                                    m.restoreOpName = r.string();
                                    break;
                                case 4:
                                    m.maxToKeep = r.int32();
                                    break;
                                case 5:
                                    m.sharded = r.bool();
                                    break;
                                case 6:
                                    m.keepCheckpointEveryNHours = r.float();
                                    break;
                                case 7:
                                    m.version = r.int32();
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    SaverDef.CheckpointFormatVersion = function () {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "LEGACY"] = 0;
                        values[valuesById[1] = "V1"] = 1;
                        values[valuesById[2] = "V2"] = 2;
                        return values
                    }();
                    return SaverDef
                }();
                tensorflow.TensorInfo = function () {
                    function TensorInfo(p) {
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    TensorInfo.prototype.name = "";
                    TensorInfo.prototype.cooSparse = null;
                    TensorInfo.prototype.dtype = 0;
                    TensorInfo.prototype.tensorShape = null;
                    var $oneOfFields;
                    Object.defineProperty(TensorInfo.prototype, "encoding", {
                        get: $util.oneOfGetter($oneOfFields = ["name", "cooSparse"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
                    TensorInfo.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorInfo;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.name = r.string();
                                    break;
                                case 4:
                                    m.cooSparse = $root.tensorflow.TensorInfo.CooSparse.decode(r, r.uint32());
                                    break;
                                case 2:
                                    m.dtype = r.int32();
                                    break;
                                case 3:
                                    m.tensorShape = $root.tensorflow.TensorShape.decode(r, r.uint32());
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    TensorInfo.CooSparse = function () {
                        function CooSparse(p) {
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        CooSparse.prototype.valuesTensorName = "";
                        CooSparse.prototype.indicesTensorName = "";
                        CooSparse.prototype.denseShapeTensorName = "";
                        CooSparse.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.TensorInfo.CooSparse;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        m.valuesTensorName = r.string();
                                        break;
                                    case 2:
                                        m.indicesTensorName = r.string();
                                        break;
                                    case 3:
                                        m.denseShapeTensorName = r.string();
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return CooSparse
                    }();
                    return TensorInfo
                }();
                tensorflow.SignatureDef = function () {
                    function SignatureDef(p) {
                        this.inputs = {};
                        this.outputs = {};
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    SignatureDef.prototype.inputs = $util.emptyObject;
                    SignatureDef.prototype.outputs = $util.emptyObject;
                    SignatureDef.prototype.methodName = "";
                    SignatureDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SignatureDef, k;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    r.skip().pos++;
                                    if (m.inputs === $util.emptyObject) m.inputs = {};
                                    k = r.string();
                                    r.pos++;
                                    m.inputs[k] = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                                    break;
                                case 2:
                                    r.skip().pos++;
                                    if (m.outputs === $util.emptyObject) m.outputs = {};
                                    k = r.string();
                                    r.pos++;
                                    m.outputs[k] = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                                    break;
                                case 3:
                                    m.methodName = r.string();
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return SignatureDef
                }();
                tensorflow.AssetFileDef = function () {
                    function AssetFileDef(p) {
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    AssetFileDef.prototype.tensorInfo = null;
                    AssetFileDef.prototype.filename = "";
                    AssetFileDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.AssetFileDef;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.tensorInfo = $root.tensorflow.TensorInfo.decode(r, r.uint32());
                                    break;
                                case 2:
                                    m.filename = r.string();
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return AssetFileDef
                }();
                tensorflow.OpDef = function () {
                    function OpDef(p) {
                        this.inputArg = [];
                        this.outputArg = [];
                        this.attr = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    OpDef.prototype.name = "";
                    OpDef.prototype.inputArg = $util.emptyArray;
                    OpDef.prototype.outputArg = $util.emptyArray;
                    OpDef.prototype.attr = $util.emptyArray;
                    OpDef.prototype.deprecation = null;
                    OpDef.prototype.summary = "";
                    OpDef.prototype.description = "";
                    OpDef.prototype.isCommutative = false;
                    OpDef.prototype.isAggregate = false;
                    OpDef.prototype.isStateful = false;
                    OpDef.prototype.allowsUninitializedInput = false;
                    OpDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.name = r.string();
                                    break;
                                case 2:
                                    if (!(m.inputArg && m.inputArg.length)) m.inputArg = [];
                                    m.inputArg.push($root.tensorflow.OpDef.ArgDef.decode(r, r.uint32()));
                                    break;
                                case 3:
                                    if (!(m.outputArg && m.outputArg.length)) m.outputArg = [];
                                    m.outputArg.push($root.tensorflow.OpDef.ArgDef.decode(r, r.uint32()));
                                    break;
                                case 4:
                                    if (!(m.attr && m.attr.length)) m.attr = [];
                                    m.attr.push($root.tensorflow.OpDef.AttrDef.decode(r, r.uint32()));
                                    break;
                                case 8:
                                    m.deprecation = $root.tensorflow.OpDef.OpDeprecation.decode(r, r.uint32());
                                    break;
                                case 5:
                                    m.summary = r.string();
                                    break;
                                case 6:
                                    m.description = r.string();
                                    break;
                                case 18:
                                    m.isCommutative = r.bool();
                                    break;
                                case 16:
                                    m.isAggregate = r.bool();
                                    break;
                                case 17:
                                    m.isStateful = r.bool();
                                    break;
                                case 19:
                                    m.allowsUninitializedInput = r.bool();
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    OpDef.ArgDef = function () {
                        function ArgDef(p) {
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        ArgDef.prototype.name = "";
                        ArgDef.prototype.description = "";
                        ArgDef.prototype.type = 0;
                        ArgDef.prototype.typeAttr = "";
                        ArgDef.prototype.numberAttr = "";
                        ArgDef.prototype.typeListAttr = "";
                        ArgDef.prototype.isRef = false;
                        ArgDef.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.ArgDef;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        m.name = r.string();
                                        break;
                                    case 2:
                                        m.description = r.string();
                                        break;
                                    case 3:
                                        m.type = r.int32();
                                        break;
                                    case 4:
                                        m.typeAttr = r.string();
                                        break;
                                    case 5:
                                        m.numberAttr = r.string();
                                        break;
                                    case 6:
                                        m.typeListAttr = r.string();
                                        break;
                                    case 16:
                                        m.isRef = r.bool();
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return ArgDef
                    }();
                    OpDef.AttrDef = function () {
                        function AttrDef(p) {
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        AttrDef.prototype.name = "";
                        AttrDef.prototype.type = "";
                        AttrDef.prototype.defaultValue = null;
                        AttrDef.prototype.description = "";
                        AttrDef.prototype.hasMinimum = false;
                        AttrDef.prototype.minimum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                        AttrDef.prototype.allowedValues = null;
                        AttrDef.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.AttrDef;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        m.name = r.string();
                                        break;
                                    case 2:
                                        m.type = r.string();
                                        break;
                                    case 3:
                                        m.defaultValue = $root.tensorflow.AttrValue.decode(r, r.uint32());
                                        break;
                                    case 4:
                                        m.description = r.string();
                                        break;
                                    case 5:
                                        m.hasMinimum = r.bool();
                                        break;
                                    case 6:
                                        m.minimum = r.int64();
                                        break;
                                    case 7:
                                        m.allowedValues = $root.tensorflow.AttrValue.decode(r, r.uint32());
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return AttrDef
                    }();
                    OpDef.OpDeprecation = function () {
                        function OpDeprecation(p) {
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        OpDeprecation.prototype.version = 0;
                        OpDeprecation.prototype.explanation = "";
                        OpDeprecation.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpDef.OpDeprecation;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        m.version = r.int32();
                                        break;
                                    case 2:
                                        m.explanation = r.string();
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return OpDeprecation
                    }();
                    return OpDef
                }();
                tensorflow.OpList = function () {
                    function OpList(p) {
                        this.op = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    OpList.prototype.op = $util.emptyArray;
                    OpList.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.OpList;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    if (!(m.op && m.op.length)) m.op = [];
                                    m.op.push($root.tensorflow.OpDef.decode(r, r.uint32()));
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return OpList
                }();
                tensorflow.MetaGraphDef = function () {
                    function MetaGraphDef(p) {
                        this.collectionDef = {};
                        this.signatureDef = {};
                        this.assetFileDef = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    MetaGraphDef.prototype.metaInfoDef = null;
                    MetaGraphDef.prototype.graphDef = null;
                    MetaGraphDef.prototype.saverDef = null;
                    MetaGraphDef.prototype.collectionDef = $util.emptyObject;
                    MetaGraphDef.prototype.signatureDef = $util.emptyObject;
                    MetaGraphDef.prototype.assetFileDef = $util.emptyArray;
                    MetaGraphDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.MetaGraphDef, k;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.metaInfoDef = $root.tensorflow.MetaGraphDef.MetaInfoDef.decode(r, r.uint32());
                                    break;
                                case 2:
                                    m.graphDef = $root.tensorflow.GraphDef.decode(r, r.uint32());
                                    break;
                                case 3:
                                    m.saverDef = $root.tensorflow.SaverDef.decode(r, r.uint32());
                                    break;
                                case 4:
                                    r.skip().pos++;
                                    if (m.collectionDef === $util.emptyObject) m.collectionDef = {};
                                    k = r.string();
                                    r.pos++;
                                    m.collectionDef[k] = $root.tensorflow.CollectionDef.decode(r, r.uint32());
                                    break;
                                case 5:
                                    r.skip().pos++;
                                    if (m.signatureDef === $util.emptyObject) m.signatureDef = {};
                                    k = r.string();
                                    r.pos++;
                                    m.signatureDef[k] = $root.tensorflow.SignatureDef.decode(r, r.uint32());
                                    break;
                                case 6:
                                    if (!(m.assetFileDef && m.assetFileDef.length)) m.assetFileDef = [];
                                    m.assetFileDef.push($root.tensorflow.AssetFileDef.decode(r, r.uint32()));
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    MetaGraphDef.MetaInfoDef = function () {
                        function MetaInfoDef(p) {
                            this.tags = [];
                            if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                        }

                        MetaInfoDef.prototype.metaGraphVersion = "";
                        MetaInfoDef.prototype.strippedOpList = null;
                        MetaInfoDef.prototype.anyInfo = null;
                        MetaInfoDef.prototype.tags = $util.emptyArray;
                        MetaInfoDef.prototype.tensorflowVersion = "";
                        MetaInfoDef.prototype.tensorflowGitVersion = "";
                        MetaInfoDef.decode = function decode(r, l) {
                            if (!(r instanceof $Reader)) r = $Reader.create(r);
                            var c = l === undefined ? r.len : r.pos + l,
                                m = new $root.tensorflow.MetaGraphDef.MetaInfoDef;
                            while (r.pos < c) {
                                var t = r.uint32();
                                switch (t >>> 3) {
                                    case 1:
                                        m.metaGraphVersion = r.string();
                                        break;
                                    case 2:
                                        m.strippedOpList = $root.tensorflow.OpList.decode(r, r.uint32());
                                        break;
                                    case 3:
                                        m.anyInfo = $root.tensorflow.Any.decode(r, r.uint32());
                                        break;
                                    case 4:
                                        if (!(m.tags && m.tags.length)) m.tags = [];
                                        m.tags.push(r.string());
                                        break;
                                    case 5:
                                        m.tensorflowVersion = r.string();
                                        break;
                                    case 6:
                                        m.tensorflowGitVersion = r.string();
                                        break;
                                    default:
                                        r.skipType(t & 7);
                                        break
                                }
                            }
                            return m
                        };
                        return MetaInfoDef
                    }();
                    return MetaGraphDef
                }();
                tensorflow.SavedModel = function () {
                    function SavedModel(p) {
                        this.metaGraphs = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    SavedModel.prototype.savedModelSchemaVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                    SavedModel.prototype.metaGraphs = $util.emptyArray;
                    SavedModel.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.SavedModel;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.savedModelSchemaVersion = r.int64();
                                    break;
                                case 2:
                                    if (!(m.metaGraphs && m.metaGraphs.length)) m.metaGraphs = [];
                                    m.metaGraphs.push($root.tensorflow.MetaGraphDef.decode(r, r.uint32()));
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return SavedModel
                }();
                tensorflow.FunctionDefLibrary = function () {
                    function FunctionDefLibrary(p) {
                        this["function"] = [];
                        this.gradient = [];
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    FunctionDefLibrary.prototype["function"] = $util.emptyArray;
                    FunctionDefLibrary.prototype.gradient = $util.emptyArray;
                    FunctionDefLibrary.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.FunctionDefLibrary;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    if (!(m["function"] && m["function"].length)) m["function"] = [];
                                    m["function"].push($root.tensorflow.FunctionDef.decode(r, r.uint32()));
                                    break;
                                case 2:
                                    if (!(m.gradient && m.gradient.length)) m.gradient = [];
                                    m.gradient.push($root.tensorflow.GradientDef.decode(r, r.uint32()));
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return FunctionDefLibrary
                }();
                tensorflow.FunctionDef = function () {
                    function FunctionDef(p) {
                        this.attr = {};
                        this.nodeDef = [];
                        this.ret = {};
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    FunctionDef.prototype.signature = null;
                    FunctionDef.prototype.attr = $util.emptyObject;
                    FunctionDef.prototype.nodeDef = $util.emptyArray;
                    FunctionDef.prototype.ret = $util.emptyObject;
                    FunctionDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.FunctionDef, k;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.signature = $root.tensorflow.OpDef.decode(r, r.uint32());
                                    break;
                                case 5:
                                    r.skip().pos++;
                                    if (m.attr === $util.emptyObject) m.attr = {};
                                    k = r.string();
                                    r.pos++;
                                    m.attr[k] = $root.tensorflow.AttrValue.decode(r, r.uint32());
                                    break;
                                case 3:
                                    if (!(m.nodeDef && m.nodeDef.length)) m.nodeDef = [];
                                    m.nodeDef.push($root.tensorflow.NodeDef.decode(r, r.uint32()));
                                    break;
                                case 4:
                                    r.skip().pos++;
                                    if (m.ret === $util.emptyObject) m.ret = {};
                                    k = r.string();
                                    r.pos++;
                                    m.ret[k] = r.string();
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return FunctionDef
                }();
                tensorflow.GradientDef = function () {
                    function GradientDef(p) {
                        if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]]
                    }

                    GradientDef.prototype.functionName = "";
                    GradientDef.prototype.gradientFunc = "";
                    GradientDef.decode = function decode(r, l) {
                        if (!(r instanceof $Reader)) r = $Reader.create(r);
                        var c = l === undefined ? r.len : r.pos + l, m = new $root.tensorflow.GradientDef;
                        while (r.pos < c) {
                            var t = r.uint32();
                            switch (t >>> 3) {
                                case 1:
                                    m.functionName = r.string();
                                    break;
                                case 2:
                                    m.gradientFunc = r.string();
                                    break;
                                default:
                                    r.skipType(t & 7);
                                    break
                            }
                        }
                        return m
                    };
                    return GradientDef
                }();
                return tensorflow
            }();
            module.exports = $root
        }, {"protobufjs/minimal": 197}],
        9: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ExecutionContext = function () {
                function ExecutionContext(weightMap) {
                    this.weightMap = weightMap;
                    this.rootContext = {id: 0, frameName: "", iterationId: 0};
                    this.contexts = [this.rootContext];
                    this.lastId = 0;
                    this.generateCurrentContextIds()
                }

                ExecutionContext.prototype.newFrame = function (id, frameName) {
                    return {id: id, frameName: frameName, iterationId: 0}
                };
                Object.defineProperty(ExecutionContext.prototype, "currentContext", {
                    get: function () {
                        return this.contexts
                    }, set: function (contexts) {
                        if (this.contexts !== contexts) {
                            this.contexts = contexts;
                            this.generateCurrentContextIds()
                        }
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(ExecutionContext.prototype, "currentContextId", {
                    get: function () {
                        return this._currentContextIds[0]
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(ExecutionContext.prototype, "currentContextIds", {
                    get: function () {
                        return this._currentContextIds
                    }, enumerable: true, configurable: true
                });
                ExecutionContext.prototype.generateCurrentContextIds = function () {
                    var names = [];
                    for (var i = 0; i < this.contexts.length - 1; i++) {
                        var contexts = this.contexts.slice(0, this.contexts.length - i);
                        names.push(this.contextIdforContexts(contexts))
                    }
                    names.push("");
                    this._currentContextIds = names
                };
                ExecutionContext.prototype.contextIdforContexts = function (contexts) {
                    return contexts ? contexts.map(function (context) {
                        return context.id === 0 && context.iterationId === 0 ? "" : context.frameName + "-" + context.iterationId
                    }).join("/") : ""
                };
                ExecutionContext.prototype.enterFrame = function (frameId) {
                    if (this.contexts) {
                        this.lastId++;
                        this.contexts = this.contexts.slice();
                        this.contexts.push(this.newFrame(this.lastId, frameId));
                        this._currentContextIds.unshift(this.contextIdforContexts(this.contexts))
                    }
                };
                ExecutionContext.prototype.exitFrame = function () {
                    if (this.contexts && this.contexts.length > 1) {
                        this.contexts = this.contexts.slice();
                        this.contexts.splice(-1);
                        this.currentContextIds.shift()
                    } else {
                        throw new Error("Cannot exit frame, the context is empty")
                    }
                };
                ExecutionContext.prototype.nextIteration = function () {
                    if (this.contexts && this.contexts.length > 0) {
                        this.contexts = this.contexts.slice();
                        this.lastId++;
                        var context = Object.assign({}, this.contexts[this.contexts.length - 1]);
                        context.iterationId += 1;
                        context.id = this.lastId;
                        this.contexts.splice(-1, 1, context);
                        this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts))
                    } else {
                        throw new Error("Cannot increase frame iteration, the context is empty")
                    }
                };
                ExecutionContext.prototype.getWeight = function (name) {
                    return this.weightMap[name]
                };
                return ExecutionContext
            }();
            exports.ExecutionContext = ExecutionContext
        }, {}],
        10: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var Url = require("url");
            var compiled_api_1 = require("../data/compiled_api");
            var operation_mapper_1 = require("../operations/operation_mapper");
            var graph_executor_1 = require("./graph_executor");
            var FrozenModel = function () {
                function FrozenModel(modelUrl, weightManifestUrl, requestOption) {
                    this.modelUrl = modelUrl;
                    this.weightManifestUrl = weightManifestUrl;
                    this.requestOption = requestOption;
                    this.version = "n/a";
                    this.pathPrefix = this.getPathPrefix()
                }

                Object.defineProperty(FrozenModel.prototype, "modelVersion", {
                    get: function () {
                        return this.version
                    }, enumerable: true, configurable: true
                });
                FrozenModel.prototype.getPathPrefix = function () {
                    var url = Url.parse(this.weightManifestUrl);
                    var segments = url.pathname.split("/");
                    segments.splice(-1);
                    url.pathname = segments.join("/");
                    return Url.format(url) + "/"
                };
                FrozenModel.prototype.loadRemoteProtoFile = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var response, _a, _b, _c, error_1;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    _d.trys.push([0, 3, , 4]);
                                    return [4, fetch(this.modelUrl, this.requestOption)];
                                case 1:
                                    response = _d.sent();
                                    _b = (_a = compiled_api_1.tensorflow.GraphDef).decode;
                                    _c = Uint8Array.bind;
                                    return [4, response.arrayBuffer()];
                                case 2:
                                    return [2, _b.apply(_a, [new (_c.apply(Uint8Array, [void 0, _d.sent()]))])];
                                case 3:
                                    error_1 = _d.sent();
                                    throw new Error(this.modelUrl + " not found. " + error_1);
                                case 4:
                                    return [2]
                            }
                        })
                    })
                };
                FrozenModel.prototype.loadWeightManifest = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var manifest, _a, error_2;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _b.trys.push([0, 3, , 4]);
                                    return [4, fetch(this.weightManifestUrl, this.requestOption)];
                                case 1:
                                    manifest = _b.sent();
                                    _a = this;
                                    return [4, manifest.clone().json()];
                                case 2:
                                    _a.weightManifest = _b.sent();
                                    return [3, 4];
                                case 3:
                                    error_2 = _b.sent();
                                    throw new Error(this.weightManifestUrl + " not found. " + error_2);
                                case 4:
                                    return [2]
                            }
                        })
                    })
                };
                FrozenModel.prototype.load = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var graphPromise, manifestPromise, graph, weightMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    graphPromise = this.loadRemoteProtoFile();
                                    manifestPromise = this.loadWeightManifest();
                                    return [4, Promise.all([graphPromise, manifestPromise])];
                                case 1:
                                    graph = _a.sent()[0];
                                    this.version = graph.versions.producer + "." + graph.versions.minConsumer;
                                    return [4, tfc.io.loadWeights(this.weightManifest, this.pathPrefix, undefined, this.requestOption)];
                                case 2:
                                    weightMap = _a.sent();
                                    this.executor = new graph_executor_1.GraphExecutor(operation_mapper_1.OperationMapper.Instance.transformGraph(graph));
                                    this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
                                    return [2, true]
                            }
                        })
                    })
                };
                FrozenModel.prototype.execute = function (inputs, outputs) {
                    if (this.executor.isControlFlowModel) {
                        throw new Error("The model contains control flow ops, " + "please use executeAsync method")
                    }
                    var result = this.executor.execute(this.convertTensorMapToTensorsMap(inputs), outputs);
                    var keys = Object.keys(result);
                    return keys.length === 1 ? result[keys[0]] : result
                };
                FrozenModel.prototype.executeAsync = function (inputs, outputs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var result, keys;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.executor.isControlFlowModel) {
                                        throw new Error("The model does not contain control flow ops, " + "please use execute method for better performance.")
                                    }
                                    return [4, this.executor.executeAsync(this.convertTensorMapToTensorsMap(inputs), outputs)];
                                case 1:
                                    result = _a.sent();
                                    keys = Object.keys(result);
                                    return [2, keys.length === 1 ? result[keys[0]] : result]
                            }
                        })
                    })
                };
                FrozenModel.prototype.convertTensorMapToTensorsMap = function (map) {
                    return Object.keys(map).reduce(function (newMap, key) {
                        newMap[key] = [map[key]];
                        return newMap
                    }, {})
                };
                FrozenModel.prototype.dispose = function () {
                    this.executor.dispose()
                };
                return FrozenModel
            }();
            exports.FrozenModel = FrozenModel;

            function loadFrozenModel(modelUrl, weightsManifestUrl, requestOption) {
                return __awaiter(this, void 0, void 0, function () {
                    var model;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                model = new FrozenModel(modelUrl, weightsManifestUrl, requestOption);
                                return [4, model.load()];
                            case 1:
                                _a.sent();
                                return [2, model]
                        }
                    })
                })
            }

            exports.loadFrozenModel = loadFrozenModel
        }, {
            "../data/compiled_api": 8,
            "../operations/operation_mapper": 41,
            "./graph_executor": 11,
            "@tensorflow/tfjs-core": 50,
            url: 220
        }],
        11: [function (require, module, exports) {
            "use strict";
            var __assign = this && this.__assign || Object.assign || function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var utils_1 = require("../operations/executors/utils");
            var operation_executor_1 = require("../operations/operation_executor");
            var execution_context_1 = require("./execution_context");
            var GraphExecutor = function () {
                function GraphExecutor(graph) {
                    this.graph = graph;
                    this.compiledOrder = [];
                    this._weightMap = {};
                    this.placeholders = graph.placeholders.map(function (node) {
                        return node.name
                    });
                    this.outputs = graph.outputs.map(function (node) {
                        return node.name
                    });
                    this.compile()
                }

                Object.defineProperty(GraphExecutor.prototype, "weightMap", {
                    get: function () {
                        return this._weightMap
                    }, set: function (weightMap) {
                        var weightIds = Object.keys(weightMap).map(function (key) {
                            return weightMap[key].map(function (tensor) {
                                return tensor.id
                            })
                        });
                        this.weightIds = [].concat.apply([], weightIds);
                        this._weightMap = weightMap
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GraphExecutor.prototype, "inputNodes", {
                    get: function () {
                        return this.placeholders
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GraphExecutor.prototype, "outputNodes", {
                    get: function () {
                        return this.outputs
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GraphExecutor.prototype, "isControlFlowModel", {
                    get: function () {
                        return this.graph.withControlFlow
                    }, enumerable: true, configurable: true
                });
                GraphExecutor.prototype.compile = function () {
                    if (this.graph.withControlFlow) {
                        return
                    }
                    var stack = this.graph.inputs.slice();
                    var visited = {};
                    while (stack.length > 0) {
                        var node = stack.pop();
                        visited[node.name] = true;
                        this.compiledOrder.push(node);
                        node.children.forEach(function (childNode) {
                            if (!visited[childNode.name] && childNode.inputNames.every(function (name) {
                                var nodeName = utils_1.getNodeNameAndIndex(name)[0];
                                return visited[nodeName]
                            })) {
                                stack.push(childNode)
                            }
                        })
                    }
                };
                GraphExecutor.prototype.execute = function (inputs, outputs) {
                    var _this = this;
                    this.checkInput(inputs);
                    var result = tfjs_core_1.tidy(function () {
                        var context = new execution_context_1.ExecutionContext(_this._weightMap);
                        var tensors = _this.compiledOrder.reduce(function (map, node) {
                            map[node.name] = operation_executor_1.executeOp(node, map, context);
                            return map
                        }, __assign({}, _this.weightMap, inputs));
                        return _this.findOutputs(tensors, context, outputs)
                    });
                    return result
                };
                GraphExecutor.prototype.executeAsync = function (inputs, outputs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var context, tensors, results, outputIds, inputIdArray, inputIds;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    context = new execution_context_1.ExecutionContext(this._weightMap);
                                    return [4, this.executeWithControlFlow(inputs, context)];
                                case 1:
                                    tensors = _a.sent();
                                    results = this.findOutputs(tensors, context, outputs);
                                    outputIds = Object.keys(results).map(function (key) {
                                        return results[key].id
                                    });
                                    inputIdArray = Object.keys(inputs).map(function (key) {
                                        return inputs[key].map(function (input) {
                                            return input.id
                                        })
                                    });
                                    inputIds = [].concat.apply([], inputIdArray);
                                    Object.keys(tensors).forEach(function (key) {
                                        var tensorArray = tensors[key];
                                        tensorArray.forEach(function (tensor) {
                                            if (tensor && outputIds.indexOf(tensor.id) === -1 && inputIds.indexOf(tensor.id) === -1 && _this.weightIds.indexOf(tensor.id) === -1) {
                                                tensor.dispose()
                                            }
                                        })
                                    });
                                    return [2, results]
                            }
                        })
                    })
                };
                GraphExecutor.prototype.executeWithControlFlow = function (inputs, context) {
                    return __awaiter(this, void 0, void 0, function () {
                        var stack, tensorMap, added, item, tensors, nodeName, _a, _b;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    stack = this.graph.inputs.map(function (node) {
                                        return {node: node, contexts: context.currentContext}
                                    });
                                    tensorMap = __assign({}, this.weightMap, inputs);
                                    added = {};
                                    _c.label = 1;
                                case 1:
                                    if (!(stack.length > 0)) return [3, 3];
                                    item = stack.pop();
                                    context.currentContext = item.contexts;
                                    tensors = operation_executor_1.executeOp(item.node, tensorMap, context);
                                    nodeName = utils_1.getNodeNameAndIndex(item.node.name, context)[0];
                                    _a = tensorMap;
                                    _b = nodeName;
                                    return [4, tensors];
                                case 2:
                                    _a[_b] = _c.sent();
                                    item.node.children.forEach(function (childNode) {
                                        var nodeName = utils_1.getNodeNameAndIndex(childNode.name, context)[0];
                                        if (!added[nodeName]) {
                                            if (childNode.op === "merge") {
                                                if (childNode.inputNames.some(function (name) {
                                                    return !!utils_1.getTensor(name, tensorMap, context)
                                                })) {
                                                    added[nodeName] = true;
                                                    stack.push({contexts: context.currentContext, node: childNode})
                                                }
                                            } else if (childNode.inputNames.every(function (name) {
                                                return !!utils_1.getTensor(name, tensorMap, context)
                                            })) {
                                                added[nodeName] = true;
                                                stack.push({contexts: context.currentContext, node: childNode})
                                            }
                                        }
                                    });
                                    return [3, 1];
                                case 3:
                                    return [2, tensorMap]
                            }
                        })
                    })
                };
                GraphExecutor.prototype.findOutputs = function (tensorMap, context, outputs) {
                    if (outputs && !(outputs instanceof Array)) {
                        outputs = [outputs]
                    }
                    var requestedOutputs = outputs || this.graph.outputs.map(function (node) {
                        return node.name
                    });
                    return requestedOutputs.reduce(function (map, name) {
                        map[name] = utils_1.getTensor(name, tensorMap, context);
                        return map
                    }, {})
                };
                GraphExecutor.prototype.dispose = function () {
                    var _this = this;
                    Object.keys(this.weightMap).forEach(function (key) {
                        return _this.weightMap[key].forEach(function (tensor) {
                            return tensor.dispose()
                        })
                    })
                };
                GraphExecutor.prototype.checkInput = function (inputs) {
                    var _this = this;
                    var inputKeys = Object.keys(inputs);
                    var missing = [];
                    var extra = [];
                    this.placeholders.forEach(function (name) {
                        if (inputKeys.indexOf(name) === -1) missing.push(name)
                    });
                    inputKeys.forEach(function (name) {
                        if (_this.placeholders.indexOf(name) === -1) extra.push(name)
                    });
                    if (missing.length > 0) {
                        throw new Error("The dict provided in model.execute(dict) has the keys " + ("[" + inputKeys + "], but is missing the required keys: [" + missing + "]."))
                    }
                    if (extra.length > 0) {
                        throw new Error("The dict provided in model.execute(dict) has " + ("unused keys: [" + extra + "]. Please provide only the following keys: ") + ("[" + this.placeholders + "]."))
                    }
                };
                return GraphExecutor
            }();
            exports.GraphExecutor = GraphExecutor
        }, {
            "../operations/executors/utils": 26,
            "../operations/operation_executor": 40,
            "./execution_context": 9,
            "@tensorflow/tfjs-core": 50
        }],
        12: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var frozen_model_1 = require("./executor/frozen_model");
            exports.FrozenModel = frozen_model_1.FrozenModel;
            exports.loadFrozenModel = frozen_model_1.loadFrozenModel;
            var version_1 = require("./version");
            exports.version_converter = version_1.version
        }, {"./executor/frozen_model": 10, "./version": 42}],
        13: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"add": {
                        return [tfc.add(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"mod":
                        return [tfc.mod(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))];
                    case"mul":
                        return [tfc.mul(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))];
                    case"div": {
                        return [tfc.div(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"sub": {
                        return [tfc.sub(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"minimum": {
                        return [tfc.minimum(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"maximum": {
                        return [tfc.maximum(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"pow": {
                        return [tfc.pow(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"squaredDifference": {
                        return [tfc.squaredDifference(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "arithmetic"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        14: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"abs":
                        return [tfc.abs(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"acos":
                        return [tfc.acos(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"acosh":
                        return [tfc.acosh(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"asin":
                        return [tfc.asin(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"asinh":
                        return [tfc.asinh(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"atan":
                        return [tfc.atan(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"atanh":
                        return [tfc.atanh(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"ceil":
                        return [tfc.ceil(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"cos":
                        return [tfc.cos(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"cosh":
                        return [tfc.cosh(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"elu":
                        return [tfc.elu(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"erf":
                        return [tfc.erf(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"exp":
                        return [tfc.exp(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"expm1": {
                        return [tfc.expm1(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"floor":
                        return [tfc.floor(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"log":
                        return [tfc.log(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"log1p": {
                        return [tfc.log1p(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"neg":
                        return [tfc.neg(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"reciprocal": {
                        return [tfc.reciprocal(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"relu":
                        return [tfc.relu(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"round": {
                        return [tfc.round(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"selu":
                        return [tfc.selu(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"sigmoid":
                        return [tfc.sigmoid(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"sin":
                        return [tfc.sin(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"sign": {
                        return [tfc.sign(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"sinh": {
                        return [tfc.sinh(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"softplus": {
                        return [tfc.softplus(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"sqrt": {
                        return [tfc.sqrt(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"square": {
                        return [tfc.square(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"tanh": {
                        return [tfc.tanh(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"tan":
                        return [tfc.tan(utils_1.getParamValue("x", node, tensorMap, context))];
                    case"clipByValue":
                        return [tfc.clipByValue(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("clipValueMin", node, tensorMap, context), utils_1.getParamValue("clipValueMax", node, tensorMap, context))];
                    case"rsqrt":
                        return [tfc.div(tfc.scalar(1, "float32"), tfc.sqrt(utils_1.getTensor(node.inputNames[0], tensorMap, context)))];
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "basic_math"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        15: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var utils_1 = require("./utils");

            function executeOp(node, tensorMap, context) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, pred, data_1, inputName, frameId, data, tensor, input;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _a = node.op;
                                switch (_a) {
                                    case"loopCond":
                                        return [3, 1];
                                    case"switch":
                                        return [3, 2];
                                    case"merge":
                                        return [3, 4];
                                    case"enter":
                                        return [3, 5];
                                    case"exit":
                                        return [3, 6];
                                    case"nextIteration":
                                        return [3, 7]
                                }
                                return [3, 8];
                            case 1:
                                return [2, [utils_1.getParamValue("pred", node, tensorMap, context)]];
                            case 2:
                                pred = utils_1.getParamValue("pred", node, tensorMap, context);
                                data_1 = utils_1.getParamValue("data", node, tensorMap, context);
                                return [4, pred.data()];
                            case 3:
                                return [2, _b.sent()[0] ? [undefined, data_1] : [data_1, undefined]];
                            case 4:
                                inputName = node.inputNames.find(function (name) {
                                    return utils_1.getTensor(name, tensorMap, context) !== undefined
                                });
                                return [2, inputName ? [utils_1.getTensor(inputName, tensorMap, context)] : undefined];
                            case 5:
                                frameId = utils_1.getParamValue("frameName", node, tensorMap, context);
                                data = utils_1.getParamValue("tensor", node, tensorMap, context);
                                context.enterFrame(frameId);
                                return [2, [data]];
                            case 6:
                                tensor = utils_1.getParamValue("tensor", node, tensorMap, context);
                                context.exitFrame();
                                return [2, [tensor]];
                            case 7:
                                input = utils_1.getParamValue("tensor", node, tensorMap, context);
                                context.nextIteration();
                                return [2, [input]];
                            case 8:
                                throw TypeError("Node type " + node.op + " is not implemented")
                        }
                    })
                })
            }

            exports.executeOp = executeOp;
            exports.CATEGORY = "control"
        }, {"./utils": 26}],
        16: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"conv1d": {
                        var stride = utils_1.getParamValue("stride", node, tensorMap, context);
                        var pad = utils_1.getParamValue("pad", node, tensorMap, context);
                        var dataFormat = utils_1.getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
                        var dilation = utils_1.getParamValue("dilation", node, tensorMap, context);
                        return [tfc.conv1d(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("filter", node, tensorMap, context), stride, pad, dataFormat, dilation)]
                    }
                    case"conv2d": {
                        var stride = utils_1.getParamValue("strides", node, tensorMap, context);
                        var pad = utils_1.getParamValue("pad", node, tensorMap, context);
                        var dataFormat = utils_1.getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
                        var dilations = utils_1.getParamValue("dilations", node, tensorMap, context);
                        return [tfc.conv2d(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])]
                    }
                    case"conv2dTranspose": {
                        var shape = utils_1.getParamValue("outputShape", node, tensorMap, context);
                        var stride = utils_1.getParamValue("strides", node, tensorMap, context);
                        var pad = utils_1.getParamValue("pad", node, tensorMap, context);
                        return [tfc.conv2dTranspose(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("filter", node, tensorMap, context), shape, [stride[1], stride[2]], pad)]
                    }
                    case"depthwiseConv2d": {
                        var stride = utils_1.getParamValue("strides", node, tensorMap, context);
                        var pad = utils_1.getParamValue("pad", node, tensorMap, context);
                        var dilations = utils_1.getParamValue("dilations", node, tensorMap, context);
                        var dataFormat = utils_1.getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
                        return [tfc.depthwiseConv2d(utils_1.getParamValue("input", node, tensorMap, context), utils_1.getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])]
                    }
                    case"avgPool": {
                        var stride = utils_1.getParamValue("strides", node, tensorMap, context);
                        var pad = utils_1.getParamValue("pad", node, tensorMap, context);
                        var kernelSize = utils_1.getParamValue("kernelSize", node, tensorMap, context);
                        return [tfc.avgPool(utils_1.getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)]
                    }
                    case"maxPool": {
                        var stride = utils_1.getParamValue("strides", node, tensorMap, context);
                        var pad = utils_1.getParamValue("pad", node, tensorMap, context);
                        var kernelSize = utils_1.getParamValue("kernelSize", node, tensorMap, context);
                        return [tfc.maxPool(utils_1.getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)]
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "convolution"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        17: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"fill": {
                        var shape = utils_1.getParamValue("shape", node, tensorMap, context);
                        var value = utils_1.getParamValue("value", node, tensorMap, context);
                        return [tfc.fill(shape, value)]
                    }
                    case"linspace": {
                        var start = utils_1.getParamValue("start", node, tensorMap, context);
                        var stop_1 = utils_1.getParamValue("stop", node, tensorMap, context);
                        var num = utils_1.getParamValue("num", node, tensorMap, context);
                        return [tfc.linspace(start, stop_1, num)]
                    }
                    case"oneHot": {
                        var indices = utils_1.getParamValue("indices", node, tensorMap, context);
                        var depth = utils_1.getParamValue("depth", node, tensorMap, context);
                        var onValue = utils_1.getParamValue("onValue", node, tensorMap, context);
                        var offValue = utils_1.getParamValue("offValue", node, tensorMap, context);
                        return [tfc.oneHot(indices, depth, onValue, offValue)]
                    }
                    case"ones": {
                        return [tfc.ones(utils_1.getParamValue("shape", node, tensorMap, context), utils_1.getParamValue("dtype", node, tensorMap, context))]
                    }
                    case"onesLike": {
                        return [tfc.onesLike(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    case"randomUniform": {
                        return [tfc.randomUniform(utils_1.getParamValue("shape", node, tensorMap, context), utils_1.getParamValue("minval", node, tensorMap, context), utils_1.getParamValue("maxval", node, tensorMap, context), utils_1.getParamValue("dtype", node, tensorMap, context))]
                    }
                    case"range": {
                        var start = utils_1.getParamValue("start", node, tensorMap, context);
                        var stop_2 = utils_1.getParamValue("stop", node, tensorMap, context);
                        var step = utils_1.getParamValue("step", node, tensorMap, context);
                        return [tfc.range(start, stop_2, step, utils_1.getParamValue("dtype", node, tensorMap, context))]
                    }
                    case"truncatedNormal": {
                        var shape = utils_1.getParamValue("shape", node, tensorMap, context);
                        var mean = utils_1.getParamValue("mean", node, tensorMap, context);
                        var stdDev = utils_1.getParamValue("stdDev", node, tensorMap, context);
                        var seed = utils_1.getParamValue("seed", node, tensorMap, context);
                        return [tfc.truncatedNormal(shape, mean, stdDev, utils_1.getParamValue("dtype", node, tensorMap, context), seed)]
                    }
                    case"zeros": {
                        return [tfc.zeros(utils_1.getParamValue("shape", node, tensorMap, context), utils_1.getParamValue("dtype", node, tensorMap, context))]
                    }
                    case"zerosLike": {
                        return [tfc.zerosLike(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "creation"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        18: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"const": {
                        return tensorMap[node.name]
                    }
                    case"placeholder":
                        var def = utils_1.getParamValue("default", node, tensorMap, context);
                        return [utils_1.getTensor(node.name, tensorMap, context) || def];
                    case"identity":
                    case"stopGradient":
                    case"fakeQuantWithMinMaxVars":
                        return [utils_1.getParamValue("x", node, tensorMap, context)];
                    case"snapshot":
                        var snapshot = utils_1.getParamValue("x", node, tensorMap, context);
                        return [snapshot.clone()];
                    case"shape":
                        return [tfc.tensor1d(utils_1.getParamValue("x", node, tensorMap, context).shape, "int32")];
                    case"noop":
                        return [];
                    case"print":
                        var input = utils_1.getParamValue("x", node, tensorMap, context);
                        var data = utils_1.getParamValue("data", node, tensorMap, context);
                        var message = utils_1.getParamValue("message", node, tensorMap, context);
                        var summarize = utils_1.getParamValue("summarize", node, tensorMap, context);
                        console.warn("The graph has a tf.print() operation," + "usually used for debugging, which slows down performance.");
                        console.log(message);
                        for (var i = 0; i < data.length; i++) {
                            console.log(Array.prototype.slice.call(data[0].dataSync()).slice(0, summarize))
                        }
                        return [input];
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "graph"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        19: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"resizeBilinear": {
                        var images = utils_1.getParamValue("images", node, tensorMap, context);
                        var size = utils_1.getParamValue("size", node, tensorMap, context);
                        var alignCorners = utils_1.getParamValue("alignCorners", node, tensorMap, context);
                        return [tfc.image.resizeBilinear(images, [size[0], size[1]], alignCorners)]
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "image"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        20: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"equal": {
                        return [tfc.equal(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"notEqual": {
                        return [tfc.notEqual(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"greater": {
                        return [tfc.greater(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"greaterEqual": {
                        return [tfc.greaterEqual(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"less": {
                        return [tfc.less(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"lessEqual": {
                        return [tfc.lessEqual(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"logicalAnd": {
                        return [tfc.logicalAnd(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"logicalNot": {
                        return [tfc.logicalNot(utils_1.getParamValue("a", node, tensorMap, context))]
                    }
                    case"logicalOr": {
                        return [tfc.logicalOr(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    case"where": {
                        return [tfc.where(utils_1.getParamValue("condition", node, tensorMap, context), utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context))]
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "logical"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        21: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"matMul":
                        return [tfc.matMul(utils_1.getParamValue("a", node, tensorMap, context), utils_1.getParamValue("b", node, tensorMap, context), utils_1.getParamValue("transposeA", node, tensorMap, context), utils_1.getParamValue("transposeB", node, tensorMap, context))];
                    case"transpose":
                        return [tfc.transpose(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("perm", node, tensorMap, context))];
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "matrices"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        22: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"batchNormalization": {
                        return [tfc.batchNormalization(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("mean", node, tensorMap, context), utils_1.getParamValue("variance", node, tensorMap, context), utils_1.getParamValue("epsilon", node, tensorMap, context), utils_1.getParamValue("scale", node, tensorMap, context), utils_1.getParamValue("offset", node, tensorMap, context))]
                    }
                    case"localResponseNormalization": {
                        return [tfc.localResponseNormalization(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("radius", node, tensorMap, context), utils_1.getParamValue("bias", node, tensorMap, context), utils_1.getParamValue("alpha", node, tensorMap, context), utils_1.getParamValue("beta", node, tensorMap, context))]
                    }
                    case"softmax": {
                        return [tfc.softmax(utils_1.getParamValue("x", node, tensorMap, context))]
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "normalization"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        23: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"max": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        var keepDims = utils_1.getParamValue("keepDims", node, tensorMap, context);
                        return [tfc.max(utils_1.getParamValue("x", node, tensorMap, context), axis, keepDims)]
                    }
                    case"mean": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        var keepDims = utils_1.getParamValue("keepDims", node, tensorMap, context);
                        return [tfc.mean(utils_1.getParamValue("x", node, tensorMap, context), axis, keepDims)]
                    }
                    case"min": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        var keepDims = utils_1.getParamValue("keepDims", node, tensorMap, context);
                        return [tfc.min(utils_1.getParamValue("x", node, tensorMap, context), axis, keepDims)]
                    }
                    case"sum": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        var keepDims = utils_1.getParamValue("keepDims", node, tensorMap, context);
                        return [tfc.sum(utils_1.getParamValue("x", node, tensorMap, context), axis, keepDims)]
                    }
                    case"argMax": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        return [tfc.argMax(utils_1.getParamValue("x", node, tensorMap, context), axis)]
                    }
                    case"argMin": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        return [tfc.argMin(utils_1.getParamValue("x", node, tensorMap, context), axis)]
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "reduction"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        24: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"concat": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        var inputs = utils_1.getParamValue("tensors", node, tensorMap, context);
                        return [tfc.concat(inputs, axis)]
                    }
                    case"gather": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        var input = utils_1.getParamValue("x", node, tensorMap, context);
                        var indices = utils_1.getParamValue("indices", node, tensorMap, context);
                        return [tfc.gather(input, indices, axis)]
                    }
                    case"reverse": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        var input = utils_1.getParamValue("x", node, tensorMap, context);
                        return [tfc.reverse(input, axis)]
                    }
                    case"slice": {
                        var begin = utils_1.getParamValue("begin", node, tensorMap, context);
                        var size = utils_1.getParamValue("size", node, tensorMap, context);
                        return [tfc.slice(utils_1.getParamValue("x", node, tensorMap, context), begin, size)]
                    }
                    case"stridedSlice": {
                        var begin = utils_1.getParamValue("begin", node, tensorMap, context);
                        var end = utils_1.getParamValue("end", node, tensorMap, context);
                        var strides = utils_1.getParamValue("strides", node, tensorMap, context);
                        var beginMask = utils_1.getParamValue("beginMask", node, tensorMap, context);
                        var endMask = utils_1.getParamValue("endMask", node, tensorMap, context);
                        return [tfc.stridedSlice(utils_1.getParamValue("x", node, tensorMap, context), begin, end, strides, beginMask, endMask)]
                    }
                    case"stack": {
                        return tfc.tidy(function () {
                            var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                            var tensors = utils_1.getParamValue("tensors", node, tensorMap, context);
                            var shape = tensors[0].shape;
                            var squeezedShape = tensors[0].squeeze().shape;
                            var mapped = tensors.map(function (tensor) {
                                var sameShape = tfc.util.arraysEqual(tensor.shape, shape);
                                if (!sameShape && !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {
                                    throw new Error("the input tensors shape does not match")
                                }
                                return sameShape ? tensor : tensor.reshape(shape)
                            });
                            return [tfc.stack(mapped, axis)]
                        })
                    }
                    case"tile": {
                        var reps = utils_1.getParamValue("reps", node, tensorMap, context);
                        return [tfc.tile(utils_1.getParamValue("x", node, tensorMap, context), reps)]
                    }
                    case"split": {
                        var axis = utils_1.getParamValue("axis", node, tensorMap, context);
                        var numOrSizeSplits = utils_1.getParamValue("numOrSizeSplits", node, tensorMap, context);
                        return tfc.split(utils_1.getParamValue("x", node, tensorMap, context), numOrSizeSplits, axis)
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "slice_join"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        25: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var utils_1 = require("./utils");
            exports.executeOp = function (node, tensorMap, context) {
                switch (node.op) {
                    case"cast": {
                        return [tfc.cast(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("dtype", node, tensorMap, context))]
                    }
                    case"expandDims": {
                        var axis = node.params["axis"].value;
                        return [tfc.expandDims(utils_1.getParamValue("x", node, tensorMap, context), axis)]
                    }
                    case"squeeze": {
                        var axis = node.params["axis"].value;
                        return [tfc.squeeze(utils_1.getParamValue("x", node, tensorMap, context), axis)]
                    }
                    case"reshape": {
                        return [tfc.reshape(utils_1.getParamValue("x", node, tensorMap, context), utils_1.getParamValue("shape", node, tensorMap, context))]
                    }
                    case"pad": {
                        return [tfc.pad(utils_1.getParamValue("x", node, tensorMap, context), utils_1.split(utils_1.getParamValue("padding", node, tensorMap, context), 2), utils_1.getParamValue("constantValue", node, tensorMap, context))]
                    }
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            };
            exports.CATEGORY = "transformation"
        }, {"./utils": 26, "@tensorflow/tfjs-core": 50}],
        26: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function getParamValue(paramName, node, tensorMap, context) {
                var param = node.params[paramName];
                if (param && param.inputIndex !== undefined) {
                    if (param.type === "tensor") {
                        return getTensor(node.inputNames[param.inputIndex], tensorMap, context)
                    }
                    if (param.type === "tensors") {
                        var inputs = param.inputIndex === 0 ? param.inputParamLength === 0 ? node.inputNames : node.inputNames.slice(param.inputIndex, -param.inputParamLength) : node.inputNames.splice(param.inputIndex);
                        return inputs.map(function (name) {
                            return getTensor(name, tensorMap, context)
                        })
                    }
                    var data = Array.prototype.slice.call(getTensor(node.inputNames.slice(param.inputIndex)[0], tensorMap, context).dataSync());
                    return param.type === "number" ? data[0] : data
                }
                return param && param.value
            }

            exports.getParamValue = getParamValue;

            function getTensor(name, tensorsMap, context) {
                var _a = parseNodeName(name), nodeName = _a[0], index = _a[1];
                var contextId = context.currentContextIds.find(function (contextId) {
                    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)]
                });
                return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined
            }

            exports.getTensor = getTensor;

            function getNodeNameAndIndex(inputName, context) {
                var _a = parseNodeName(inputName), nodeName = _a[0], index = _a[1];
                return [getNodeNameWithContextId(nodeName, context && context.currentContextId), index]
            }

            exports.getNodeNameAndIndex = getNodeNameAndIndex;

            function getNodeNameWithContextId(name, contextId) {
                return !!contextId ? name + "-" + contextId : name
            }

            function parseNodeName(name) {
                var index = name.lastIndexOf(":");
                if (index === -1) return [name, 0];
                var nodeName = name.substring(0, index);
                return [nodeName, Number(name.substring(index + 1))]
            }

            exports.parseNodeName = parseNodeName;

            function split(arr, size) {
                var res = [];
                for (var i = 0; i < arr.length; i += size) {
                    res.push(arr.slice(i, i + size))
                }
                return res
            }

            exports.split = split
        }, {}],
        27: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "Add",
                dlOpName: "add",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "BiasAdd",
                dlOpName: "add",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Sub",
                dlOpName: "sub",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "RealDiv",
                dlOpName: "div",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Div",
                dlOpName: "div",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Mul",
                dlOpName: "mul",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Maximum",
                dlOpName: "maximum",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Minimum",
                dlOpName: "minimum",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Pow",
                dlOpName: "pow",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "SquaredDifference",
                dlOpName: "squaredDifference",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Mod",
                dlOpName: "mod",
                category: "arithmetic",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }]
        }, {}],
        28: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "Abs",
                dlOpName: "abs",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Acos",
                dlOpName: "acos",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Asin",
                dlOpName: "asin",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "atan",
                dlOpName: "atan",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Ceil",
                dlOpName: "ceil",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "ClipByValue",
                dlOpName: "clipByValue",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "clip_value_min",
                    dlParamName: "clipValueMin",
                    type: "number"
                }, {tfParamName: "clip_value_max", dlParamName: "clipValueMax", type: "number"}]
            }, {
                tfOpName: "Cos",
                dlOpName: "cos",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Cosh",
                dlOpName: "cosh",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Elu",
                dlOpName: "elu",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Exp",
                dlOpName: "exp",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Floor",
                dlOpName: "floor",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Log",
                dlOpName: "log",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Neg",
                dlOpName: "neg",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Relu",
                dlOpName: "relu",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Relu6",
                dlOpName: "clipByValue",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }, {dlParamName: "clipValueMin", type: "number", defaultValue: 0}, {
                    dlParamName: "clipValueMax",
                    type: "number",
                    defaultValue: 6
                }]
            }, {
                tfOpName: "Selu",
                dlOpName: "selu",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Sigmoid",
                dlOpName: "sigmoid",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Sin",
                dlOpName: "sin",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Sinh",
                dlOpName: "sinh",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Sqrt",
                dlOpName: "sqrt",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Rsqrt",
                dlOpName: "rsqrt",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Square",
                dlOpName: "square",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Tan",
                dlOpName: "tan",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Tanh",
                dlOpName: "tanh",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Sign",
                dlOpName: "sign",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Round",
                dlOpName: "round",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Expm1",
                dlOpName: "expm1",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Log1p",
                dlOpName: "log1p",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Reciprocal",
                dlOpName: "reciprocal",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Reciprocal",
                dlOpName: "reciprocal",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Softplus",
                dlOpName: "softplus",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Asinh",
                dlOpName: "asinh",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Acosh",
                dlOpName: "acosh",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Atanh",
                dlOpName: "atanh",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Erf",
                dlOpName: "erf",
                category: "basic_math",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }]
        }, {}],
        29: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "LoopCond",
                dlOpName: "loopCond",
                category: "control",
                params: [{tfInputIndex: 0, dlParamName: "pred", type: "tensor"}]
            }, {
                tfOpName: "Switch",
                dlOpName: "switch",
                category: "control",
                params: [{tfInputIndex: 0, dlParamName: "data", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "pred",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Merge",
                dlOpName: "merge",
                category: "control",
                params: [{tfInputIndex: 0, tfInputParamLength: 0, dlParamName: "tensors", type: "tensors"}]
            }, {
                tfOpName: "Enter",
                dlOpName: "enter",
                category: "control",
                params: [{tfInputIndex: 0, dlParamName: "tensor", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }, {tfParamName: "frame_name", dlParamName: "frameName", type: "string"}, {
                    tfParamName: "is_constant",
                    dlParamName: "isConstant",
                    type: "bool"
                }]
            }, {
                tfOpName: "Exit",
                dlOpName: "exit",
                category: "control",
                params: [{tfInputIndex: 0, dlParamName: "tensor", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "NextIteration",
                dlOpName: "nextIteration",
                category: "control",
                params: [{tfInputIndex: 0, dlParamName: "tensor", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }]
        }, {}],
        30: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "AvgPool",
                dlOpName: "avgPool",
                category: "convolution",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "strides",
                    dlParamName: "strides",
                    type: "number[]"
                }, {tfParamName: "padding", dlParamName: "pad", type: "string"}, {
                    tfParamName: "data_format",
                    dlParamName: "dataFormat",
                    type: "string",
                    notSupported: true
                }, {tfParamName: "ksize", dlParamName: "kernelSize", type: "number[]"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "MaxPool",
                dlOpName: "maxPool",
                category: "convolution",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "strides",
                    dlParamName: "strides",
                    type: "number[]"
                }, {tfParamName: "padding", dlParamName: "pad", type: "string"}, {
                    tfParamName: "data_format",
                    dlParamName: "dataFormat",
                    type: "string",
                    notSupported: true
                }, {tfParamName: "ksize", dlParamName: "kernelSize", type: "number[]"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Conv1D",
                dlOpName: "conv1d",
                category: "convolution",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "filter",
                    type: "tensor"
                }, {tfParamName: "stride", dlParamName: "stride", type: "number"}, {
                    tfParamName: "padding",
                    dlParamName: "pad",
                    type: "string"
                }, {
                    tfParamName: "data_format",
                    dlParamName: "dataFormat",
                    type: "string",
                    defaultValue: "NWC"
                }, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }, {tfParamName: "dilation", dlParamName: "dilation", type: "number", defaultValue: 1}]
            }, {
                tfOpName: "Conv2D",
                dlOpName: "conv2d",
                category: "convolution",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "filter",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}, {
                    tfParamName: "strides",
                    dlParamName: "strides",
                    type: "number[]"
                }, {tfParamName: "padding", dlParamName: "pad", type: "string"}, {
                    tfParamName: "useCudnnOnGpu",
                    dlParamName: "useCudnnOnGpu",
                    type: "bool"
                }, {
                    tfParamName: "data_format",
                    dlParamName: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {tfParamName: "dilations", dlParamName: "dilations", type: "number[]"}]
            }, {
                tfOpName: "Conv2DBackpropInput",
                dlOpName: "conv2dTranspose",
                category: "convolution",
                params: [{tfInputIndex: 2, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "filter",
                    type: "tensor"
                }, {tfInputIndex: 0, dlParamName: "outputShape", type: "number[]"}, {
                    tfParamName: "strides",
                    dlParamName: "strides",
                    type: "number[]"
                }, {tfParamName: "padding", dlParamName: "pad", type: "string"}, {
                    tfParamName: "data_format",
                    dlParamName: "dataFormat",
                    type: "string",
                    notSupported: true
                }]
            }, {
                tfOpName: "DepthwiseConv2d",
                dlOpName: "depthwiseConv2d",
                category: "convolution",
                params: [{tfInputIndex: 0, dlParamName: "input", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "filter",
                    type: "tensor"
                }, {tfParamName: "strides", dlParamName: "strides", type: "number[]"}, {
                    tfParamName: "padding",
                    dlParamName: "pad",
                    type: "string"
                }, {
                    tfParamName: "data_format",
                    dlParamName: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {tfParamName: "dilations", dlParamName: "dilations", type: "number[]"}]
            }, {
                tfOpName: "DepthwiseConv2dNative",
                dlOpName: "depthwiseConv2d",
                category: "convolution",
                params: [{tfInputIndex: 0, dlParamName: "input", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "filter",
                    type: "tensor"
                }, {tfParamName: "strides", dlParamName: "strides", type: "number[]"}, {
                    tfParamName: "padding",
                    dlParamName: "pad",
                    type: "string"
                }, {
                    tfParamName: "data_format",
                    dlParamName: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {tfParamName: "dilations", dlParamName: "dilations", type: "number[]"}]
            }]
        }, {}],
        31: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "Fill",
                dlOpName: "fill",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "shape", type: "number[]"}, {
                    tfInputIndex: 1,
                    dlParamName: "value",
                    type: "number"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "LinSpace",
                dlOpName: "linspace",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "start", type: "number"}, {
                    tfInputIndex: 1,
                    dlParamName: "stop",
                    type: "number"
                }, {tfInputIndex: 2, dlParamName: "num", type: "number"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "OneHot",
                dlOpName: "oneHot",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "indices", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "depth",
                    type: "number"
                }, {tfInputIndex: 2, dlParamName: "onValue", type: "number", defaultValue: 1}, {
                    tfInputIndex: 3,
                    dlParamName: "offValue",
                    type: "number",
                    defaultValue: 0
                }, {tfParamName: "axis", dlParamName: "axis", type: "number", notSupported: true}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "Ones",
                dlOpName: "ones",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "shape", type: "number[]"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "OnesLike",
                dlOpName: "onesLike",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "dtype",
                    dlParamName: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "RandomUniform",
                dlOpName: "randomUniform",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "shape", type: "number[]"}, {
                    tfParamName: "minval",
                    dlParamName: "minval",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfParamName: "maxval",
                    dlParamName: "maxval",
                    type: "number",
                    defaultValue: 1
                }, {tfParamName: "dtype", dlParamName: "dtype", type: "dtype"}, {
                    tfParamName: "seed",
                    dlParamName: "seed",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfParamName: "seed2",
                    dlParamName: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: true
                }, {tfParamName: "T", dlParamName: "T", type: "number", notSupported: true}]
            }, {
                tfOpName: "Range",
                dlOpName: "range",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "start", type: "number"}, {
                    tfInputIndex: 1,
                    dlParamName: "stop",
                    type: "number"
                }, {tfInputIndex: 2, dlParamName: "step", type: "number", defaultValue: 0}, {
                    tfParamName: "Tidx",
                    dlParamName: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "truncatedNormal",
                dlOpName: "truncatedNormal",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "shape", type: "number[]"}, {
                    tfParamName: "means",
                    dlParamName: "mean",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfParamName: "stddev",
                    dlParamName: "stdDev",
                    type: "number",
                    defaultValue: 1
                }, {tfParamName: "seed", dlParamName: "seed", type: "number"}, {
                    tfParamName: "seed2",
                    dlParamName: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: true
                }, {tfParamName: "dtype", dlParamName: "dtype", type: "dtype"}, {
                    tfParamName: "T",
                    dlParamName: "T",
                    type: "number",
                    notSupported: true
                }]
            }, {
                tfOpName: "Zeros",
                dlOpName: "zeros",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "shape", type: "number[]"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "ZerosLike",
                dlOpName: "zerosLike",
                category: "creation",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype"
                }]
            }]
        }, {}],
        32: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "PlaceholderWithDefault",
                dlOpName: "placeholder",
                category: "graph",
                params: [{tfInputIndex: 0, dlParamName: "default", type: "tensor"}]
            }, {tfOpName: "Placeholder", dlOpName: "placeholder", category: "graph"}, {
                tfOpName: "Const",
                dlOpName: "const",
                category: "graph"
            }, {
                tfOpName: "Identity",
                dlOpName: "identity",
                category: "graph",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}]
            }, {
                tfOpName: "Snapshot",
                dlOpName: "snapshot",
                category: "graph",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}]
            }, {
                tfOpName: "Shape",
                dlOpName: "shape",
                category: "graph",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}]
            }, {
                tfOpName: "Print",
                dlOpName: "print",
                category: "graph",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    tfInputParamLength: 1,
                    dlParamName: "data",
                    type: "tensors"
                }, {tfParamName: "message", dlParamName: "message", type: "string"}, {
                    tfParamName: "first_n",
                    dlParamName: "firstN",
                    type: "number",
                    notSupprted: true
                }, {tfParamName: "summarize", dlParamName: "summarize", type: "number", defaultValue: 3}]
            }, {tfOpName: "NoOp", dlOpName: "noop", category: "graph", params: []}, {
                tfOpName: "StopGradient",
                dlOpName: "stopGradient",
                category: "graph",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}]
            }, {
                tfOpName: "FakeQuantWithMinMaxVars",
                dlOpName: "fakeQuantWithMinMaxVars",
                category: "graph",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "min",
                    dlParamName: "min",
                    type: "number"
                }, {tfParamName: "max", dlParamName: "max", type: "number"}]
            }]
        }, {}],
        33: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "ResizeBilinear",
                dlOpName: "resizeBilinear",
                category: "image",
                params: [{tfInputIndex: 0, dlParamName: "images", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "size",
                    type: "number[]"
                }, {tfParamName: "align_corners", dlParamName: "alignCorners", type: "bool"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }]
        }, {}],
        34: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "Equal",
                dlOpName: "equal",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "NotEqual",
                dlOpName: "notEqual",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Greater",
                dlOpName: "greater",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "GreaterEqual",
                dlOpName: "greaterEqual",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Less",
                dlOpName: "less",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "LessEqual",
                dlOpName: "lessEqual",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "LogicalAnd",
                dlOpName: "logicalAnd",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "LogicalNot",
                dlOpName: "logicalNot",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }, {
                tfOpName: "LogicalOr",
                dlOpName: "logicalOr",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Select",
                dlOpName: "where",
                category: "logical",
                params: [{tfInputIndex: 0, dlParamName: "condition", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "a",
                    type: "tensor"
                }, {tfInputIndex: 2, dlParamName: "b", type: "tensor"}, {
                    tfParamName: "T",
                    dlParamName: "dtype",
                    type: "dtype",
                    notSupported: true
                }]
            }]
        }, {}],
        35: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "MatMul",
                dlOpName: "matMul",
                category: "matrices",
                params: [{tfInputIndex: 0, dlParamName: "a", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "b",
                    type: "tensor"
                }, {
                    tfParamName: "transpose_a",
                    dlParamName: "transposeA",
                    type: "bool",
                    defaultValue: false
                }, {
                    tfParamName: "transpose_b",
                    dlParamName: "transposeB",
                    type: "bool",
                    defaultValue: false
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }, {
                tfOpName: "Transpose",
                dlOpName: "transpose",
                category: "matrices",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "perm",
                    dlParamName: "perm",
                    type: "number[]"
                }, {tfParamName: "T", dlParamName: "dtype", type: "dtype", notSupported: true}]
            }]
        }, {}],
        36: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "FusedBatchNorm",
                dlOpName: "batchNormalization",
                category: "normalization",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "scale",
                    type: "tensor"
                }, {tfInputIndex: 2, dlParamName: "offset", type: "tensor"}, {
                    tfInputIndex: 3,
                    dlParamName: "mean",
                    type: "tensor"
                }, {tfInputIndex: 4, dlParamName: "variance", type: "tensor"}, {
                    tfParamName: "epsilon",
                    dlParamName: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {tfParamName: "data_format", dlParamName: "dataFormat", type: "string", notSupported: true}]
            }, {
                tfOpName: "FusedBatchNormV2",
                dlOpName: "batchNormalization",
                category: "normalization",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "scale",
                    type: "tensor"
                }, {tfInputIndex: 2, dlParamName: "offset", type: "tensor"}, {
                    tfInputIndex: 3,
                    dlParamName: "mean",
                    type: "tensor"
                }, {tfInputIndex: 4, dlParamName: "variance", type: "tensor"}, {
                    tfParamName: "epsilon",
                    dlParamName: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {tfParamName: "data_format", dlParamName: "dataFormat", type: "string", notSupported: true}]
            }, {
                tfOpName: "LRN",
                dlOpName: "localResponseNormalization",
                category: "normalization",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "depth_radius",
                    dlParamName: "radius",
                    type: "number",
                    defaultValue: 5
                }, {tfParamName: "bias", dlParamName: "bias", type: "number", defaultValue: 1}, {
                    tfParamName: "alpha",
                    dlParamName: "alpha",
                    type: "number",
                    defaultValue: 1
                }, {tfParamName: "beta", dlParamName: "beta", type: "number", defaultValue: .5}]
            }, {
                tfOpName: "Softmax",
                dlOpName: "softmax",
                category: "normalization",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}]
            }]
        }, {}],
        37: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "Max",
                dlOpName: "max",
                category: "reduction",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "axis",
                    type: "number[]"
                }, {tfParamName: "keep_dims", dlParamName: "keepDims", type: "bool"}]
            }, {
                tfOpName: "Mean",
                dlOpName: "mean",
                category: "reduction",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "axis",
                    type: "number[]"
                }, {tfParamName: "keep_dims", dlParamName: "keepDims", type: "bool"}]
            }, {
                tfOpName: "Min",
                dlOpName: "min",
                category: "reduction",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "axis",
                    type: "number[]"
                }, {tfParamName: "keep_dims", dlParamName: "keepDims", type: "bool"}]
            }, {
                tfOpName: "Sum",
                dlOpName: "sum",
                category: "reduction",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "axis",
                    type: "number[]"
                }, {tfParamName: "keep_dims", dlParamName: "keepDims", type: "bool"}]
            }, {
                tfOpName: "ArgMax",
                dlOpName: "argMax",
                category: "reduction",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "ArgMin",
                dlOpName: "argMin",
                category: "reduction",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "axis",
                    type: "number"
                }]
            }]
        }, {}],
        38: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "ConcatV2",
                dlOpName: "concat",
                category: "slice_join",
                params: [{
                    tfInputIndex: 0,
                    tfInputParamLength: 1,
                    dlParamName: "tensors",
                    type: "tensors"
                }, {tfInputIndex: -1, dlParamName: "axis", type: "number"}]
            }, {
                tfOpName: "Concat",
                dlOpName: "concat",
                category: "slice_join",
                params: [{
                    tfInputIndex: 1,
                    tfInputParamLength: 1,
                    dlParamName: "tensors",
                    type: "tensors"
                }, {tfInputIndex: 0, dlParamName: "axis", type: "number"}]
            }, {
                tfOpName: "GatherV2",
                dlOpName: "gather",
                category: "slice_join",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "indices",
                    type: "tensor"
                }, {tfParamName: "axis", dlParamName: "axis", type: "number", defaultValue: 0}]
            }, {
                tfOpName: "Gather",
                dlOpName: "gather",
                category: "slice_join",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "indices",
                    type: "tensor"
                }, {
                    tfParamName: "axis",
                    dlParamName: "axis",
                    type: "number",
                    defaultValue: 0
                }, {tfParamName: "validate_indices", dlParamName: "validateIndices", type: "bool", notSupported: true}]
            }, {
                tfOpName: "Reverse",
                dlOpName: "reverse",
                category: "slice_join",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "ReverseV2",
                dlOpName: "reverse",
                category: "slice_join",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "Slice",
                dlOpName: "slice",
                category: "slice_join",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "begin",
                    type: "number[]"
                }, {tfInputIndex: 2, dlParamName: "size", type: "number[]"}]
            }, {
                tfOpName: "StridedSlice",
                dlOpName: "stridedSlice",
                category: "slice_join",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "begin",
                    type: "number[]"
                }, {tfInputIndex: 2, dlParamName: "end", type: "number[]"}, {
                    tfInputIndex: 3,
                    dlParamName: "strides",
                    type: "number[]"
                }, {
                    tfParamName: "begin_mask",
                    dlParamName: "beginMask",
                    type: "number",
                    defaultValue: 0
                }, {tfParamName: "end_mask", dlParamName: "endMask", type: "number", defaultValue: 0}]
            }, {
                tfOpName: "Pack",
                dlOpName: "stack",
                category: "slice_join",
                params: [{
                    tfInputIndex: 0,
                    tfInputParamLength: 0,
                    dlParamName: "tensors",
                    type: "tensors"
                }, {tfParamName: "axis", dlParamName: "axis", type: "number", defaultValue: 0}]
            }, {
                tfOpName: "Tile",
                dlOpName: "tile",
                category: "slice_join",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "reps",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Split",
                dlOpName: "split",
                category: "slice_join",
                params: [{tfInputIndex: 0, dlParamName: "axis", type: "number", defaultValue: 0}, {
                    tfInputIndex: 1,
                    dlParamName: "x",
                    type: "tensor"
                }, {tfParamName: "num_split", dlParamName: "numOrSizeSplits", type: "number", defaultValue: 1}]
            }]
        }, {}],
        39: [function (require, module, exports) {
            module.exports = [{
                tfOpName: "Cast",
                dlOpName: "cast",
                category: "transformation",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "SrcT",
                    dlParamName: "sdtype",
                    type: "dtype",
                    notSupported: true
                }, {tfParamName: "DstT", dlParamName: "dtype", type: "dtype"}]
            }, {
                tfOpName: "ExpandDims",
                dlOpName: "expandDims",
                category: "transformation",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    tfParamNameDeprecated: "dim",
                    dlParamName: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "Pad",
                dlOpName: "pad",
                category: "transformation",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "padding",
                    type: "number[]"
                }, {tfParamName: "constant_value", dlParamName: "constantValue", type: "number", defaultValue: 0}]
            }, {
                tfOpName: "PadV2",
                dlOpName: "pad",
                category: "transformation",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "padding",
                    type: "number[]"
                }, {tfInputIndex: 2, dlParamName: "constantValue", type: "number", defaultValue: 0}]
            }, {
                tfOpName: "Reshape",
                dlOpName: "reshape",
                category: "transformation",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfInputIndex: 1,
                    dlParamName: "shape",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Squeeze",
                dlOpName: "squeeze",
                category: "transformation",
                params: [{tfInputIndex: 0, dlParamName: "x", type: "tensor"}, {
                    tfParamName: "axis",
                    tfParamNameDeprecated: "squeeze_dims",
                    dlParamName: "axis",
                    type: "number[]"
                }]
            }]
        }, {}],
        40: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var arithmetic = require("./executors/arithmetic_executor");
            var basicMath = require("./executors/basic_math_executor");
            var control = require("./executors/control_executor");
            var convolution = require("./executors/convolution_executor");
            var creation = require("./executors/creation_executor");
            var graph = require("./executors/graph_executor");
            var image = require("./executors/image_executor");
            var logical = require("./executors/logical_executor");
            var matrices = require("./executors/matrices_executor");
            var normalization = require("./executors/normalization_executor");
            var reduction = require("./executors/reduction_executor");
            var sliceJoin = require("./executors/slice_join_executor");
            var transformation = require("./executors/transformation_executor");

            function executeOp(node, tensorMap, context) {
                switch (node.category) {
                    case"arithmetic":
                        return arithmetic.executeOp(node, tensorMap, context);
                    case"basic_math":
                        return basicMath.executeOp(node, tensorMap, context);
                    case"control":
                        return control.executeOp(node, tensorMap, context);
                    case"convolution":
                        return convolution.executeOp(node, tensorMap, context);
                    case"creation":
                        return creation.executeOp(node, tensorMap, context);
                    case"image":
                        return image.executeOp(node, tensorMap, context);
                    case"graph":
                        return graph.executeOp(node, tensorMap, context);
                    case"logical":
                        return logical.executeOp(node, tensorMap, context);
                    case"matrices":
                        return matrices.executeOp(node, tensorMap, context);
                    case"normalization":
                        return normalization.executeOp(node, tensorMap, context);
                    case"reduction":
                        return reduction.executeOp(node, tensorMap, context);
                    case"slice_join":
                        return sliceJoin.executeOp(node, tensorMap, context);
                    case"transformation":
                        return transformation.executeOp(node, tensorMap, context);
                    default:
                        throw TypeError("Node type " + node.op + " is not implemented")
                }
            }

            exports.executeOp = executeOp
        }, {
            "./executors/arithmetic_executor": 13,
            "./executors/basic_math_executor": 14,
            "./executors/control_executor": 15,
            "./executors/convolution_executor": 16,
            "./executors/creation_executor": 17,
            "./executors/graph_executor": 18,
            "./executors/image_executor": 19,
            "./executors/logical_executor": 20,
            "./executors/matrices_executor": 21,
            "./executors/normalization_executor": 22,
            "./executors/reduction_executor": 23,
            "./executors/slice_join_executor": 24,
            "./executors/transformation_executor": 25
        }],
        41: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var compiled_api_1 = require("../data/compiled_api");
            var utils_1 = require("./executors/utils");
            var arithmetic_json_1 = require("./op_list/arithmetic.json");
            var basic_math_json_1 = require("./op_list/basic_math.json");
            var control_json_1 = require("./op_list/control.json");
            var convolution_json_1 = require("./op_list/convolution.json");
            var creation_json_1 = require("./op_list/creation.json");
            var graph_json_1 = require("./op_list/graph.json");
            var image_json_1 = require("./op_list/image.json");
            var logical_json_1 = require("./op_list/logical.json");
            var matrices_json_1 = require("./op_list/matrices.json");
            var normalization_json_1 = require("./op_list/normalization.json");
            var reduction_json_1 = require("./op_list/reduction.json");
            var slice_join_json_1 = require("./op_list/slice_join.json");
            var transformation_json_1 = require("./op_list/transformation.json");
            var CONTROL_FLOW_OPS = ["Switch", "Merge", "Enter", "Exit", "NextIteration"];
            var OperationMapper = function () {
                function OperationMapper() {
                    var mappersJson = arithmetic_json_1.default.concat(basic_math_json_1.default, control_json_1.default, convolution_json_1.default, creation_json_1.default, logical_json_1.default, image_json_1.default, graph_json_1.default, matrices_json_1.default, normalization_json_1.default, reduction_json_1.default, slice_join_json_1.default, transformation_json_1.default);
                    this.opMappers = mappersJson.reduce(function (map, mapper) {
                        map[mapper.tfOpName] = mapper;
                        return map
                    }, {})
                }

                Object.defineProperty(OperationMapper, "Instance", {
                    get: function () {
                        return this._instance || (this._instance = new this)
                    }, enumerable: true, configurable: true
                });
                OperationMapper.prototype.isControlFlow = function (node) {
                    return CONTROL_FLOW_OPS.some(function (op) {
                        return op === node.op
                    })
                };
                OperationMapper.prototype.transformGraph = function (graph) {
                    var _this = this;
                    var tfNodes = graph.node;
                    var withControlFlow = false;
                    var placeholders = [];
                    var nodes = tfNodes.reduce(function (map, node) {
                        map[node.name] = _this.mapNode(node);
                        if (_this.isControlFlow(node)) withControlFlow = true;
                        if (node.op === "Placeholder") placeholders.push(map[node.name]);
                        return map
                    }, {});
                    var inputs = [];
                    var outputs = [];
                    Object.keys(nodes).forEach(function (key) {
                        var node = nodes[key];
                        node.inputNames.forEach(function (name) {
                            var nodeName = utils_1.getNodeNameAndIndex(name)[0];
                            node.inputs.push(nodes[nodeName]);
                            nodes[nodeName].children.push(node)
                        });
                        if (node.inputs.length === 0) inputs.push(node)
                    });
                    Object.keys(nodes).forEach(function (key) {
                        var node = nodes[key];
                        if (node.children.length === 0) outputs.push(node)
                    });
                    return {
                        nodes: nodes,
                        inputs: inputs,
                        outputs: outputs,
                        placeholders: placeholders,
                        withControlFlow: withControlFlow
                    }
                };
                OperationMapper.prototype.mapNode = function (node) {
                    var _this = this;
                    var mapper = this.opMappers[node.op];
                    if (mapper === undefined) {
                        throw new Error("Tensorflow Op is not supported: " + node.op)
                    }
                    var newNode = {
                        name: node.name,
                        op: mapper.dlOpName,
                        category: mapper.category,
                        inputNames: (node.input || []).map(function (input) {
                            return input.startsWith("^") ? input.substr(1) : input
                        }),
                        inputs: [],
                        children: [],
                        params: {}
                    };
                    if (!!mapper.params) {
                        newNode.params = mapper.params.reduce(function (map, param) {
                            var inputIndex = param.tfInputIndex;
                            var inputParamLength = param.tfInputParamLength;
                            var type = param.type;
                            var value = undefined;
                            if (inputIndex === undefined) {
                                switch (param.type) {
                                    case"string":
                                        value = _this.getStringParam(node.attr, param.tfParamName, param.defaultValue);
                                        if (value === undefined && !!param.tfParamNameDeprecated) {
                                            value = _this.getStringParam(node.attr, param.tfParamNameDeprecated, param.defaultValue)
                                        }
                                        break;
                                    case"number":
                                        value = _this.getNumberParam(node.attr, param.tfParamName, param.defaultValue);
                                        if (value === undefined && !!param.tfParamNameDeprecated) {
                                            value = _this.getNumberParam(node.attr, param.tfParamNameDeprecated, param.defaultValue)
                                        }
                                        break;
                                    case"number[]":
                                        value = _this.getNumericArrayParam(node.attr, param.tfParamName, param.defaultValue);
                                        if (value === undefined && !!param.tfParamNameDeprecated) {
                                            value = _this.getNumericArrayParam(node.attr, param.tfParamNameDeprecated, param.defaultValue)
                                        }
                                        break;
                                    case"bool":
                                        value = _this.getBoolParam(node.attr, param.tfParamName, param.defaultValue);
                                        if (value === undefined && !!param.tfParamNameDeprecated) {
                                            value = _this.getBoolParam(node.attr, param.tfParamNameDeprecated, param.defaultValue)
                                        }
                                        break;
                                    case"shape":
                                        value = _this.getTensorShapeParam(node.attr, param.tfParamName, param.defaultValue);
                                        if (value === undefined && !!param.tfParamNameDeprecated) {
                                            value = _this.getTensorShapeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue)
                                        }
                                        break;
                                    case"dtype":
                                        value = _this.getDtypeParam(node.attr, param.tfParamName, param.defaultValue);
                                        if (value === undefined && !!param.tfParamNameDeprecated) {
                                            value = _this.getDtypeParam(node.attr, param.tfParamNameDeprecated, param.defaultValue)
                                        }
                                        break;
                                    case"tensor":
                                    case"tensors":
                                        break;
                                    default:
                                        throw new Error("Unsupported param type: " + param.type + " for op: " + node.op)
                                }
                            }
                            map[param.dlParamName] = {
                                value: value,
                                inputIndex: inputIndex,
                                type: type,
                                inputParamLength: inputParamLength
                            };
                            return map
                        }, {})
                    }
                    return newNode
                };
                OperationMapper.prototype.getStringParam = function (attrs, name, def, keepCase) {
                    if (keepCase === void 0) {
                        keepCase = false
                    }
                    var param = attrs[name];
                    if (param !== undefined) {
                        var value = String.fromCharCode.apply(null, param.s);
                        return keepCase ? value : value.toLowerCase()
                    }
                    return def
                };
                OperationMapper.prototype.getBoolParam = function (attrs, name, def) {
                    var param = attrs[name];
                    return param ? param.b : def
                };
                OperationMapper.prototype.getNumberParam = function (attrs, name, def) {
                    var param = attrs[name];
                    var value = param ? param.f !== undefined ? param.f : param.i : def;
                    return typeof value === "number" ? value : value["toInt"]()
                };
                OperationMapper.prototype.getDtypeParam = function (attrs, name, def) {
                    var param = attrs[name];
                    if (param && param.type) {
                        switch (param.type) {
                            case compiled_api_1.tensorflow.DataType.DT_FLOAT:
                                return "float32";
                            case compiled_api_1.tensorflow.DataType.DT_INT32:
                                return "int32";
                            case compiled_api_1.tensorflow.DataType.DT_BOOL:
                                return "bool";
                            default:
                                return def
                        }
                    }
                    return def
                };
                OperationMapper.prototype.getTensorShapeParam = function (attrs, name, def) {
                    var param = attrs[name];
                    if (param && param.shape) {
                        return param.shape.dim.map(function (dim) {
                            return dim.size
                        })
                    }
                    return def
                };
                OperationMapper.prototype.getNumericArrayParam = function (attrs, name, def) {
                    var param = attrs[name];
                    if (param) {
                        return (param.list.f && param.list.f.length ? param.list.f : param.list.i).map(function (v) {
                            return typeof v === "number" ? v : v["toInt"]()
                        })
                    }
                    return def
                };
                return OperationMapper
            }();
            exports.OperationMapper = OperationMapper
        }, {
            "../data/compiled_api": 8,
            "./executors/utils": 26,
            "./op_list/arithmetic.json": 27,
            "./op_list/basic_math.json": 28,
            "./op_list/control.json": 29,
            "./op_list/convolution.json": 30,
            "./op_list/creation.json": 31,
            "./op_list/graph.json": 32,
            "./op_list/image.json": 33,
            "./op_list/logical.json": 34,
            "./op_list/matrices.json": 35,
            "./op_list/normalization.json": 36,
            "./op_list/reduction.json": 37,
            "./op_list/slice_join.json": 38,
            "./op_list/transformation.json": 39
        }],
        42: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var version = "0.4.0";
            exports.version = version
        }, {}],
        43: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("./doc");
            var BrowserUtil = function () {
                function BrowserUtil() {
                }

                BrowserUtil.nextFrame = function () {
                    return new Promise(function (resolve) {
                        return requestAnimationFrame(function () {
                            return resolve()
                        })
                    })
                };
                __decorate([doc_1.doc({heading: "Performance", subheading: "Timing"})], BrowserUtil, "nextFrame", null);
                return BrowserUtil
            }();
            exports.BrowserUtil = BrowserUtil
        }, {"./doc": 45}],
        44: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function isMobile() {
                var a = navigator.userAgent || navigator.vendor || window.opera;
                return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))
            }

            exports.isMobile = isMobile
        }, {}],
        45: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function doc(info) {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i]
                    }
                }
            }

            exports.doc = doc
        }, {}],
        46: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("./environment");
            var globals_1 = require("./globals");
            var ops = require("./ops/ops");
            var profiler_1 = require("./profiler");
            var tape_1 = require("./tape");
            var tensor_1 = require("./tensor");
            var util = require("./util");
            var Engine = function () {
                function Engine(backend, safeMode) {
                    this.backend = backend;
                    this.safeMode = safeMode;
                    this.registeredVariables = {};
                    this.refCounter = new WeakMap;
                    this.nextTapeNodeId = 0;
                    this.numBytes = 0;
                    this.numTensors = 0;
                    this.numDataBuffers = 0;
                    this.gradientScopeCount = 0;
                    this.customGradientDepth = 0;
                    this.activeScope = {keep: [], track: []};
                    this.scopeStack = [this.activeScope];
                    this.profiler = new profiler_1.Profiler(backend)
                }

                Engine.prototype.runKernel = function (forwardFunc, inputs, backwardsFunc) {
                    var _this = this;
                    var result;
                    var saved = [];
                    var saveFunc = function (x) {
                        saved.push(x);
                        return x
                    };
                    var scopeName = this.activeScope.name;
                    this.customGradientDepth++;
                    if (!environment_1.ENV.get("DEBUG")) {
                        result = forwardFunc(this.backend, saveFunc)
                    } else {
                        result = this.profiler.profileKernel(scopeName, function () {
                            return forwardFunc(_this.backend, saveFunc)
                        })
                    }
                    this.customGradientDepth--;
                    if (this.shouldRecord()) {
                        var tapeNode = {id: this.nextTapeNodeId++, name: scopeName, inputs: inputs, output: result};
                        if (backwardsFunc != null) {
                            tapeNode.gradient = function (dy) {
                                return backwardsFunc(dy, saved)
                            }
                        }
                        this.activeTape.push(tapeNode)
                    }
                    return result
                };
                Engine.prototype.registerTensor = function (a) {
                    var refCount = this.refCounter.has(a.dataId) ? this.refCounter.get(a.dataId) : 0;
                    this.numTensors++;
                    if (refCount === 0) {
                        this.numDataBuffers++;
                        this.numBytes += util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
                        this.backend.register(a.dataId, a.shape, a.dtype)
                    }
                    this.refCounter.set(a.dataId, refCount + 1);
                    if (!(a instanceof tensor_1.Variable)) {
                        this.track(a)
                    }
                };
                Engine.prototype.registerVariable = function (v) {
                    if (this.registeredVariables[v.name] != null) {
                        throw new Error("Variable with name " + v.name + " was already registered")
                    }
                    this.registeredVariables[v.name] = v
                };
                Engine.prototype.disposeTensor = function (a) {
                    if (!this.refCounter.has(a.dataId)) {
                        return
                    }
                    this.numTensors--;
                    var refCount = this.refCounter.get(a.dataId);
                    if (refCount <= 1) {
                        this.refCounter.delete(a.dataId);
                        this.backend.disposeData(a.dataId);
                        this.numDataBuffers--;
                        this.numBytes -= util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype)
                    } else {
                        this.refCounter.set(a.dataId, refCount - 1)
                    }
                };
                Engine.prototype.disposeVariables = function () {
                    for (var varName in this.registeredVariables) {
                        var v = this.registeredVariables[varName];
                        this.disposeTensor(v);
                        delete this.registeredVariables[varName]
                    }
                };
                Engine.prototype.memory = function () {
                    var info = this.backend.memory();
                    info.numTensors = this.numTensors;
                    info.numDataBuffers = this.numDataBuffers;
                    info.numBytes = this.numBytes;
                    return info
                };
                Engine.prototype.shouldRecord = function () {
                    return this.activeTape != null && this.customGradientDepth === 0
                };
                Engine.prototype.addTapeNode = function (inputs, result, gradientsFunc) {
                    var inputsMap = {};
                    inputs.forEach(function (input, idx) {
                        inputsMap[idx] = input
                    });
                    var gradient = function (dy) {
                        var res = gradientsFunc(dy);
                        var resMap = {};
                        res.forEach(function (r, idx) {
                            resMap[idx] = function () {
                                return r
                            }
                        });
                        return resMap
                    };
                    var tapeNode = {
                        id: this.nextTapeNodeId++,
                        name: this.activeScope.name,
                        inputs: inputsMap,
                        output: result,
                        gradient: gradient
                    };
                    this.activeTape.push(tapeNode)
                };
                Engine.prototype.keep = function (result) {
                    if (this.scopeStack.length === 1 && environment_1.ENV.engine.safeMode) {
                        throw new Error("Safe mode is ON. Enclose all tensor operations inside tf.tidy(): " + "tf.tidy(() => {...}) to avoid memory leaks.")
                    }
                    this.activeScope.keep.push(result);
                    return result
                };
                Engine.prototype.startScope = function (name, gradientsMode) {
                    if (gradientsMode === void 0) {
                        gradientsMode = false
                    }
                    if (gradientsMode && this.gradientScopeCount === 0) {
                        this.activeTape = []
                    }
                    if (gradientsMode) {
                        this.gradientScopeCount++
                    }
                    var scopeInfo = {keep: [], track: []};
                    if (name) {
                        scopeInfo.name = name
                    }
                    this.scopeStack.push(scopeInfo);
                    this.activeScope = scopeInfo
                };
                Engine.prototype.endScope = function (result, gradientsMode) {
                    var _this = this;
                    if (gradientsMode === void 0) {
                        gradientsMode = false
                    }
                    if (gradientsMode) {
                        this.gradientScopeCount--;
                        if (this.gradientScopeCount === 0) {
                            this.activeTape = null
                        }
                    }
                    var tensorsToKeep = this.activeScope.keep;
                    var tensorsToTrackInParent = util.extractTensorsFromContainer(result);
                    tensorsToKeep = tensorsToKeep.concat(tensorsToTrackInParent);
                    for (var i = 0; i < this.activeScope.track.length; i++) {
                        var tensor = this.activeScope.track[i];
                        if (util.isTensorInList(tensor, tensorsToKeep)) {
                            continue
                        }
                        if (this.activeTape != null) {
                            tensorsToTrackInParent.push(tensor)
                        } else {
                            tensor.dispose()
                        }
                    }
                    this.scopeStack.pop();
                    this.activeScope = this.scopeStack.length === 0 ? {
                        keep: [],
                        track: []
                    } : this.scopeStack[this.scopeStack.length - 1];
                    tensorsToTrackInParent.forEach(function (tensor) {
                        if (!util.isTensorInList(tensor, _this.activeScope.keep)) {
                            _this.track(tensor)
                        }
                    })
                };
                Engine.prototype.dispose = function () {
                };
                Engine.prototype.gradients = function (f, xs, dy, allowNoGradients) {
                    var _this = this;
                    if (allowNoGradients === void 0) {
                        allowNoGradients = false
                    }
                    util.assert(xs.length > 0, "gradients() received an empty list of xs.");
                    return globals_1.tidy("gradients", function () {
                        var y = f();
                        util.assert(y instanceof tensor_1.Tensor, "The result y returned by f() must be a tensor.");
                        var filteredTape = tape_1.getFilteredNodesXToY(_this.activeTape, xs, y);
                        if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
                            throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure " + "that the f you passed encloses all operations that lead from x " + "to y.")
                        }
                        var accumulatedGradientMap = {};
                        accumulatedGradientMap[y.id] = dy == null ? ops.ones(y.shape) : dy;
                        tape_1.backpropagateGradients(accumulatedGradientMap, filteredTape);
                        var grads = xs.map(function (x) {
                            return accumulatedGradientMap[x.id]
                        });
                        return {value: y, grads: grads}
                    }, true)
                };
                Engine.prototype.customGrad = function (f) {
                    var _this = this;
                    util.assert(util.isFunction(f), "The f passed in customGrad(f) must be a function.");
                    return function () {
                        var inputs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            inputs[_i] = arguments[_i]
                        }
                        util.assert(inputs.every(function (t) {
                            return t instanceof tensor_1.Tensor
                        }), "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
                        _this.customGradientDepth++;
                        var gradientsFunc;
                        var gradientsMode = true;
                        var result = globals_1.tidy(f.name, function () {
                            var _a = f.apply(void 0, inputs), value = _a.value, gradFunc = _a.gradFunc;
                            util.assert(value instanceof tensor_1.Tensor, "The function f passed in customGrad(f) must return an object " + "where `obj.value` is a tensor");
                            util.assert(util.isFunction(gradFunc), "The function f passed in customGrad(f) must return an object " + "where `obj.gradFunc` is a function.");
                            gradientsFunc = gradFunc;
                            return value
                        }, gradientsMode);
                        _this.customGradientDepth--;
                        if (_this.shouldRecord()) {
                            var gradFunc = function (dy) {
                                var res = gradientsFunc(dy);
                                var grads = Array.isArray(res) ? res : [res];
                                util.assert(grads.length === inputs.length, "The function f passed in customGrad(f) must return an object " + "where `obj.gradFunc` is a function that returns the same " + "number of tensors as inputs passed to f(...).");
                                util.assert(grads.every(function (t) {
                                    return t instanceof tensor_1.Tensor
                                }), "The function f passed in customGrad(f) must return an object " + "where `obj.gradFunc` is a function that returns a list of " + "only tensors.");
                                return grads
                            };
                            _this.addTapeNode(inputs, result, gradFunc)
                        }
                        return result
                    }
                };
                Engine.prototype.write = function (dataId, values) {
                    this.backend.write(dataId, values)
                };
                Engine.prototype.readSync = function (dataId) {
                    return this.backend.readSync(dataId)
                };
                Engine.prototype.read = function (dataId) {
                    return this.backend.read(dataId)
                };
                Engine.prototype.fromPixels = function (pixels, numChannels) {
                    return this.backend.fromPixels(pixels, numChannels)
                };
                Engine.prototype.time = function (query) {
                    return __awaiter(this, void 0, void 0, function () {
                        var start, timingInfo;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    start = performance.now();
                                    return [4, this.backend.time(query)];
                                case 1:
                                    timingInfo = _a.sent();
                                    timingInfo.wallMs = performance.now() - start;
                                    return [2, timingInfo]
                            }
                        })
                    })
                };
                Engine.prototype.track = function (result) {
                    if (this.scopeStack.length === 1 && this.safeMode) {
                        throw new Error("Safe mode is ON. Enclose all tensor operations inside tf.tidy(): " + "tf.tidy(() => {op();...}); to avoid memory leaks.")
                    }
                    this.activeScope.track.push(result);
                    return result
                };
                return Engine
            }();
            exports.Engine = Engine
        }, {
            "./environment": 47,
            "./globals": 48,
            "./ops/ops": 122,
            "./profiler": 144,
            "./tape": 146,
            "./tensor": 147,
            "./util": 153
        }],
        47: [function (require, module, exports) {
            (function (global) {
                "use strict";
                var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
                        d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r
                };
                Object.defineProperty(exports, "__esModule", {value: true});
                var device_util = require("./device_util");
                var doc_1 = require("./doc");
                var engine_1 = require("./engine");
                var util = require("./util");
                var Type;
                (function (Type) {
                    Type[Type["NUMBER"] = 0] = "NUMBER";
                    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
                    Type[Type["STRING"] = 2] = "STRING"
                })(Type = exports.Type || (exports.Type = {}));
                exports.URL_PROPERTIES = [{name: "DEBUG", type: Type.BOOLEAN}, {
                    name: "IS_BROWSER",
                    type: Type.BOOLEAN
                }, {
                    name: "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",
                    type: Type.NUMBER
                }, {name: "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", type: Type.BOOLEAN}, {
                    name: "WEBGL_VERSION",
                    type: Type.NUMBER
                }, {
                    name: "WEBGL_FLOAT_TEXTURE_ENABLED",
                    type: Type.BOOLEAN
                }, {name: "WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED", type: Type.BOOLEAN}, {
                    name: "BACKEND",
                    type: Type.STRING
                }];

                function hasExtension(gl, extensionName) {
                    var ext = gl.getExtension(extensionName);
                    return ext != null
                }

                function getWebGLRenderingContext(webGLVersion) {
                    if (webGLVersion === 0) {
                        throw new Error("Cannot get WebGL rendering context, WebGL is disabled.")
                    }
                    var tempCanvas = document.createElement("canvas");
                    if (webGLVersion === 1) {
                        return tempCanvas.getContext("webgl") || tempCanvas.getContext("experimental-webgl")
                    }
                    return tempCanvas.getContext("webgl2")
                }

                function loseContext(gl) {
                    if (gl != null) {
                        var loseContextExtension = gl.getExtension("WEBGL_lose_context");
                        if (loseContextExtension == null) {
                            throw new Error("Extension WEBGL_lose_context not supported on this browser.")
                        }
                        loseContextExtension.loseContext()
                    }
                }

                function isWebGLVersionEnabled(webGLVersion) {
                    var gl = getWebGLRenderingContext(webGLVersion);
                    if (gl != null) {
                        loseContext(gl);
                        return true
                    }
                    return false
                }

                function getWebGLDisjointQueryTimerVersion(webGLVersion) {
                    if (webGLVersion === 0) {
                        return 0
                    }
                    var queryTimerVersion;
                    var gl = getWebGLRenderingContext(webGLVersion);
                    if (hasExtension(gl, "EXT_disjoint_timer_query_webgl2") && webGLVersion === 2) {
                        queryTimerVersion = 2
                    } else if (hasExtension(gl, "EXT_disjoint_timer_query")) {
                        queryTimerVersion = 1
                    } else {
                        queryTimerVersion = 0
                    }
                    if (gl != null) {
                        loseContext(gl)
                    }
                    return queryTimerVersion
                }

                function isFloatTextureReadPixelsEnabled(webGLVersion) {
                    if (webGLVersion === 0) {
                        return false
                    }
                    var gl = getWebGLRenderingContext(webGLVersion);
                    if (webGLVersion === 1) {
                        if (!hasExtension(gl, "OES_texture_float")) {
                            return false
                        }
                    } else {
                        if (!hasExtension(gl, "EXT_color_buffer_float")) {
                            return false
                        }
                    }
                    var frameBuffer = gl.createFramebuffer();
                    var texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
                    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                    var frameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
                    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
                    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
                    loseContext(gl);
                    return frameBufferComplete && readPixelsNoError
                }

                function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
                    if (webGLVersion > 0) {
                        return false
                    }
                    if (webGLVersion !== 2) {
                        return false
                    }
                    var gl = getWebGLRenderingContext(webGLVersion);
                    var isEnabled = hasExtension(gl, "WEBGL_get_buffer_sub_data_async");
                    loseContext(gl);
                    return isEnabled
                }

                var Environment = function () {
                    function Environment(features) {
                        this.features = {};
                        this.registry = {};
                        if (features != null) {
                            this.features = features
                        }
                        if (this.get("DEBUG")) {
                            console.warn("Debugging mode is ON. The output of every math call will " + "be downloaded to CPU and checked for NaNs. " + "This significantly impacts performance.")
                        }
                    }

                    Environment.setBackend = function (backendType, safeMode) {
                        if (safeMode === void 0) {
                            safeMode = false
                        }
                        if (!(backendType in exports.ENV.registry)) {
                            throw new Error("Backend type '" + backendType + "' not found in registry")
                        }
                        exports.ENV.initBackend(backendType, safeMode)
                    };
                    Environment.getBackend = function () {
                        exports.ENV.initDefaultBackend();
                        return exports.ENV.currentBackend
                    };
                    Environment.disposeVariables = function () {
                        exports.ENV.engine.disposeVariables()
                    };
                    Environment.memory = function () {
                        return exports.ENV.engine.memory()
                    };
                    Environment.prototype.get = function (feature) {
                        if (feature in this.features) {
                            return this.features[feature]
                        }
                        this.features[feature] = this.evaluateFeature(feature);
                        return this.features[feature]
                    };
                    Environment.prototype.set = function (feature, value) {
                        this.features[feature] = value
                    };
                    Environment.prototype.getBestBackendType = function () {
                        var _this = this;
                        if (Object.keys(this.registry).length === 0) {
                            throw new Error("No backend found in registry.")
                        }
                        var sortedBackends = Object.keys(this.registry).map(function (name) {
                            return {name: name, entry: _this.registry[name]}
                        }).sort(function (a, b) {
                            return b.entry.priority - a.entry.priority
                        });
                        return sortedBackends[0].name
                    };
                    Environment.prototype.evaluateFeature = function (feature) {
                        if (feature === "DEBUG") {
                            return false
                        } else if (feature === "IS_BROWSER") {
                            return typeof window !== "undefined"
                        } else if (feature === "BACKEND") {
                            return this.getBestBackendType()
                        } else if (feature === "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") {
                            var webGLVersion = this.get("WEBGL_VERSION");
                            if (webGLVersion === 0) {
                                return 0
                            }
                            return getWebGLDisjointQueryTimerVersion(webGLVersion)
                        } else if (feature === "WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") {
                            return this.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !device_util.isMobile()
                        } else if (feature === "WEBGL_VERSION") {
                            if (isWebGLVersionEnabled(2)) {
                                return 2
                            } else if (isWebGLVersionEnabled(1)) {
                                return 1
                            }
                            return 0
                        } else if (feature === "WEBGL_FLOAT_TEXTURE_ENABLED") {
                            return isFloatTextureReadPixelsEnabled(this.get("WEBGL_VERSION"))
                        } else if (feature === "WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED") {
                            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get("WEBGL_VERSION"))
                        }
                        throw new Error("Unknown feature " + feature + ".")
                    };
                    Environment.prototype.setFeatures = function (features) {
                        this.features = features
                    };
                    Environment.prototype.reset = function () {
                        this.features = getFeaturesFromURL();
                        if (this.globalEngine != null) {
                            this.globalEngine.dispose();
                            this.globalEngine = null
                        }
                    };
                    Environment.prototype.initBackend = function (backendType, safeMode) {
                        if (safeMode === void 0) {
                            safeMode = false
                        }
                        this.currentBackend = backendType;
                        if (this.globalEngine != null) {
                            this.globalEngine.dispose()
                        }
                        var backend = exports.ENV.findBackend(backendType);
                        this.globalEngine = new engine_1.Engine(backend, safeMode)
                    };
                    Environment.prototype.findBackend = function (name) {
                        if (!(name in this.registry)) {
                            return null
                        }
                        return this.registry[name].backend
                    };
                    Environment.prototype.registerBackend = function (name, factory, priority) {
                        if (priority === void 0) {
                            priority = 1
                        }
                        if (name in this.registry) {
                            console.warn(name + " backend was already registered")
                        }
                        try {
                            var backend = factory();
                            this.registry[name] = {backend: backend, priority: priority};
                            return true
                        } catch (err) {
                            console.warn(err.message);
                            return false
                        }
                    };
                    Environment.prototype.removeBackend = function (name) {
                        if (!(name in this.registry)) {
                            throw new Error(name + " backend not found in registry")
                        }
                        this.registry[name].backend.dispose();
                        delete this.registry[name]
                    };
                    Object.defineProperty(Environment.prototype, "engine", {
                        get: function () {
                            this.initDefaultBackend();
                            return this.globalEngine
                        }, enumerable: true, configurable: true
                    });
                    Environment.prototype.initDefaultBackend = function () {
                        if (this.globalEngine == null) {
                            this.initBackend(exports.ENV.get("BACKEND"), false)
                        }
                    };
                    __decorate([doc_1.doc({heading: "Environment"})], Environment, "setBackend", null);
                    __decorate([doc_1.doc({heading: "Environment"})], Environment, "getBackend", null);
                    __decorate([doc_1.doc({heading: "Environment"})], Environment, "disposeVariables", null);
                    __decorate([doc_1.doc({
                        heading: "Performance",
                        subheading: "Memory"
                    })], Environment, "memory", null);
                    return Environment
                }();
                exports.Environment = Environment;
                var TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags";

                function getFeaturesFromURL() {
                    var features = {};
                    if (typeof window === "undefined" || typeof window.location === "undefined") {
                        return features
                    }
                    var urlParams = util.getQueryParams(window.location.search);
                    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
                        var urlFlags_1 = {};
                        var keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
                        keyValues.forEach(function (keyValue) {
                            var _a = keyValue.split(":"), key = _a[0], value = _a[1];
                            urlFlags_1[key] = value
                        });
                        exports.URL_PROPERTIES.forEach(function (urlProperty) {
                            if (urlProperty.name in urlFlags_1) {
                                console.log("Setting feature override from URL " + urlProperty.name + ": " + ("" + urlFlags_1[urlProperty.name]));
                                if (urlProperty.type === Type.NUMBER) {
                                    features[urlProperty.name] = +urlFlags_1[urlProperty.name]
                                } else if (urlProperty.type === Type.BOOLEAN) {
                                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === "true"
                                } else if (urlProperty.type === Type.STRING) {
                                    features[urlProperty.name] = urlFlags_1[urlProperty.name]
                                } else {
                                    console.warn("Unknown URL param: " + urlProperty.name + ".")
                                }
                            }
                        })
                    }
                    return features
                }

                function getGlobalNamespace() {
                    var ns;
                    if (typeof window !== "undefined") {
                        ns = window
                    } else if (typeof global !== "undefined") {
                        ns = global
                    } else {
                        throw new Error("Could not find a global object")
                    }
                    return ns
                }

                function getOrMakeEnvironment() {
                    var ns = getGlobalNamespace();
                    ns.ENV = ns.ENV || new Environment(getFeaturesFromURL());
                    return ns.ENV
                }

                exports.ENV = getOrMakeEnvironment()
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {"./device_util": 44, "./doc": 45, "./engine": 46, "./util": 153}],
        48: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var gradients_1 = require("./gradients");
            var tracking_1 = require("./tracking");
            exports.tidy = tracking_1.Tracking.tidy;
            exports.keep = tracking_1.Tracking.keep;
            exports.dispose = tracking_1.Tracking.dispose;
            exports.time = tracking_1.Tracking.time;
            exports.grad = gradients_1.Gradients.grad;
            exports.valueAndGrad = gradients_1.Gradients.valueAndGrad;
            exports.grads = gradients_1.Gradients.grads;
            exports.valueAndGrads = gradients_1.Gradients.valueAndGrads;
            exports.variableGrads = gradients_1.Gradients.variableGrads;
            exports.customGrad = gradients_1.Gradients.customGrad
        }, {"./gradients": 49, "./tracking": 150}],
        49: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("./doc");
            var environment_1 = require("./environment");
            var globals_1 = require("./globals");
            var tensor_1 = require("./tensor");
            var util = require("./util");
            var Gradients = function () {
                function Gradients() {
                }

                Gradients.gradScope = function (nameOrScopeFn, scopeFn) {
                    return globals_1.tidy(nameOrScopeFn, scopeFn, true)
                };
                Gradients.grad = function (f) {
                    util.assert(util.isFunction(f), "The f passed in grad(f) must be a function");
                    return function (x, dy) {
                        util.assert(x instanceof tensor_1.Tensor, "The x passed in grad(f)(x) must be a tensor");
                        util.assert(dy == null || dy instanceof tensor_1.Tensor, "The dy passed in grad(f)(x, dy) must be a tensor");
                        return globals_1.tidy(function () {
                            var _a = environment_1.ENV.engine.gradients(function () {
                                return f(x)
                            }, [x], dy), value = _a.value, grads = _a.grads;
                            if (dy != null) {
                                util.assertShapesMatch(value.shape, dy.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape " + "returned by f(x)")
                            }
                            checkGrads(grads);
                            return grads[0]
                        })
                    }
                };
                Gradients.grads = function (f) {
                    util.assert(util.isFunction(f), "The f passed in grads(f) must be a function");
                    return function (args, dy) {
                        util.assert(Array.isArray(args) && args.every(function (arg) {
                            return arg instanceof tensor_1.Tensor
                        }), "The args passed in grads(f)(args) must be an array of tensors");
                        util.assert(dy == null || dy instanceof tensor_1.Tensor, "The dy passed in grads(f)(args, dy) must be a tensor");
                        return globals_1.tidy(function () {
                            var _a = environment_1.ENV.engine.gradients(function () {
                                return f.apply(void 0, args)
                            }, args, dy), value = _a.value, grads = _a.grads;
                            if (dy != null) {
                                util.assertShapesMatch(value.shape, dy.shape, "The shape of dy passed in grads(f)([x1,...], dy) must " + "match the shape returned by f([x1,...])")
                            }
                            checkGrads(grads);
                            return grads
                        })
                    }
                };
                Gradients.valueAndGrad = function (f) {
                    util.assert(util.isFunction(f), "The f passed in valueAndGrad(f) must be a function");
                    return function (x, dy) {
                        util.assert(x instanceof tensor_1.Tensor, "The x passed in valueAndGrad(f)(x) must be a tensor");
                        util.assert(dy == null || dy instanceof tensor_1.Tensor, "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
                        var _a = environment_1.ENV.engine.gradients(function () {
                            return f(x)
                        }, [x], dy), grads = _a.grads, value = _a.value;
                        checkGrads(grads);
                        return {grad: grads[0], value: value}
                    }
                };
                Gradients.valueAndGrads = function (f) {
                    util.assert(util.isFunction(f), "The f passed in valueAndGrads(f) must be a function");
                    return function (args, dy) {
                        util.assert(Array.isArray(args) && args.every(function (arg) {
                            return arg instanceof tensor_1.Tensor
                        }), "The args passed in valueAndGrads(f)(args) must be array of tensors");
                        util.assert(dy == null || dy instanceof tensor_1.Tensor, "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
                        var res = environment_1.ENV.engine.gradients(function () {
                            return f.apply(void 0, args)
                        }, args, dy);
                        if (dy != null) {
                            util.assertShapesMatch(res.value.shape, dy.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must " + "match the shape returned by f([x1,...])")
                        }
                        checkGrads(res.grads);
                        return res
                    }
                };
                Gradients.variableGrads = function (f, varList) {
                    util.assert(util.isFunction(f), "The f passed in variableGrads(f) must be a function");
                    util.assert(varList == null || Array.isArray(varList) && varList.every(function (v) {
                        return v instanceof tensor_1.Variable
                    }), "The varList passed in variableGrads(f, varList) must be an array " + "of variables");
                    if (varList == null) {
                        varList = [];
                        for (var varName in environment_1.ENV.engine.registeredVariables) {
                            varList.push(environment_1.ENV.engine.registeredVariables[varName])
                        }
                    }
                    var originalVarCount = varList.length;
                    varList = varList.filter(function (variable) {
                        return variable.trainable
                    });
                    util.assert(varList.length > 0, "variableGrads() expects at least one of the input variables to be " + ("trainable, but none of the " + originalVarCount + " variables is ") + "trainable.");
                    var allowNoGradients = true;
                    var _a = environment_1.ENV.engine.gradients(f, varList, null, allowNoGradients), value = _a.value,
                        grads = _a.grads;
                    util.assert(grads.some(function (g) {
                        return g != null
                    }), "Cannot find a connection between any variable and the result of the " + "loss function y=f(x). Please make sure the operations that use " + "variables are inside the function f passed to minimize().");
                    util.assert(value.rank === 0, "The f passed in variableGrads(f) must return a scalar, but it " + ("returned a rank-" + value.rank + " tensor"));
                    var namedGrads = {};
                    varList.forEach(function (v, i) {
                        if (grads[i] != null) {
                            namedGrads[v.name] = grads[i]
                        }
                    });
                    return {value: value, grads: namedGrads}
                };
                Gradients.customGrad = function (f) {
                    return environment_1.ENV.engine.customGrad(f)
                };
                __decorate([doc_1.doc({heading: "Training", subheading: "Gradients"})], Gradients, "grad", null);
                __decorate([doc_1.doc({heading: "Training", subheading: "Gradients"})], Gradients, "grads", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Gradients"
                })], Gradients, "valueAndGrad", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Gradients"
                })], Gradients, "valueAndGrads", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Gradients"
                })], Gradients, "variableGrads", null);
                __decorate([doc_1.doc({heading: "Training", subheading: "Gradients"})], Gradients, "customGrad", null);
                return Gradients
            }();
            exports.Gradients = Gradients;

            function checkGrads(grads) {
                var numNullGradients = grads.filter(function (g) {
                    return g == null
                }).length;
                if (numNullGradients > 0) {
                    throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")
                }
            }
        }, {"./doc": 45, "./environment": 47, "./globals": 48, "./tensor": 147, "./util": 153}],
        50: [function (require, module, exports) {
            "use strict";

            function __export(m) {
                for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p]
            }

            Object.defineProperty(exports, "__esModule", {value: true});
            require("./kernels/backend_webgl");
            require("./kernels/backend_cpu");
            var browser_util_1 = require("./browser_util");
            var environment = require("./environment");
            exports.environment = environment;
            var environment_1 = require("./environment");
            var io = require("./io/io");
            exports.io = io;
            var serialization = require("./serialization");
            exports.serialization = serialization;
            var test_util = require("./test_util");
            exports.test_util = test_util;
            var util = require("./util");
            exports.util = util;
            var version_1 = require("./version");
            exports.version_core = version_1.version;
            var webgl = require("./webgl");
            exports.webgl = webgl;
            var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
            exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
            var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
            exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
            var adam_optimizer_1 = require("./optimizers/adam_optimizer");
            exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
            var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
            exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
            var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
            exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
            var optimizer_1 = require("./optimizers/optimizer");
            exports.Optimizer = optimizer_1.Optimizer;
            var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
            exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
            var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
            exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
            var tensor_1 = require("./tensor");
            exports.Tensor = tensor_1.Tensor;
            exports.TensorBuffer = tensor_1.TensorBuffer;
            exports.variable = tensor_1.variable;
            exports.Variable = tensor_1.Variable;
            var types_1 = require("./types");
            exports.Rank = types_1.Rank;
            __export(require("./ops/ops"));
            var loss_ops_1 = require("./ops/loss_ops");
            exports.Reduction = loss_ops_1.Reduction;
            __export(require("./train"));
            __export(require("./globals"));
            var environment_2 = require("./environment");
            exports.ENV = environment_2.ENV;
            exports.Environment = environment_2.Environment;
            exports.setBackend = environment_1.Environment.setBackend;
            exports.getBackend = environment_1.Environment.getBackend;
            exports.disposeVariables = environment_1.Environment.disposeVariables;
            exports.memory = environment_1.Environment.memory;
            var doc_1 = require("./doc");
            exports.doc = doc_1.doc;
            exports.nextFrame = browser_util_1.BrowserUtil.nextFrame
        }, {
            "./browser_util": 43,
            "./doc": 45,
            "./environment": 47,
            "./globals": 48,
            "./io/io": 54,
            "./kernels/backend_cpu": 61,
            "./kernels/backend_webgl": 63,
            "./ops/loss_ops": 115,
            "./ops/ops": 122,
            "./optimizers/adadelta_optimizer": 135,
            "./optimizers/adagrad_optimizer": 136,
            "./optimizers/adam_optimizer": 137,
            "./optimizers/adamax_optimizer": 138,
            "./optimizers/momentum_optimizer": 139,
            "./optimizers/optimizer": 140,
            "./optimizers/rmsprop_optimizer": 142,
            "./optimizers/sgd_optimizer": 143,
            "./serialization": 145,
            "./tensor": 147,
            "./test_util": 149,
            "./train": 151,
            "./types": 152,
            "./util": 153,
            "./version": 154,
            "./webgl": 155
        }],
        51: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var io_utils_1 = require("./io_utils");
            var router_registry_1 = require("./router_registry");
            var DEFAULT_FILE_NAME_PREFIX = "model";
            var DEFAULT_JSON_EXTENSION_NAME = ".json";
            var DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin";
            var BrowserDownloads = function () {
                function BrowserDownloads(fileNamePrefix) {
                    if (!environment_1.ENV.get("IS_BROWSER")) {
                        throw new Error("triggerDownloads() cannot proceed because the current environment " + "is not a browser.")
                    }
                    if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
                        fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length)
                    }
                    if (fileNamePrefix == null || fileNamePrefix.length === 0) {
                        fileNamePrefix = DEFAULT_FILE_NAME_PREFIX
                    }
                    this.modelTopologyFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
                    this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME
                }

                BrowserDownloads.prototype.save = function (modelArtifacts) {
                    return __awaiter(this, void 0, void 0, function () {
                        var weightsURL, weightsManifest, modelTopologyAndWeightManifest,
                            modelTopologyAndWeightManifestURL, jsonAnchor, weightDataAnchor;
                        return __generator(this, function (_a) {
                            weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], {type: "application/octet-stream"}));
                            if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                                throw new Error("DownloadTrigger.save() does not support saving model topology " + "in binary formats yet.")
                            } else {
                                weightsManifest = [{
                                    paths: ["./" + this.weightDataFileName],
                                    weights: modelArtifacts.weightSpecs
                                }];
                                modelTopologyAndWeightManifest = {
                                    modelTopology: modelArtifacts.modelTopology,
                                    weightsManifest: weightsManifest
                                };
                                modelTopologyAndWeightManifestURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)], {type: "application/json"}));
                                jsonAnchor = this.jsonAnchor == null ? document.createElement("a") : this.jsonAnchor;
                                jsonAnchor.download = this.modelTopologyFileName;
                                jsonAnchor.href = modelTopologyAndWeightManifestURL;
                                jsonAnchor.click();
                                if (modelArtifacts.weightData != null) {
                                    weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
                                    weightDataAnchor.download = this.weightDataFileName;
                                    weightDataAnchor.href = weightsURL;
                                    weightDataAnchor.click()
                                }
                                return [2, {modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts)}]
                            }
                            return [2]
                        })
                    })
                };
                BrowserDownloads.URL_SCHEME = "downloads://";
                return BrowserDownloads
            }();
            exports.BrowserDownloads = BrowserDownloads;
            var BrowserFiles = function () {
                function BrowserFiles(files) {
                    if (files == null || files.length < 1) {
                        throw new Error("When calling browserFiles, at least 1 file is required, " + ("but received " + files))
                    }
                    this.files = files
                }

                BrowserFiles.prototype.load = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var jsonFile, weightFiles;
                        return __generator(this, function (_a) {
                            jsonFile = this.files[0];
                            weightFiles = this.files.slice(1);
                            return [2, new Promise(function (resolve, reject) {
                                var jsonReader = new FileReader;
                                jsonReader.onload = function (event) {
                                    var modelJSON = JSON.parse(event.target.result);
                                    var modelTopology = modelJSON.modelTopology;
                                    if (modelTopology == null) {
                                        reject(new Error("modelTopology field is missing from file " + jsonFile.name));
                                        return
                                    }
                                    if (weightFiles.length === 0) {
                                        resolve({modelTopology: modelTopology})
                                    }
                                    var weightsManifest = modelJSON.weightsManifest;
                                    if (weightsManifest == null) {
                                        reject(new Error("weightManifest field is missing from file " + jsonFile.name));
                                        return
                                    }
                                    var pathToFile;
                                    try {
                                        pathToFile = _this.checkManifestAndWeightFiles(weightsManifest, weightFiles)
                                    } catch (err) {
                                        reject(err);
                                        return
                                    }
                                    var weightSpecs = [];
                                    var paths = [];
                                    var perFileBuffers = [];
                                    weightsManifest.forEach(function (weightsGroup) {
                                        weightsGroup.paths.forEach(function (path) {
                                            paths.push(path);
                                            perFileBuffers.push(null)
                                        });
                                        weightSpecs.push.apply(weightSpecs, weightsGroup.weights)
                                    });
                                    weightsManifest.forEach(function (weightsGroup) {
                                        weightsGroup.paths.forEach(function (path) {
                                            var weightFileReader = new FileReader;
                                            weightFileReader.onload = function (event) {
                                                var weightData = event.target.result;
                                                var index = paths.indexOf(path);
                                                perFileBuffers[index] = weightData;
                                                if (perFileBuffers.indexOf(null) === -1) {
                                                    resolve({
                                                        modelTopology: modelTopology,
                                                        weightSpecs: weightSpecs,
                                                        weightData: io_utils_1.concatenateArrayBuffers(perFileBuffers)
                                                    })
                                                }
                                            };
                                            weightFileReader.onerror = function (error) {
                                                reject("Failed to weights data from file of path '" + path + "'.");
                                                return
                                            };
                                            weightFileReader.readAsArrayBuffer(pathToFile[path])
                                        })
                                    })
                                };
                                jsonReader.onerror = function (error) {
                                    reject("Failed to read model topology and weights manifest JSON " + ("from file '" + jsonFile.name + "'. BrowserFiles supports loading ") + "Keras-style tf.Model artifacts only.");
                                    return
                                };
                                jsonReader.readAsText(jsonFile)
                            })]
                        })
                    })
                };
                BrowserFiles.prototype.checkManifestAndWeightFiles = function (manifest, files) {
                    var basenames = [];
                    var fileNames = files.map(function (file) {
                        return io_utils_1.basename(file.name)
                    });
                    var pathToFile = {};
                    for (var _i = 0, manifest_1 = manifest; _i < manifest_1.length; _i++) {
                        var group = manifest_1[_i];
                        group.paths.forEach(function (path) {
                            var pathBasename = io_utils_1.basename(path);
                            if (basenames.indexOf(pathBasename) !== -1) {
                                throw new Error("Duplicate file basename found in weights manifest: " + ("'" + pathBasename + "'"))
                            }
                            basenames.push(pathBasename);
                            if (fileNames.indexOf(pathBasename) === -1) {
                                throw new Error("Weight file with basename '" + pathBasename + "' is not provided.")
                            } else {
                                pathToFile[path] = files[fileNames.indexOf(pathBasename)]
                            }
                        })
                    }
                    if (basenames.length !== files.length) {
                        throw new Error("Mismatch in the number of files in weights manifest " + ("(" + basenames.length + ") and the number of weight files provided ") + ("(" + files.length + ")."))
                    }
                    return pathToFile
                };
                return BrowserFiles
            }();
            exports.browserDownloadsRouter = function (url) {
                if (!environment_1.ENV.get("IS_BROWSER")) {
                    return null
                } else {
                    if (url.startsWith(BrowserDownloads.URL_SCHEME)) {
                        return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length))
                    } else {
                        return null
                    }
                }
            };
            router_registry_1.IORouterRegistry.registerSaveRouter(exports.browserDownloadsRouter);

            function browserDownloads(fileNamePrefix) {
                if (fileNamePrefix === void 0) {
                    fileNamePrefix = "model"
                }
                return new BrowserDownloads(fileNamePrefix)
            }

            exports.browserDownloads = browserDownloads;

            function browserFiles(files) {
                return new BrowserFiles(files)
            }

            exports.browserFiles = browserFiles
        }, {"../environment": 47, "./io_utils": 55, "./router_registry": 58}],
        52: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var util_1 = require("../util");
            var io_utils_1 = require("./io_utils");
            var router_registry_1 = require("./router_registry");
            var BrowserHTTPRequest = function () {
                function BrowserHTTPRequest(path, requestInit) {
                    this.DEFAULT_METHOD = "POST";
                    if (!environment_1.ENV.get("IS_BROWSER")) {
                        throw new Error("browserHTTPRequest is not supported outside the web browser.")
                    }
                    util_1.assert(path != null && path.length > 0, "URL path for browserHTTPRequest must not be null, undefined or " + "empty.");
                    this.path = path;
                    if (requestInit != null && requestInit.body != null) {
                        throw new Error("requestInit is expected to have no pre-existing body, but has one.")
                    }
                    this.requestInit = requestInit || {}
                }

                BrowserHTTPRequest.prototype.save = function (modelArtifacts) {
                    return __awaiter(this, void 0, void 0, function () {
                        var init, weightsManifest, modelTopologyAndWeightManifest, response;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                                        throw new Error("BrowserHTTPRequest.save() does not support saving model topology " + "in binary formats yet.")
                                    }
                                    init = Object.assign({method: this.DEFAULT_METHOD}, this.requestInit);
                                    init.body = new FormData;
                                    weightsManifest = [{
                                        paths: ["./model.weights.bin"],
                                        weights: modelArtifacts.weightSpecs
                                    }];
                                    modelTopologyAndWeightManifest = {
                                        modelTopology: modelArtifacts.modelTopology,
                                        weightsManifest: weightsManifest
                                    };
                                    init.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], {type: "application/json"}), "model.json");
                                    if (modelArtifacts.weightData != null) {
                                        init.body.append("model.weights.bin", new Blob([modelArtifacts.weightData], {type: "application/octet-stream"}), "model.weights.bin")
                                    }
                                    return [4, fetch(this.path, init)];
                                case 1:
                                    response = _a.sent();
                                    if (response.status === 200) {
                                        return [2, {
                                            modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts),
                                            responses: [response]
                                        }]
                                    } else {
                                        throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + (response.status + "."))
                                    }
                                    return [2]
                            }
                        })
                    })
                };
                BrowserHTTPRequest.URL_SCHEMES = ["http://", "https://"];
                return BrowserHTTPRequest
            }();
            exports.BrowserHTTPRequest = BrowserHTTPRequest;
            exports.httpRequestRouter = function (url) {
                if (!environment_1.ENV.get("IS_BROWSER")) {
                    return null
                } else {
                    for (var _i = 0, _a = BrowserHTTPRequest.URL_SCHEMES; _i < _a.length; _i++) {
                        var scheme = _a[_i];
                        if (url.startsWith(scheme)) {
                            return browserHTTPRequest(url)
                        }
                    }
                    return null
                }
            };
            router_registry_1.IORouterRegistry.registerSaveRouter(exports.httpRequestRouter);

            function browserHTTPRequest(path, requestInit) {
                return new BrowserHTTPRequest(path, requestInit)
            }

            exports.browserHTTPRequest = browserHTTPRequest
        }, {"../environment": 47, "../util": 153, "./io_utils": 55, "./router_registry": 58}],
        53: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var io_utils_1 = require("./io_utils");
            var model_management_1 = require("./model_management");
            var router_registry_1 = require("./router_registry");
            var DATABASE_NAME = "tensorflowjs";
            var DATABASE_VERSION = 1;
            var MODEL_STORE_NAME = "models_store";
            var INFO_STORE_NAME = "model_info_store";

            function deleteDatabase() {
                return __awaiter(this, void 0, void 0, function () {
                    var idbFactory;
                    return __generator(this, function (_a) {
                        idbFactory = getIndexedDBFactory();
                        return [2, new Promise(function (resolve, reject) {
                            var deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);
                            deleteRequest.onsuccess = function () {
                                return resolve()
                            };
                            deleteRequest.onerror = function (error) {
                                return reject(error)
                            }
                        })]
                    })
                })
            }

            exports.deleteDatabase = deleteDatabase;

            function getIndexedDBFactory() {
                if (!environment_1.ENV.get("IS_BROWSER")) {
                    throw new Error("Failed to obtain IndexedDB factory because the current environment" + "is not a web browser.")
                }
                var theWindow = window;
                var factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
                if (factory == null) {
                    throw new Error("The current browser does not appear to support IndexedDB.")
                }
                return factory
            }

            function setUpDatabase(openRequest) {
                var db = openRequest.result;
                db.createObjectStore(MODEL_STORE_NAME, {keyPath: "modelPath"});
                db.createObjectStore(INFO_STORE_NAME, {keyPath: "modelPath"})
            }

            var BrowserIndexedDB = function () {
                function BrowserIndexedDB(modelPath) {
                    this.indexedDB = getIndexedDBFactory();
                    if (modelPath == null || !modelPath) {
                        throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.")
                    }
                    this.modelPath = modelPath
                }

                BrowserIndexedDB.prototype.save = function (modelArtifacts) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                                throw new Error("BrowserLocalStorage.save() does not support saving model topology " + "in binary formats yet.")
                            }
                            return [2, this.databaseAction(this.modelPath, modelArtifacts)]
                        })
                    })
                };
                BrowserIndexedDB.prototype.load = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2, this.databaseAction(this.modelPath)]
                        })
                    })
                };
                BrowserIndexedDB.prototype.databaseAction = function (modelPath, modelArtifacts) {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                        openRequest.onupgradeneeded = function () {
                            return setUpDatabase(openRequest)
                        };
                        openRequest.onsuccess = function () {
                            var db = openRequest.result;
                            if (modelArtifacts == null) {
                                var modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
                                var modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                                var getRequest_1 = modelStore.get(_this.modelPath);
                                getRequest_1.onsuccess = function () {
                                    if (getRequest_1.result == null) {
                                        db.close();
                                        return reject(new Error("Cannot find model with path '" + _this.modelPath + "' " + "in IndexedDB."))
                                    } else {
                                        resolve(getRequest_1.result.modelArtifacts)
                                    }
                                };
                                getRequest_1.onerror = function (error) {
                                    db.close();
                                    return reject(getRequest_1.error)
                                };
                                modelTx.oncomplete = function () {
                                    return db.close()
                                }
                            } else {
                                var modelArtifactsInfo_1 = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);
                                var infoTx_1 = db.transaction(INFO_STORE_NAME, "readwrite");
                                var infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);
                                var putInfoRequest_1 = infoStore_1.put({
                                    modelPath: _this.modelPath,
                                    modelArtifactsInfo: modelArtifactsInfo_1
                                });
                                var modelTx_1;
                                putInfoRequest_1.onsuccess = function () {
                                    modelTx_1 = db.transaction(MODEL_STORE_NAME, "readwrite");
                                    var modelStore = modelTx_1.objectStore(MODEL_STORE_NAME);
                                    var putModelRequest = modelStore.put({
                                        modelPath: _this.modelPath,
                                        modelArtifacts: modelArtifacts,
                                        modelArtifactsInfo: modelArtifactsInfo_1
                                    });
                                    putModelRequest.onsuccess = function () {
                                        return resolve({modelArtifactsInfo: modelArtifactsInfo_1})
                                    };
                                    putModelRequest.onerror = function (error) {
                                        infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);
                                        var deleteInfoRequest = infoStore_1.delete(_this.modelPath);
                                        deleteInfoRequest.onsuccess = function () {
                                            db.close();
                                            return reject(putModelRequest.error)
                                        };
                                        deleteInfoRequest.onerror = function (error) {
                                            db.close();
                                            return reject(putModelRequest.error)
                                        }
                                    }
                                };
                                putInfoRequest_1.onerror = function (error) {
                                    db.close();
                                    return reject(putInfoRequest_1.error)
                                };
                                infoTx_1.oncomplete = function () {
                                    if (modelTx_1 == null) {
                                        db.close()
                                    } else {
                                        modelTx_1.oncomplete = function () {
                                            return db.close()
                                        }
                                    }
                                }
                            }
                        };
                        openRequest.onerror = function (error) {
                            return reject(openRequest.error)
                        }
                    })
                };
                BrowserIndexedDB.URL_SCHEME = "indexeddb://";
                return BrowserIndexedDB
            }();
            exports.BrowserIndexedDB = BrowserIndexedDB;
            exports.indexedDBRouter = function (url) {
                if (!environment_1.ENV.get("IS_BROWSER")) {
                    return null
                } else {
                    if (url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
                        return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length))
                    } else {
                        return null
                    }
                }
            };
            router_registry_1.IORouterRegistry.registerSaveRouter(exports.indexedDBRouter);
            router_registry_1.IORouterRegistry.registerLoadRouter(exports.indexedDBRouter);

            function browserIndexedDB(modelPath) {
                return new BrowserIndexedDB(modelPath)
            }

            exports.browserIndexedDB = browserIndexedDB;

            function maybeStripScheme(key) {
                return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key
            }

            var BrowserIndexedDBManager = function () {
                function BrowserIndexedDBManager() {
                    this.indexedDB = getIndexedDBFactory()
                }

                BrowserIndexedDBManager.prototype.listModels = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2, new Promise(function (resolve, reject) {
                                var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                                openRequest.onupgradeneeded = function () {
                                    return setUpDatabase(openRequest)
                                };
                                openRequest.onsuccess = function () {
                                    var db = openRequest.result;
                                    var tx = db.transaction(INFO_STORE_NAME, "readonly");
                                    var store = tx.objectStore(INFO_STORE_NAME);
                                    var getAllInfoRequest = store.getAll();
                                    getAllInfoRequest.onsuccess = function () {
                                        var out = {};
                                        for (var _i = 0, _a = getAllInfoRequest.result; _i < _a.length; _i++) {
                                            var item = _a[_i];
                                            out[item.modelPath] = item.modelArtifactsInfo
                                        }
                                        resolve(out)
                                    };
                                    getAllInfoRequest.onerror = function (error) {
                                        db.close();
                                        return reject(getAllInfoRequest.error)
                                    };
                                    tx.oncomplete = function () {
                                        return db.close()
                                    }
                                };
                                openRequest.onerror = function (error) {
                                    return reject(openRequest.error)
                                }
                            })]
                        })
                    })
                };
                BrowserIndexedDBManager.prototype.removeModel = function (path) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            path = maybeStripScheme(path);
                            return [2, new Promise(function (resolve, reject) {
                                var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
                                openRequest.onupgradeneeded = function () {
                                    return setUpDatabase(openRequest)
                                };
                                openRequest.onsuccess = function () {
                                    var db = openRequest.result;
                                    var infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
                                    var infoStore = infoTx.objectStore(INFO_STORE_NAME);
                                    var getInfoRequest = infoStore.get(path);
                                    var modelTx;
                                    getInfoRequest.onsuccess = function () {
                                        if (getInfoRequest.result == null) {
                                            db.close();
                                            return reject(new Error("Cannot find model with path '" + path + "' " + "in IndexedDB."))
                                        } else {
                                            var deleteInfoRequest = infoStore.delete(path);
                                            var deleteModelData_1 = function () {
                                                modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
                                                var modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                                                var deleteModelRequest = modelStore.delete(path);
                                                deleteModelRequest.onsuccess = function () {
                                                    return resolve(getInfoRequest.result.modelArtifactsInfo)
                                                };
                                                deleteModelRequest.onerror = function (error) {
                                                    return reject(getInfoRequest.error)
                                                }
                                            };
                                            deleteInfoRequest.onsuccess = deleteModelData_1;
                                            deleteInfoRequest.onerror = function (error) {
                                                deleteModelData_1();
                                                db.close();
                                                return reject(getInfoRequest.error)
                                            }
                                        }
                                    };
                                    getInfoRequest.onerror = function (error) {
                                        db.close();
                                        return reject(getInfoRequest.error)
                                    };
                                    infoTx.oncomplete = function () {
                                        if (modelTx == null) {
                                            db.close()
                                        } else {
                                            modelTx.oncomplete = function () {
                                                return db.close()
                                            }
                                        }
                                    }
                                };
                                openRequest.onerror = function (error) {
                                    return reject(openRequest.error)
                                }
                            })]
                        })
                    })
                };
                return BrowserIndexedDBManager
            }();
            exports.BrowserIndexedDBManager = BrowserIndexedDBManager;
            if (environment_1.ENV.get("IS_BROWSER")) {
                try {
                    model_management_1.ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager)
                } catch (err) {
                }
            }
        }, {"../environment": 47, "./io_utils": 55, "./model_management": 57, "./router_registry": 58}],
        54: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            require("./indexed_db");
            require("./local_storage");
            var browser_files_1 = require("./browser_files");
            exports.browserFiles = browser_files_1.browserFiles;
            var browser_http_1 = require("./browser_http");
            exports.browserHTTPRequest = browser_http_1.browserHTTPRequest;
            var io_utils_1 = require("./io_utils");
            exports.decodeWeights = io_utils_1.decodeWeights;
            exports.encodeWeights = io_utils_1.encodeWeights;
            var model_management_1 = require("./model_management");
            var router_registry_1 = require("./router_registry");
            var weights_loader_1 = require("./weights_loader");
            exports.loadWeights = weights_loader_1.loadWeights;
            var registerSaveRouter = router_registry_1.IORouterRegistry.registerSaveRouter;
            exports.registerSaveRouter = registerSaveRouter;
            var registerLoadRouter = router_registry_1.IORouterRegistry.registerLoadRouter;
            exports.registerLoadRouter = registerLoadRouter;
            var getSaveHandlers = router_registry_1.IORouterRegistry.getSaveHandlers;
            exports.getSaveHandlers = getSaveHandlers;
            var getLoadHandlers = router_registry_1.IORouterRegistry.getLoadHandlers;
            exports.getLoadHandlers = getLoadHandlers;
            var copyModel = model_management_1.ModelManagement.copyModel;
            exports.copyModel = copyModel;
            var listModels = model_management_1.ModelManagement.listModels;
            exports.listModels = listModels;
            var moveModel = model_management_1.ModelManagement.moveModel;
            exports.moveModel = moveModel;
            var removeModel = model_management_1.ModelManagement.removeModel;
            exports.removeModel = removeModel
        }, {
            "./browser_files": 51,
            "./browser_http": 52,
            "./indexed_db": 53,
            "./io_utils": 55,
            "./local_storage": 56,
            "./model_management": 57,
            "./router_registry": 58,
            "./weights_loader": 60
        }],
        55: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var array_ops_1 = require("../ops/array_ops");
            var util_1 = require("../util");
            var types_1 = require("./types");

            function encodeWeights(tensors) {
                return __awaiter(this, void 0, void 0, function () {
                    var specs, dataPromises, name_1, t, tensorValues;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                specs = [];
                                dataPromises = [];
                                for (name_1 in tensors) {
                                    t = tensors[name_1];
                                    if (t.dtype !== "float32" && t.dtype !== "int32" && t.dtype !== "bool") {
                                        throw new Error("Unsupported dtype in weight '" + name_1 + "': " + t.dtype)
                                    }
                                    specs.push({name: name_1, shape: t.shape, dtype: t.dtype});
                                    dataPromises.push(t.data())
                                }
                                return [4, Promise.all(dataPromises)];
                            case 1:
                                tensorValues = _a.sent();
                                return [2, {data: concatenateTypedArrays(tensorValues), specs: specs}]
                        }
                    })
                })
            }

            exports.encodeWeights = encodeWeights;

            function decodeWeights(buffer, specs) {
                var out = {};
                var offset = 0;
                for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
                    var spec = specs_1[_i];
                    var name_2 = spec.name;
                    var dtype = spec.dtype;
                    var shape = spec.shape;
                    if (spec.quantization != null) {
                        throw new Error("decodeWeights does not support quantization yet, but encountered " + ("weight '" + name_2 + " with quantization.'"))
                    }
                    var size = util_1.sizeFromShape(shape);
                    var value = void 0;
                    if (dtype === "float32") {
                        value = array_ops_1.ArrayOps.tensor(new Float32Array(buffer, offset, size), shape, "float32")
                    } else if (dtype === "int32") {
                        value = array_ops_1.ArrayOps.tensor(new Int32Array(buffer, offset, size), shape, "int32")
                    } else if (dtype === "bool") {
                        value = array_ops_1.ArrayOps.tensor(new Uint8Array(buffer, offset, size), shape, "bool")
                    } else {
                        throw new Error("Unsupported dtype in weight '" + name_2 + "': " + dtype)
                    }
                    out[name_2] = value;
                    offset += size * types_1.DTYPE_VALUE_SIZE_MAP[dtype]
                }
                return out
            }

            exports.decodeWeights = decodeWeights;

            function concatenateTypedArrays(xs) {
                if (xs === null) {
                    throw new Error("Invalid input value: " + JSON.stringify(xs))
                }
                var totalByteLength = 0;
                xs.forEach(function (x) {
                    if (x instanceof Float32Array || x instanceof Int32Array) {
                        totalByteLength += x.length * 4
                    } else if (x instanceof Uint8Array) {
                        totalByteLength += x.length
                    } else {
                        throw new Error("Unsupported TypedArray subtype: " + x.constructor.name)
                    }
                });
                var y = new Uint8Array(totalByteLength);
                var offset = 0;
                xs.forEach(function (x) {
                    y.set(new Uint8Array(x.buffer), offset);
                    if (x instanceof Float32Array || x instanceof Int32Array) {
                        offset += x.length * 4
                    } else {
                        offset += x.length
                    }
                });
                return y.buffer
            }

            exports.concatenateTypedArrays = concatenateTypedArrays;

            function stringByteLength(str) {
                return new Blob([str]).size
            }

            exports.stringByteLength = stringByteLength;

            function arrayBufferToBase64String(buffer) {
                return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)))
            }

            exports.arrayBufferToBase64String = arrayBufferToBase64String;

            function base64StringToArrayBuffer(str) {
                var s = atob(str);
                var buffer = new Uint8Array(s.length);
                for (var i = 0; i < s.length; ++i) {
                    buffer.set([s.charCodeAt(i)], i)
                }
                return buffer.buffer
            }

            exports.base64StringToArrayBuffer = base64StringToArrayBuffer;

            function concatenateArrayBuffers(buffers) {
                var totalByteLength = 0;
                buffers.forEach(function (buffer) {
                    totalByteLength += buffer.byteLength
                });
                var temp = new Uint8Array(totalByteLength);
                var offset = 0;
                buffers.forEach(function (buffer) {
                    temp.set(new Uint8Array(buffer), offset);
                    offset += buffer.byteLength
                });
                return temp.buffer
            }

            exports.concatenateArrayBuffers = concatenateArrayBuffers;

            function basename(path) {
                var SEPARATOR = "/";
                path = path.trim();
                while (path.endsWith(SEPARATOR)) {
                    path = path.slice(0, path.length - 1)
                }
                var items = path.split(SEPARATOR);
                return items[items.length - 1]
            }

            exports.basename = basename;

            function getModelArtifactsInfoForJSON(modelArtifacts) {
                if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                    throw new Error("Expected JSON model topology, received ArrayBuffer.")
                }
                return {
                    dateSaved: new Date,
                    modelTopologyType: "JSON",
                    modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
                    weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
                    weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
                }
            }

            exports.getModelArtifactsInfoForJSON = getModelArtifactsInfoForJSON
        }, {"../ops/array_ops": 101, "../util": 153, "./types": 59}],
        56: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var util_1 = require("../util");
            var io_utils_1 = require("./io_utils");
            var model_management_1 = require("./model_management");
            var router_registry_1 = require("./router_registry");
            var PATH_SEPARATOR = "/";
            var PATH_PREFIX = "tensorflowjs_models";
            var INFO_SUFFIX = "info";
            var MODEL_TOPOLOGY_SUFFIX = "model_topology";
            var WEIGHT_SPECS_SUFFIX = "weight_specs";
            var WEIGHT_DATA_SUFFIX = "weight_data";

            function purgeLocalStorageArtifacts() {
                if (!environment_1.ENV.get("IS_BROWSER") || typeof window.localStorage === "undefined") {
                    throw new Error("purgeLocalStorageModels() cannot proceed because local storage is " + "unavailable in the current environment.")
                }
                var LS = window.localStorage;
                var purgedModelPaths = [];
                for (var i = 0; i < LS.length; ++i) {
                    var key = LS.key(i);
                    var prefix = PATH_PREFIX + PATH_SEPARATOR;
                    if (key.startsWith(prefix) && key.length > prefix.length) {
                        LS.removeItem(key);
                        var modelName = getModelPathFromKey(key);
                        if (purgedModelPaths.indexOf(modelName) === -1) {
                            purgedModelPaths.push(modelName)
                        }
                    }
                }
                return purgedModelPaths
            }

            exports.purgeLocalStorageArtifacts = purgeLocalStorageArtifacts;

            function getModelKeys(path) {
                return {
                    info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
                    topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
                    weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
                    weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)
                }
            }

            function getModelPathFromKey(key) {
                var items = key.split(PATH_SEPARATOR);
                if (items.length < 3) {
                    throw new Error("Invalid key format: " + key)
                }
                return items.slice(1, items.length - 1).join(PATH_SEPARATOR)
            }

            function maybeStripScheme(key) {
                return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key
            }

            var BrowserLocalStorage = function () {
                function BrowserLocalStorage(modelPath) {
                    if (!environment_1.ENV.get("IS_BROWSER") || typeof window.localStorage === "undefined") {
                        throw new Error("The current environment does not support local storage.")
                    }
                    this.LS = window.localStorage;
                    if (modelPath == null || !modelPath) {
                        throw new Error("For local storage, modelPath must not be null, undefined or empty.")
                    }
                    this.modelPath = modelPath;
                    this.keys = getModelKeys(this.modelPath)
                }

                BrowserLocalStorage.prototype.save = function (modelArtifacts) {
                    return __awaiter(this, void 0, void 0, function () {
                        var topology, weightSpecs, modelArtifactsInfo, key;
                        return __generator(this, function (_a) {
                            if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
                                throw new Error("BrowserLocalStorage.save() does not support saving model topology " + "in binary formats yet.")
                            } else {
                                topology = JSON.stringify(modelArtifacts.modelTopology);
                                weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
                                modelArtifactsInfo = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);
                                try {
                                    this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
                                    this.LS.setItem(this.keys.topology, topology);
                                    this.LS.setItem(this.keys.weightSpecs, weightSpecs);
                                    this.LS.setItem(this.keys.weightData, io_utils_1.arrayBufferToBase64String(modelArtifacts.weightData));
                                    return [2, {modelArtifactsInfo: modelArtifactsInfo}]
                                } catch (err) {
                                    for (key in this.keys) {
                                        this.LS.removeItem(this.keys[key])
                                    }
                                    throw new Error("Failed to save model '" + this.modelPath + "' to local storage: " + "size quota being exceeded is a possible cause of this failure: " + ("modelTopologyBytes=" + modelArtifactsInfo.modelTopologyBytes + ", ") + ("weightSpecsBytes=" + modelArtifactsInfo.weightSpecsBytes + ", ") + ("weightDataBytes=" + modelArtifactsInfo.weightDataBytes + "."))
                                }
                            }
                            return [2]
                        })
                    })
                };
                BrowserLocalStorage.prototype.load = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var info, out, topology, weightSpecs, weightDataBase64;
                        return __generator(this, function (_a) {
                            info = JSON.parse(this.LS.getItem(this.keys.info));
                            if (info == null) {
                                throw new Error("In local storage, there is no model with name '" + this.modelPath + "'")
                            }
                            if (info.modelTopologyType !== "JSON") {
                                throw new Error("BrowserLocalStorage does not support loading non-JSON model " + "topology yet.")
                            }
                            out = {};
                            topology = JSON.parse(this.LS.getItem(this.keys.topology));
                            if (topology == null) {
                                throw new Error("In local storage, the topology of model '" + this.modelPath + "' " + "is missing.")
                            }
                            out.modelTopology = topology;
                            weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
                            if (weightSpecs == null) {
                                throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' " + "are missing.")
                            }
                            out.weightSpecs = weightSpecs;
                            weightDataBase64 = this.LS.getItem(this.keys.weightData);
                            if (weightDataBase64 == null) {
                                throw new Error("In local storage, the binary weight values of model " + ("'" + this.modelPath + "' are missing."))
                            }
                            out.weightData = io_utils_1.base64StringToArrayBuffer(weightDataBase64);
                            return [2, out]
                        })
                    })
                };
                BrowserLocalStorage.URL_SCHEME = "localstorage://";
                return BrowserLocalStorage
            }();
            exports.BrowserLocalStorage = BrowserLocalStorage;
            exports.localStorageRouter = function (url) {
                if (!environment_1.ENV.get("IS_BROWSER")) {
                    return null
                } else {
                    if (url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
                        return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length))
                    } else {
                        return null
                    }
                }
            };
            router_registry_1.IORouterRegistry.registerSaveRouter(exports.localStorageRouter);
            router_registry_1.IORouterRegistry.registerLoadRouter(exports.localStorageRouter);

            function browserLocalStorage(modelPath) {
                return new BrowserLocalStorage(modelPath)
            }

            exports.browserLocalStorage = browserLocalStorage;
            var BrowserLocalStorageManager = function () {
                function BrowserLocalStorageManager() {
                    util_1.assert(environment_1.ENV.get("IS_BROWSER"), "Current environment is not a web browser");
                    util_1.assert(typeof window.localStorage !== "undefined", "Current browser does not appear to support localStorage");
                    this.LS = window.localStorage
                }

                BrowserLocalStorageManager.prototype.listModels = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var out, prefix, suffix, i, key, modelPath;
                        return __generator(this, function (_a) {
                            out = {};
                            prefix = PATH_PREFIX + PATH_SEPARATOR;
                            suffix = PATH_SEPARATOR + INFO_SUFFIX;
                            for (i = 0; i < this.LS.length; ++i) {
                                key = this.LS.key(i);
                                if (key.startsWith(prefix) && key.endsWith(suffix)) {
                                    modelPath = getModelPathFromKey(key);
                                    out[modelPath] = JSON.parse(this.LS.getItem(key))
                                }
                            }
                            return [2, out]
                        })
                    })
                };
                BrowserLocalStorageManager.prototype.removeModel = function (path) {
                    return __awaiter(this, void 0, void 0, function () {
                        var keys, info;
                        return __generator(this, function (_a) {
                            path = maybeStripScheme(path);
                            keys = getModelKeys(path);
                            if (this.LS.getItem(keys.info) == null) {
                                throw new Error("Cannot find model at path '" + path + "'")
                            }
                            info = JSON.parse(this.LS.getItem(keys.info));
                            this.LS.removeItem(keys.info);
                            this.LS.removeItem(keys.topology);
                            this.LS.removeItem(keys.weightSpecs);
                            this.LS.removeItem(keys.weightData);
                            return [2, info]
                        })
                    })
                };
                return BrowserLocalStorageManager
            }();
            exports.BrowserLocalStorageManager = BrowserLocalStorageManager;
            if (environment_1.ENV.get("IS_BROWSER")) {
                try {
                    model_management_1.ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager)
                } catch (err) {
                }
            }
        }, {"../environment": 47, "../util": 153, "./io_utils": 55, "./model_management": 57, "./router_registry": 58}],
        57: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var util_1 = require("../util");
            var router_registry_1 = require("./router_registry");
            var URL_SCHEME_SUFFIX = "://";
            var ModelStoreManagerRegistry = function () {
                function ModelStoreManagerRegistry() {
                    this.managers = {}
                }

                ModelStoreManagerRegistry.getInstance = function () {
                    if (ModelStoreManagerRegistry.instance == null) {
                        ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry
                    }
                    return ModelStoreManagerRegistry.instance
                };
                ModelStoreManagerRegistry.registerManager = function (scheme, manager) {
                    util_1.assert(scheme != null, "scheme must not be undefined or null.");
                    if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
                        scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX))
                    }
                    util_1.assert(scheme.length > 0, "scheme must not be an empty string.");
                    var registry = ModelStoreManagerRegistry.getInstance();
                    util_1.assert(registry.managers[scheme] == null, "A model store manager is already registered for scheme '" + scheme + "'.");
                    registry.managers[scheme] = manager
                };
                ModelStoreManagerRegistry.getManager = function (scheme) {
                    var manager = this.getInstance().managers[scheme];
                    if (manager == null) {
                        throw new Error("Cannot find model manager for scheme '" + scheme + "'")
                    }
                    return manager
                };
                ModelStoreManagerRegistry.getSchemes = function () {
                    return Object.keys(this.getInstance().managers)
                };
                return ModelStoreManagerRegistry
            }();
            exports.ModelStoreManagerRegistry = ModelStoreManagerRegistry;

            function parseURL(url) {
                if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
                    throw new Error("The url string provided does not contain a scheme. " + "Supported schemes are: " + ("" + ModelStoreManagerRegistry.getSchemes().join(",")))
                }
                return {scheme: url.split(URL_SCHEME_SUFFIX)[0], path: url.split(URL_SCHEME_SUFFIX)[1]}
            }

            function cloneModelInternal(sourceURL, destURL, deleteSource) {
                if (deleteSource === void 0) {
                    deleteSource = false
                }
                return __awaiter(this, void 0, void 0, function () {
                    var loadHandlers, loadHandler, saveHandlers, saveHandler, sourceScheme, sourcePath, sameMedium,
                        modelArtifacts, saveResult;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                util_1.assert(sourceURL !== destURL, "Old path and new path are the same: '" + sourceURL + "'");
                                loadHandlers = router_registry_1.IORouterRegistry.getLoadHandlers(sourceURL);
                                util_1.assert(loadHandlers.length > 0, "Copying failed because no load handler is found for source URL " + sourceURL + ".");
                                util_1.assert(loadHandlers.length < 2, "Copying failed because more than one (" + loadHandlers.length + ") " + ("load handlers for source URL " + sourceURL + "."));
                                loadHandler = loadHandlers[0];
                                saveHandlers = router_registry_1.IORouterRegistry.getSaveHandlers(destURL);
                                util_1.assert(saveHandlers.length > 0, "Copying failed because no save handler is found for destination URL " + (destURL + "."));
                                util_1.assert(saveHandlers.length < 2, "Copying failed because more than one (" + loadHandlers.length + ") " + ("save handlers for destination URL " + destURL + "."));
                                saveHandler = saveHandlers[0];
                                sourceScheme = parseURL(sourceURL).scheme;
                                sourcePath = parseURL(sourceURL).path;
                                sameMedium = sourceScheme === parseURL(sourceURL).scheme;
                                return [4, loadHandler.load()];
                            case 1:
                                modelArtifacts = _a.sent();
                                if (!(deleteSource && sameMedium)) return [3, 3];
                                return [4, ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath)];
                            case 2:
                                _a.sent();
                                _a.label = 3;
                            case 3:
                                return [4, saveHandler.save(modelArtifacts)];
                            case 4:
                                saveResult = _a.sent();
                                if (!(deleteSource && !sameMedium)) return [3, 6];
                                return [4, ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath)];
                            case 5:
                                _a.sent();
                                _a.label = 6;
                            case 6:
                                return [2, saveResult.modelArtifactsInfo]
                        }
                    })
                })
            }

            var ModelManagement = function () {
                function ModelManagement() {
                }

                ModelManagement.listModels = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var schemes, out, _i, schemes_1, scheme, schemeOut, path, url;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    schemes = ModelStoreManagerRegistry.getSchemes();
                                    out = {};
                                    _i = 0, schemes_1 = schemes;
                                    _a.label = 1;
                                case 1:
                                    if (!(_i < schemes_1.length)) return [3, 4];
                                    scheme = schemes_1[_i];
                                    return [4, ModelStoreManagerRegistry.getManager(scheme).listModels()];
                                case 2:
                                    schemeOut = _a.sent();
                                    for (path in schemeOut) {
                                        url = scheme + URL_SCHEME_SUFFIX + path;
                                        out[url] = schemeOut[path]
                                    }
                                    _a.label = 3;
                                case 3:
                                    _i++;
                                    return [3, 1];
                                case 4:
                                    return [2, out]
                            }
                        })
                    })
                };
                ModelManagement.removeModel = function (url) {
                    return __awaiter(this, void 0, void 0, function () {
                        var schemeAndPath, manager;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    schemeAndPath = parseURL(url);
                                    manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
                                    return [4, manager.removeModel(schemeAndPath.path)];
                                case 1:
                                    return [2, _a.sent()]
                            }
                        })
                    })
                };
                ModelManagement.copyModel = function (sourceURL, destURL) {
                    return __awaiter(this, void 0, void 0, function () {
                        var deleteSource;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    deleteSource = false;
                                    return [4, cloneModelInternal(sourceURL, destURL, deleteSource)];
                                case 1:
                                    return [2, _a.sent()]
                            }
                        })
                    })
                };
                ModelManagement.moveModel = function (sourceURL, destURL) {
                    return __awaiter(this, void 0, void 0, function () {
                        var deleteSource;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    deleteSource = true;
                                    return [4, cloneModelInternal(sourceURL, destURL, deleteSource)];
                                case 1:
                                    return [2, _a.sent()]
                            }
                        })
                    })
                };
                __decorate([doc_1.doc({
                    heading: "Models",
                    subheading: "Management"
                })], ModelManagement, "listModels", null);
                __decorate([doc_1.doc({
                    heading: "Models",
                    subheading: "Management"
                })], ModelManagement, "removeModel", null);
                __decorate([doc_1.doc({
                    heading: "Models",
                    subheading: "Management"
                })], ModelManagement, "copyModel", null);
                __decorate([doc_1.doc({
                    heading: "Models",
                    subheading: "Management"
                })], ModelManagement, "moveModel", null);
                return ModelManagement
            }();
            exports.ModelManagement = ModelManagement
        }, {"../doc": 45, "../util": 153, "./router_registry": 58}],
        58: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var IORouterRegistry = function () {
                function IORouterRegistry() {
                    this.saveRouters = [];
                    this.loadRouters = []
                }

                IORouterRegistry.getInstance = function () {
                    if (IORouterRegistry.instance == null) {
                        IORouterRegistry.instance = new IORouterRegistry
                    }
                    return IORouterRegistry.instance
                };
                IORouterRegistry.registerSaveRouter = function (saveRouter) {
                    IORouterRegistry.getInstance().saveRouters.push(saveRouter)
                };
                IORouterRegistry.registerLoadRouter = function (loadRouter) {
                    IORouterRegistry.getInstance().loadRouters.push(loadRouter)
                };
                IORouterRegistry.getSaveHandlers = function (url) {
                    return IORouterRegistry.getHandlers(url, "save")
                };
                IORouterRegistry.getLoadHandlers = function (url) {
                    return IORouterRegistry.getHandlers(url, "load")
                };
                IORouterRegistry.getHandlers = function (url, handlerType) {
                    var validHandlers = [];
                    var routers = handlerType === "load" ? this.getInstance().loadRouters : this.getInstance().saveRouters;
                    routers.forEach(function (router) {
                        var handler = router(url);
                        if (handler !== null) {
                            validHandlers.push(handler)
                        }
                    });
                    return validHandlers
                };
                return IORouterRegistry
            }();
            exports.IORouterRegistry = IORouterRegistry
        }, {}],
        59: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.DTYPE_VALUE_SIZE_MAP = {float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1}
        }, {}],
        60: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var ops_1 = require("../ops/ops");
            var util = require("../util");
            var types_1 = require("./types");

            function loadWeights(manifest, filePathPrefix, weightNames, requestOptions) {
                if (filePathPrefix === void 0) {
                    filePathPrefix = ""
                }
                return __awaiter(this, void 0, void 0, function () {
                    var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames,
                        weightsNotFound, groupIndicesToFetch, requests, responses, buffers, weightsTensorMap,
                        bufferIndexOffset;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                groupIndicesToFetchMap = manifest.map(function () {
                                    return false
                                });
                                groupWeightsToFetch = {};
                                weightsFound = weightNames != null ? weightNames.map(function () {
                                    return false
                                }) : [];
                                allManifestWeightNames = [];
                                manifest.forEach(function (manifestGroupConfig, groupIndex) {
                                    var groupOffset = 0;
                                    manifestGroupConfig.weights.forEach(function (weightsEntry) {
                                        var rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
                                        var weightsBytes = types_1.DTYPE_VALUE_SIZE_MAP[rawDtype] * util.sizeFromShape(weightsEntry.shape);
                                        var enqueueWeightsForFetchingFn = function () {
                                            groupIndicesToFetchMap[groupIndex] = true;
                                            if (groupWeightsToFetch[groupIndex] == null) {
                                                groupWeightsToFetch[groupIndex] = []
                                            }
                                            groupWeightsToFetch[groupIndex].push({
                                                manifestEntry: weightsEntry,
                                                groupOffset: groupOffset,
                                                sizeBytes: weightsBytes
                                            })
                                        };
                                        if (weightNames != null) {
                                            weightNames.forEach(function (weightName, weightIndex) {
                                                if (weightName === weightsEntry.name) {
                                                    enqueueWeightsForFetchingFn();
                                                    weightsFound[weightIndex] = true
                                                }
                                            })
                                        } else {
                                            enqueueWeightsForFetchingFn()
                                        }
                                        allManifestWeightNames.push(weightsEntry.name);
                                        groupOffset += weightsBytes
                                    })
                                });
                                if (!weightsFound.every(function (found) {
                                    return found
                                })) {
                                    weightsNotFound = weightNames.filter(function (weight, i) {
                                        return !weightsFound[i]
                                    });
                                    throw new Error("Could not find weights in manifest with names: " + (weightsNotFound.join(", ") + ". \n") + "Manifest JSON has weights with names: " + (allManifestWeightNames.join(", ") + "."))
                                }
                                groupIndicesToFetch = groupIndicesToFetchMap.reduce(function (accumulator, shouldFetch, i) {
                                    if (shouldFetch) {
                                        accumulator.push(i)
                                    }
                                    return accumulator
                                }, []);
                                requests = [];
                                groupIndicesToFetch.forEach(function (i) {
                                    manifest[i].paths.forEach(function (filepath) {
                                        var fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
                                        requests.push(fetch(fetchUrl, requestOptions))
                                    })
                                });
                                return [4, Promise.all(requests)];
                            case 1:
                                responses = _a.sent();
                                return [4, Promise.all(responses.map(function (response) {
                                    return response.arrayBuffer()
                                }))];
                            case 2:
                                buffers = _a.sent();
                                weightsTensorMap = {};
                                bufferIndexOffset = 0;
                                groupIndicesToFetch.forEach(function (i) {
                                    var numBuffers = manifest[i].paths.length;
                                    var groupBytes = 0;
                                    for (var i_1 = 0; i_1 < numBuffers; i_1++) {
                                        groupBytes += buffers[bufferIndexOffset + i_1].byteLength
                                    }
                                    var groupBuffer = new ArrayBuffer(groupBytes);
                                    var groupByteBuffer = new Uint8Array(groupBuffer);
                                    var groupBufferOffset = 0;
                                    for (var i_2 = 0; i_2 < numBuffers; i_2++) {
                                        var buffer = new Uint8Array(buffers[bufferIndexOffset + i_2]);
                                        groupByteBuffer.set(buffer, groupBufferOffset);
                                        groupBufferOffset += buffer.byteLength
                                    }
                                    var weightsEntries = groupWeightsToFetch[i];
                                    weightsEntries.forEach(function (weightsEntry) {
                                        var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
                                        var typedArray;
                                        var dtype = weightsEntry.manifestEntry.dtype;
                                        if ("quantization" in weightsEntry.manifestEntry) {
                                            var quantization_1 = weightsEntry.manifestEntry.quantization;
                                            if (quantization_1.dtype !== "uint8" && quantization_1.dtype !== "uint16") {
                                                throw new Error("Weight " + weightsEntry.manifestEntry.name + " has unknown " + ("quantization dtype " + quantization_1.dtype + "."))
                                            }
                                            var quantizedArray = quantization_1.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
                                            if (dtype === "float32") {
                                                typedArray = Float32Array.from(quantizedArray, function (v) {
                                                    return v * quantization_1.scale + quantization_1.min
                                                })
                                            } else if (dtype === "int32") {
                                                typedArray = Int32Array.from(quantizedArray, function (v) {
                                                    return Math.round(v * quantization_1.scale + quantization_1.min)
                                                })
                                            } else {
                                                throw new Error("Weight " + weightsEntry.manifestEntry.name + " has a dtype not " + ("supported by quantization: " + dtype))
                                            }
                                        } else {
                                            if (dtype === "float32") {
                                                typedArray = new Float32Array(byteBuffer)
                                            } else if (dtype === "int32") {
                                                typedArray = new Int32Array(byteBuffer)
                                            } else {
                                                throw new Error("Weight " + weightsEntry.manifestEntry.name + " has unknown dtype " + (dtype + "."))
                                            }
                                        }
                                        var weightName = weightsEntry.manifestEntry.name;
                                        if (weightsTensorMap[weightName] != null) {
                                            throw new Error("Duplicate weight with name " + weightName + ". " + "Please make sure weights names are unique in the manifest JSON.")
                                        }
                                        weightsTensorMap[weightName] = ops_1.tensor(typedArray, weightsEntry.manifestEntry.shape, weightsEntry.manifestEntry.dtype)
                                    });
                                    bufferIndexOffset += numBuffers
                                });
                                return [2, weightsTensorMap]
                        }
                    })
                })
            }

            exports.loadWeights = loadWeights
        }, {"../ops/ops": 122, "../util": 153, "./types": 59}],
        61: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var seedrandom = require("seedrandom");
            var environment_1 = require("../environment");
            var axis_util = require("../ops/axis_util");
            var broadcast_util = require("../ops/broadcast_util");
            var concat_util = require("../ops/concat_util");
            var erf_util = require("../ops/erf_util");
            var ops = require("../ops/ops");
            var ops_1 = require("../ops/ops");
            var selu_util = require("../ops/selu_util");
            var slice_util_1 = require("../ops/slice_util");
            var tensor_1 = require("../tensor");
            var types = require("../types");
            var util = require("../util");
            var backend_util = require("./backend_util");
            var MathBackendCPU = function () {
                function MathBackendCPU() {
                    this.data = new WeakMap;
                    if (typeof document !== "undefined") {
                        this.canvas = document.createElement("canvas")
                    }
                }

                MathBackendCPU.prototype.register = function (dataId, shape, dtype) {
                    if (this.data.has(dataId)) {
                        throw new Error("Data buffer is already registered")
                    }
                    this.data.set(dataId, null)
                };
                MathBackendCPU.prototype.write = function (dataId, values) {
                    if (values == null) {
                        throw new Error("MathBackendCPU.write(): values can not be null")
                    }
                    this.throwIfNoData(dataId);
                    this.data.set(dataId, values)
                };
                MathBackendCPU.prototype.fromPixels = function (pixels, numChannels) {
                    if (pixels == null) {
                        throw new Error("MathBackendCPU.writePixels(): pixels can not be null")
                    }
                    var vals;
                    if (pixels instanceof ImageData) {
                        vals = pixels.data
                    } else if (pixels instanceof HTMLCanvasElement) {
                        vals = pixels.getContext("2d").getImageData(0, 0, pixels.width, pixels.height).data
                    } else if (pixels instanceof HTMLImageElement || pixels instanceof HTMLVideoElement) {
                        if (this.canvas == null) {
                            throw new Error("Can't read pixels from HTMLImageElement outside " + "the browser.")
                        }
                        this.canvas.width = pixels.width;
                        this.canvas.height = pixels.height;
                        this.canvas.getContext("2d").drawImage(pixels, 0, 0, pixels.width, pixels.height);
                        vals = this.canvas.getContext("2d").getImageData(0, 0, pixels.width, pixels.height).data
                    } else {
                        throw new Error("pixels is of unknown type: " + pixels.constructor.name)
                    }
                    var values;
                    if (numChannels === 4) {
                        values = new Int32Array(vals)
                    } else {
                        var numPixels = pixels.width * pixels.height;
                        values = new Int32Array(numPixels * numChannels);
                        for (var i = 0; i < numPixels; i++) {
                            for (var channel = 0; channel < numChannels; ++channel) {
                                values[i * numChannels + channel] = vals[i * 4 + channel]
                            }
                        }
                    }
                    var outShape = [pixels.height, pixels.width, numChannels];
                    return ops_1.tensor3d(values, outShape, "int32")
                };
                MathBackendCPU.prototype.read = function (dataId) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2, this.readSync(dataId)]
                        })
                    })
                };
                MathBackendCPU.prototype.readSync = function (dataId) {
                    this.throwIfNoData(dataId);
                    return this.data.get(dataId)
                };
                MathBackendCPU.prototype.disposeData = function (dataId) {
                    if (this.data.has(dataId)) {
                        this.data.delete(dataId)
                    }
                };
                MathBackendCPU.prototype.time = function (f) {
                    return __awaiter(this, void 0, void 0, function () {
                        var start, kernelMs;
                        return __generator(this, function (_a) {
                            start = performance.now();
                            f();
                            kernelMs = performance.now() - start;
                            return [2, {kernelMs: kernelMs}]
                        })
                    })
                };
                MathBackendCPU.prototype.memory = function () {
                    return {unreliable: true}
                };
                MathBackendCPU.prototype.throwIfNoData = function (dataId) {
                    if (!this.data.has(dataId)) {
                        throw new Error("CPU backend: No data found for this tensor. " + "Did you change your backend in the middle of the program? " + "New backends can't use Tensors created with previous backends")
                    }
                };
                MathBackendCPU.prototype.slice = function (x, begin, size) {
                    var buffer = ops.buffer(size, x.dtype);
                    for (var i = 0; i < buffer.size; ++i) {
                        var loc = buffer.indexToLoc(i);
                        var xLoc = loc.map(function (idx, j) {
                            return idx + begin[j]
                        });
                        buffer.set.apply(buffer, [x.get.apply(x, xLoc)].concat(loc))
                    }
                    return buffer.toTensor()
                };
                MathBackendCPU.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
                    var _a = slice_util_1.getStridedSlicedInfo(x.shape, begin, end, strides, beginMask, endMask),
                        beginIndex = _a[0], size = _a[1];
                    if (size.some(function (axis) {
                        return axis === 0
                    })) {
                        return ops.tensor([], size)
                    }
                    var buffer = ops.buffer(size, x.dtype);
                    for (var i = 0; i < buffer.size; i++) {
                        var loc = buffer.indexToLoc(i);
                        var newLoc = new Array(loc.length);
                        for (var j = 0; j < newLoc.length; j++) {
                            newLoc[j] = loc[j] * strides[j] + beginIndex[j]
                        }
                        buffer.set.apply(buffer, [x.get.apply(x, newLoc)].concat(loc))
                    }
                    return buffer.toTensor()
                };
                MathBackendCPU.prototype.reverse = function (x, axis) {
                    var buffer = ops.buffer(x.shape, x.dtype);
                    var xBuffer = x.buffer();
                    var _loop_1 = function (i) {
                        var outLoc = buffer.indexToLoc(i);
                        var inLoc = outLoc.slice();
                        axis.forEach(function (ax) {
                            return inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]
                        });
                        buffer.set.apply(buffer, [xBuffer.get.apply(xBuffer, inLoc)].concat(outLoc))
                    };
                    for (var i = 0; i < buffer.size; i++) {
                        _loop_1(i)
                    }
                    return buffer.toTensor()
                };
                MathBackendCPU.prototype.concat = function (a, b) {
                    var outShape = concat_util.computeOutShape(a.shape, b.shape, 1);
                    var buffer = ops.buffer(outShape, a.dtype);
                    if (a.shape[0] === 1 && b.shape[0] === 1) {
                        var aVals = a.dataSync();
                        var bVals = b.dataSync();
                        var vals = buffer.values;
                        vals.set(aVals, 0);
                        vals.set(bVals, a.size);
                        return buffer.toTensor()
                    }
                    for (var i = 0; i < outShape[0]; ++i) {
                        for (var j = 0; j < a.shape[1]; ++j) {
                            buffer.set(a.get(i, j), i, j)
                        }
                        for (var j = 0; j < b.shape[1]; ++j) {
                            buffer.set(b.get(i, j), i, j + a.shape[1])
                        }
                    }
                    return buffer.toTensor()
                };
                MathBackendCPU.prototype.neg = function (x) {
                    return this.multiply(ops.scalar(-1), x)
                };
                MathBackendCPU.prototype.add = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) {
                        return aValue + bValue
                    })
                };
                MathBackendCPU.prototype.subtract = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) {
                        return aValue - bValue
                    })
                };
                MathBackendCPU.prototype.pow = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) {
                        return Math.pow(aValue, bValue)
                    })
                };
                MathBackendCPU.prototype.matMul = function (a, b, transposeA, transposeB) {
                    var sharedDim = transposeA ? a.shape[0] : a.shape[1];
                    var leftDim = transposeA ? a.shape[1] : a.shape[0];
                    var rightDim = transposeB ? b.shape[0] : b.shape[1];
                    var aValues = a.dataSync();
                    var bValues = b.dataSync();
                    var _a = transposeA ? [1, a.strides[0]] : [a.strides[0], 1], aOuterStep = _a[0], aInnerStep = _a[1];
                    var _b = transposeB ? [b.strides[0], 1] : [1, b.strides[0]], bOuterStep = _b[0], bInnerStep = _b[1];
                    var aOuterEnd = leftDim * aOuterStep;
                    var bOuterEnd = rightDim * bOuterStep;
                    var result = new Float32Array(leftDim * rightDim);
                    var resultIndex = 0;
                    for (var aOuter = 0; aOuter < aOuterEnd; aOuter += aOuterStep) {
                        for (var bOuter = 0; bOuter < bOuterEnd; bOuter += bOuterStep) {
                            var aInner = aOuter;
                            var bInner = bOuter;
                            var sum = 0;
                            for (var k = 0; k < sharedDim; ++k) {
                                sum += aValues[aInner] * bValues[bInner];
                                aInner += aInnerStep;
                                bInner += bInnerStep
                            }
                            result[resultIndex++] = sum
                        }
                    }
                    return ops.tensor2d(result, [leftDim, rightDim])
                };
                MathBackendCPU.prototype.multiply = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) {
                        return aValue * bValue
                    })
                };
                MathBackendCPU.prototype.divide = function (a, b) {
                    var op;
                    var outputDtype;
                    if (a.dtype === "int32" && b.dtype === "int32") {
                        outputDtype = "int32";
                        op = function (a, b) {
                            return Math.floor(a / b)
                        }
                    } else {
                        outputDtype = "float32";
                        op = function (a, b) {
                            return a / b
                        }
                    }
                    return this.broadcastedBinaryOp(a, b, outputDtype, op)
                };
                MathBackendCPU.prototype.sum = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims("sum", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var resultDtype = types.upcastType(x.dtype, "int32");
                    var result = ops.zeros(outShape, resultDtype);
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.dataSync();
                    var aVals = x.dataSync();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var sum = 0;
                        for (var j = 0; j < reduceSize; ++j) {
                            sum += aVals[offset + j]
                        }
                        vals[i] = sum
                    }
                    return result
                };
                MathBackendCPU.prototype.argMin = function (x, axis) {
                    var axes = [axis];
                    axis_util.assertAxesAreInnerMostDims("argMin", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var result = ops.zeros(outShape, "int32");
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.dataSync();
                    var aVals = x.dataSync();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var min = aVals[offset];
                        var minIndex = 0;
                        for (var j = 0; j < reduceSize; ++j) {
                            var value = aVals[offset + j];
                            if (value < min) {
                                min = value;
                                minIndex = j
                            }
                        }
                        vals[i] = minIndex
                    }
                    return result
                };
                MathBackendCPU.prototype.argMax = function (x, axis) {
                    var axes = [axis];
                    axis_util.assertAxesAreInnerMostDims("argMax", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var result = ops.zeros(outShape, "int32");
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.dataSync();
                    var aVals = x.dataSync();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var max = aVals[offset];
                        var maxIndex = 0;
                        for (var j = 0; j < reduceSize; ++j) {
                            var value = aVals[offset + j];
                            if (value > max) {
                                max = value;
                                maxIndex = j
                            }
                        }
                        vals[i] = maxIndex
                    }
                    return result
                };
                MathBackendCPU.prototype.cumsum = function (x, axis, exclusive, reverse) {
                    if (axis !== x.rank - 1) {
                        throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (x.rank - 1) + " " + ("but got axis=" + axis))
                    }
                    var resultDtype = types.upcastType(x.dtype, "int32");
                    var result = ops.zeros(x.shape, resultDtype);
                    var vals = result.dataSync();
                    var aVals = x.dataSync();
                    var finalDim = x.shape[x.rank - 1];
                    var indexAdjuster = reverse ? function (i, j) {
                        return i + finalDim - j - 1
                    } : function (i, j) {
                        return i + j
                    };
                    for (var i = 0; i < aVals.length; i += finalDim) {
                        for (var j = 0; j < finalDim; j++) {
                            var idx = indexAdjuster(i, j);
                            if (j === 0) {
                                vals[idx] = exclusive ? 0 : aVals[idx]
                            } else {
                                var prevIdx = indexAdjuster(i, j - 1);
                                vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx]
                            }
                        }
                    }
                    return result
                };
                MathBackendCPU.prototype.equal = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, "bool", function (aVal, bVal) {
                        return aVal === bVal ? 1 : 0
                    })
                };
                MathBackendCPU.prototype.notEqual = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, "bool", function (aVal, bVal) {
                        return aVal !== bVal ? 1 : 0
                    })
                };
                MathBackendCPU.prototype.less = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, "bool", function (aVal, bVal) {
                        return aVal < bVal ? 1 : 0
                    })
                };
                MathBackendCPU.prototype.lessEqual = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, "bool", function (aVal, bVal) {
                        return aVal <= bVal ? 1 : 0
                    })
                };
                MathBackendCPU.prototype.greater = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, "bool", function (aVal, bVal) {
                        return aVal > bVal ? 1 : 0
                    })
                };
                MathBackendCPU.prototype.greaterEqual = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, "bool", function (aVal, bVal) {
                        return aVal >= bVal ? 1 : 0
                    })
                };
                MathBackendCPU.prototype.logicalNot = function (x) {
                    var values = x.dataSync();
                    var newValues = new Int32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = values[i] ? 0 : 1
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues}, "bool")
                };
                MathBackendCPU.prototype.logicalAnd = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, "bool", function (aVal, bVal) {
                        return aVal && bVal
                    })
                };
                MathBackendCPU.prototype.logicalOr = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, "bool", function (aVal, bVal) {
                        return aVal || bVal
                    })
                };
                MathBackendCPU.prototype.where = function (condition, a, b, dtype) {
                    var values = condition.dataSync();
                    var aValues = a.dataSync();
                    var bValues = b.dataSync();
                    var result = ops.zeros(a.shape, dtype);
                    var newValues = result.dataSync();
                    var index = 0;
                    var offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ? 1 : a.shape[1];
                    for (var i = 0; i < values.length; i++) {
                        for (var j = 0; j < offset; j++) {
                            if (values[i] === 1) {
                                newValues[index++] = aValues[i]
                            } else {
                                newValues[index++] = bValues[i]
                            }
                        }
                    }
                    return result
                };
                MathBackendCPU.prototype.topKValues = function (x, k) {
                    return this.topK(x, k).values
                };
                MathBackendCPU.prototype.topKIndices = function (x, k) {
                    return this.topK(x, k).indices
                };
                MathBackendCPU.prototype.topK = function (x, k) {
                    var values = x.dataSync();
                    var valuesAndIndices = [];
                    for (var i = 0; i < values.length; i++) {
                        valuesAndIndices.push({value: values[i], index: i})
                    }
                    valuesAndIndices.sort(function (a, b) {
                        return b.value - a.value
                    });
                    var topkValues = util.getTypedArrayFromDType(x.dtype, k);
                    var topkIndices = new Int32Array(k);
                    for (var i = 0; i < k; i++) {
                        topkValues[i] = valuesAndIndices[i].value;
                        topkIndices[i] = valuesAndIndices[i].index
                    }
                    return {values: ops.tensor1d(topkValues, x.dtype), indices: ops.tensor1d(topkIndices, "int32")}
                };
                MathBackendCPU.prototype.min = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims("min", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var result = ops.zeros(outShape, x.dtype);
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.dataSync();
                    var aVals = x.dataSync();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var min = aVals[0];
                        for (var j = 0; j < reduceSize; ++j) {
                            var value = aVals[offset + j];
                            if (value < min) {
                                min = value
                            }
                        }
                        vals[i] = min
                    }
                    return result
                };
                MathBackendCPU.prototype.minimum = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
                        return Math.min(aVal, bVal)
                    })
                };
                MathBackendCPU.prototype.mod = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
                        var rem = aVal % bVal;
                        if (aVal < 0 && bVal < 0 || aVal >= 0 && bVal >= 0) {
                            return rem
                        } else {
                            return (rem + bVal) % bVal
                        }
                    })
                };
                MathBackendCPU.prototype.max = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims("max", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var result = ops.zeros(outShape, x.dtype);
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.dataSync();
                    var aVals = x.dataSync();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var max = aVals[offset];
                        for (var j = 0; j < reduceSize; ++j) {
                            var value = aVals[offset + j];
                            if (value > max) {
                                max = value
                            }
                        }
                        vals[i] = max
                    }
                    return result
                };
                MathBackendCPU.prototype.maximum = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
                        return Math.max(aVal, bVal)
                    })
                };
                MathBackendCPU.prototype.squaredDifference = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) {
                        var diff = aVal - bVal;
                        return diff * diff
                    })
                };
                MathBackendCPU.prototype.ceil = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = Math.ceil(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.floor = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = Math.floor(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.sign = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        if (values[i] < 0) {
                            newValues[i] = -1
                        } else if (values[i] > 0) {
                            newValues[i] = 1
                        } else {
                            newValues[i] = 0
                        }
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.round = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var base = Math.floor(values[i]);
                        if (values[i] - base < .5) {
                            newValues[i] = Math.floor(values[i])
                        } else if (values[i] - base > .5) {
                            newValues[i] = Math.ceil(values[i])
                        } else {
                            if (base % 2 === 0) {
                                newValues[i] = base
                            } else {
                                newValues[i] = base + 1
                            }
                        }
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.exp = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = Math.exp(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.expm1 = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = Math.expm1(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.log = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        newValues[i] = Math.log(value)
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.log1p = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        newValues[i] = Math.log1p(value)
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.sqrt = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        newValues[i] = Math.sqrt(value)
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.rsqrt = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        newValues[i] = 1 / Math.sqrt(value)
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.square = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        newValues[i] = value * value
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.reciprocal = function (x) {
                    var values = x.dataSync();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = 1 / values[i]
                    }
                    return tensor_1.Tensor.make(x.shape, {values: newValues})
                };
                MathBackendCPU.prototype.relu = function (x) {
                    var res = ops.zeros(x.shape, x.dtype);
                    var resVals = res.dataSync();
                    var inVals = x.dataSync();
                    for (var i = 0; i < inVals.length; ++i) {
                        resVals[i] = Math.max(0, inVals[i])
                    }
                    return res
                };
                MathBackendCPU.prototype.elu = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        var v = values[i];
                        if (v >= 0) {
                            resultValues[i] = v
                        } else {
                            resultValues[i] = Math.exp(v) - 1
                        }
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.eluDer = function (dy, y) {
                    var resultValues = new Float32Array(y.size);
                    var values = y.dataSync();
                    var dyValues = dy.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        var v = values[i];
                        if (v >= 1) {
                            resultValues[i] = dyValues[i]
                        } else {
                            resultValues[i] = dyValues[i] * (v + 1)
                        }
                    }
                    return tensor_1.Tensor.make(y.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.selu = function (x) {
                    var scaleAlpha = selu_util.SELU_SCALEALPHA;
                    var scale = selu_util.SELU_SCALE;
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        var v = values[i];
                        if (v >= 0) {
                            resultValues[i] = scale * v
                        } else {
                            resultValues[i] = scaleAlpha * (Math.exp(v) - 1)
                        }
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.clip = function (x, min, max) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.min(max, Math.max(min, values[i]))
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.abs = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.abs(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.int = function (x) {
                    var resultValues = new Int32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = values[i]
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues}, "int32")
                };
                MathBackendCPU.prototype.sigmoid = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = 1 / (1 + Math.exp(-values[i]))
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.softplus = function (x) {
                    var epsilon = 1.1920928955078125e-7;
                    var threshold = Math.log(epsilon) + 2;
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        var tooLarge = values[i] > -threshold;
                        var tooSmall = values[i] < threshold;
                        var expX = Math.exp(values[i]);
                        var result = void 0;
                        if (tooSmall) {
                            result = expX
                        } else if (tooLarge) {
                            result = values[i]
                        } else {
                            result = Math.log(1 + expX)
                        }
                        resultValues[i] = result
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.sin = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.sin(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.cos = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.cos(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.tan = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.tan(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.asin = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.asin(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.acos = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.acos(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.atan = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.atan(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.atan2 = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) {
                        return Math.atan2(aValue, bValue)
                    })
                };
                MathBackendCPU.prototype.sinh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.sinh(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.cosh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.cosh(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.tanh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = util.tanh(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.asinh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.asinh(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.acosh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.acosh(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.atanh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.atanh(values[i])
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.erf = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    var p = erf_util.ERF_P;
                    var a1 = erf_util.ERF_A1;
                    var a2 = erf_util.ERF_A2;
                    var a3 = erf_util.ERF_A3;
                    var a4 = erf_util.ERF_A4;
                    var a5 = erf_util.ERF_A5;
                    for (var i = 0; i < values.length; ++i) {
                        var v = values[i];
                        var t = 1 / (1 + p * v);
                        resultValues[i] = 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-v * v)
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.step = function (x, alpha) {
                    if (alpha === void 0) {
                        alpha = 0
                    }
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        if (isNaN(value)) {
                            resultValues[i] = NaN
                        } else {
                            resultValues[i] = value > 0 ? 1 : alpha
                        }
                    }
                    return tensor_1.Tensor.make(x.shape, {values: resultValues})
                };
                MathBackendCPU.prototype.conv2d = function (x, filter, convInfo) {
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var dilationHeight = convInfo.dilationHeight;
                    var dilationWidth = convInfo.dilationWidth;
                    var padLeft = convInfo.padInfo.left;
                    var padTop = convInfo.padInfo.top;
                    var y = ops.buffer(convInfo.outShape, x.dtype);
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                                var xRCorner = yR * convInfo.strideHeight - padLeft;
                                for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                                    var xCCorner = yC * convInfo.strideWidth - padTop;
                                    var dotProd = 0;
                                    for (var wR = 0; wR < filterHeight; wR++) {
                                        var xR = xRCorner + wR * dilationHeight;
                                        if (xR < 0 || xR >= convInfo.inHeight) {
                                            continue
                                        }
                                        for (var wC = 0; wC < filterWidth; wC++) {
                                            var xC = xCCorner + wC * dilationWidth;
                                            if (xC < 0 || xC >= convInfo.inWidth) {
                                                continue
                                            }
                                            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                                var pixel = x.get(b, xR, xC, d1);
                                                var weight = filter.get(wR, wC, d1, d2);
                                                dotProd += pixel * weight
                                            }
                                        }
                                    }
                                    y.set(dotProd, b, yR, yC, d2)
                                }
                            }
                        }
                    }
                    return y.toTensor()
                };
                MathBackendCPU.prototype.conv2dDerInput = function (dy, filter, convInfo) {
                    var dx = ops.buffer(convInfo.inShape, "float32");
                    var dxValues = dx.values;
                    var _a = dx.strides, dxS0 = _a[0], dxS1 = _a[1], dxS2 = _a[2];
                    var dyValues = dy.dataSync();
                    var _b = dy.strides, dyS0 = _b[0], dyS1 = _b[1], dyS2 = _b[2];
                    var fltValues = filter.dataSync();
                    var _c = filter.strides, fltS0 = _c[0], fltS1 = _c[1], fltS2 = _c[2];
                    var batchSize = convInfo.batchSize, filterHeight = convInfo.filterHeight,
                        filterWidth = convInfo.filterWidth, inChannels = convInfo.inChannels,
                        inHeight = convInfo.inHeight, inWidth = convInfo.inWidth, outChannels = convInfo.outChannels,
                        outHeight = convInfo.outHeight, outWidth = convInfo.outWidth,
                        strideHeight = convInfo.strideHeight, strideWidth = convInfo.strideWidth;
                    var topPad = filterHeight - 1 - convInfo.padInfo.top;
                    var leftPad = filterWidth - 1 - convInfo.padInfo.left;
                    for (var b = 0; b < batchSize; ++b) {
                        for (var d1 = 0; d1 < inChannels; ++d1) {
                            for (var xR = 0; xR < inHeight; ++xR) {
                                var xRCorner = xR - topPad;
                                var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                                var yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
                                for (var xC = 0; xC < inWidth; ++xC) {
                                    var xCCorner = xC - leftPad;
                                    var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                                    var yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                                    var dotProd = 0;
                                    for (var yR = xRMin; yR < yRMax; ++yR) {
                                        var wR = yR * strideHeight - xRCorner;
                                        for (var yC = xCMin; yC < yCMax; ++yC) {
                                            var wC = yC * strideWidth - xCCorner;
                                            var dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                                            var fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                                            for (var d2 = 0; d2 < outChannels; ++d2) {
                                                var pixel = dyValues[dyOffset + d2];
                                                var weight = fltValues[fltOffset + d2];
                                                dotProd += pixel * weight
                                            }
                                        }
                                    }
                                    dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd
                                }
                            }
                        }
                    }
                    return dx.toTensor()
                };
                MathBackendCPU.prototype.conv2dDerFilter = function (x, dy, convInfo) {
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var dW = ops.buffer(convInfo.filterShape, "float32");
                    var leftPad = convInfo.padInfo.left;
                    var topPad = convInfo.padInfo.top;
                    for (var wR = 0; wR < filterHeight; ++wR) {
                        var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
                        var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
                        for (var wC = 0; wC < filterWidth; ++wC) {
                            var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                            var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                                    var dotProd = 0;
                                    for (var b = 0; b < convInfo.batchSize; ++b) {
                                        for (var yR = yRMin; yR < yRMax; ++yR) {
                                            var xR = wR + yR * strideHeight - topPad;
                                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                                var xC = wC + yC * strideWidth - leftPad;
                                                dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2)
                                            }
                                        }
                                    }
                                    dW.set(dotProd, wR, wC, d1, d2)
                                }
                            }
                        }
                    }
                    return dW.toTensor()
                };
                MathBackendCPU.prototype.depthwiseConv2D = function (x, filter, convInfo) {
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var dilationHeight = convInfo.dilationHeight;
                    var dilationWidth = convInfo.dilationWidth;
                    var padLeft = convInfo.padInfo.left;
                    var padTop = convInfo.padInfo.top;
                    var chMul = convInfo.outChannels / convInfo.inChannels;
                    var y = ops.buffer(convInfo.outShape, x.dtype);
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                                var xRCorner = yR * convInfo.strideHeight - padLeft;
                                for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                                    var xCCorner = yC * convInfo.strideWidth - padTop;
                                    for (var q = 0; q < chMul; ++q) {
                                        var dotProd = 0;
                                        for (var wR = 0; wR < filterHeight; ++wR) {
                                            var xR = xRCorner + wR * dilationHeight;
                                            if (xR < 0 || xR >= convInfo.inHeight) {
                                                continue
                                            }
                                            for (var wC = 0; wC < filterWidth; ++wC) {
                                                var xC = xCCorner + wC * dilationWidth;
                                                if (xC < 0 || xC >= convInfo.inWidth) {
                                                    continue
                                                }
                                                var pixel = x.get(b, xR, xC, d1);
                                                var weight = filter.get(wR, wC, d1, q);
                                                dotProd += pixel * weight
                                            }
                                        }
                                        y.set(dotProd, b, yR, yC, d1 * chMul + q)
                                    }
                                }
                            }
                        }
                    }
                    return y.toTensor()
                };
                MathBackendCPU.prototype.tile = function (x, reps) {
                    var newShape = new Array(x.rank);
                    for (var i = 0; i < newShape.length; i++) {
                        newShape[i] = x.shape[i] * reps[i]
                    }
                    var result = ops.buffer(newShape, x.dtype);
                    var xBuf = x.buffer();
                    for (var i = 0; i < result.values.length; ++i) {
                        var newLoc = result.indexToLoc(i);
                        var originalLoc = new Array(x.rank);
                        for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                            originalLoc[i_1] = newLoc[i_1] % x.shape[i_1]
                        }
                        var originalIndex = xBuf.locToIndex(originalLoc);
                        result.values[i] = xBuf.values[originalIndex]
                    }
                    return result.toTensor()
                };
                MathBackendCPU.prototype.pad = function (x, paddings, constantValue) {
                    var outShape = paddings.map(function (p, i) {
                        return p[0] + x.shape[i] + p[1]
                    });
                    var start = paddings.map(function (p) {
                        return p[0]
                    });
                    var xBuffer = x.buffer();
                    var buffer = ops.buffer(outShape, x.dtype);
                    if (constantValue !== 0) {
                        buffer.values.fill(constantValue)
                    }
                    for (var i = 0; i < x.size; i++) {
                        var coords = xBuffer.indexToLoc(i);
                        var outCoords = coords.map(function (c, i) {
                            return c + start[i]
                        });
                        buffer.set.apply(buffer, [x.get.apply(x, coords)].concat(outCoords))
                    }
                    return buffer.toTensor()
                };
                MathBackendCPU.prototype.transpose = function (x, perm) {
                    var newShape = new Array(x.rank);
                    for (var i = 0; i < newShape.length; i++) {
                        newShape[i] = x.shape[perm[i]]
                    }
                    var values = x.dataSync();
                    var result = ops_1.buffer(newShape, x.dtype);
                    var xBuf = x.buffer();
                    for (var i = 0; i < x.size; ++i) {
                        var loc = xBuf.indexToLoc(i);
                        var newLoc = new Array(loc.length);
                        for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                            newLoc[i_2] = loc[perm[i_2]]
                        }
                        var newIndex = result.locToIndex(newLoc);
                        result.values[newIndex] = values[i]
                    }
                    return result.toTensor()
                };
                MathBackendCPU.prototype.gather = function (x, indices, axis) {
                    var newShape = x.shape.slice();
                    var indicesValues = indices.dataSync();
                    newShape[axis] = indicesValues.length;
                    var result = ops_1.buffer(newShape, x.dtype);
                    var xBuf = x.buffer();
                    for (var i = 0; i < result.size; ++i) {
                        var newLoc = result.indexToLoc(i);
                        var originalLoc = newLoc.slice();
                        originalLoc[axis] = indicesValues[newLoc[axis]];
                        var originalIndex = xBuf.locToIndex(originalLoc);
                        result.values[i] = xBuf.values[originalIndex]
                    }
                    return result.toTensor()
                };
                MathBackendCPU.prototype.pool = function (x, convInfo, poolType) {
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var y = ops.buffer(convInfo.outShape, "float32");
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d = 0; d < convInfo.inChannels; ++d) {
                            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                                var xRCorner = yR * strideHeight - padTop;
                                var xRMin = Math.max(0, xRCorner);
                                var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                                for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                                    var xCCorner = yC * strideWidth - padLeft;
                                    var xCMin = Math.max(0, xCCorner);
                                    var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                                    var minMaxValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
                                    var avgValue = 0;
                                    var count = 0;
                                    for (var xR = xRMin; xR < xRMax; ++xR) {
                                        for (var xC = xCMin; xC < xCMax; ++xC) {
                                            var pixel = x.get(b, xR, xC, d);
                                            if (poolType === "max" && pixel > minMaxValue) {
                                                minMaxValue = pixel
                                            } else if (poolType === "avg") {
                                                avgValue += pixel;
                                                count++
                                            }
                                        }
                                        if (isNaN(minMaxValue)) {
                                            break
                                        }
                                    }
                                    y.set(poolType === "avg" ? avgValue / count : minMaxValue, b, yR, yC, d)
                                }
                            }
                        }
                    }
                    return y.toTensor()
                };
                MathBackendCPU.prototype.maxPool = function (x, convInfo) {
                    return this.pool(x, convInfo, "max")
                };
                MathBackendCPU.prototype.maxPoolPositions = function (x, convInfo) {
                    var maxPositions = ops.buffer(convInfo.outShape, "int32");
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d = 0; d < convInfo.inChannels; ++d) {
                            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                                var xRCorner = yR * strideHeight - padTop;
                                var xRMin = Math.max(0, xRCorner);
                                var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                                for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                                    var xCCorner = yC * strideWidth - padLeft;
                                    var xCMin = Math.max(0, xCCorner);
                                    var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                                    var maxValue = Number.NEGATIVE_INFINITY;
                                    var maxPosition = -1;
                                    for (var xR = xRMin; xR < xRMax; ++xR) {
                                        var wR = xR - xRCorner;
                                        for (var xC = xCMin; xC < xCMax; ++xC) {
                                            var wC = xC - xCCorner;
                                            var pixel = x.get(b, xR, xC, d);
                                            if (pixel > maxValue) {
                                                maxValue = pixel;
                                                maxPosition = wR * filterWidth + wC
                                            }
                                        }
                                    }
                                    maxPositions.set(maxPosition, b, yR, yC, d)
                                }
                            }
                        }
                    }
                    return maxPositions.toTensor()
                };
                MathBackendCPU.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
                    var maxPositions = this.maxPoolPositions(x, convInfo);
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var padLeft = filterWidth - 1 - convInfo.padInfo.left;
                    var padTop = filterHeight - 1 - convInfo.padInfo.top;
                    var dx = ops.buffer(x.shape, "float32");
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d = 0; d < convInfo.inChannels; ++d) {
                            for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                                for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                                    var dyRCorner = dxR - padTop;
                                    var dyCCorner = dxC - padLeft;
                                    var dotProd = 0;
                                    for (var wR = 0; wR < filterHeight; ++wR) {
                                        var dyR = (dyRCorner + wR) / strideHeight;
                                        if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
                                            continue
                                        }
                                        for (var wC = 0; wC < filterWidth; ++wC) {
                                            var dyC = (dyCCorner + wC) / strideWidth;
                                            if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                                                continue
                                            }
                                            var maxPos = filterHeight * filterWidth - 1 - maxPositions.get(b, dyR, dyC, d);
                                            var curPos = wR * filterWidth + wC;
                                            var mask = maxPos === curPos ? 1 : 0;
                                            if (mask === 0) {
                                                continue
                                            }
                                            var pixel = dy.get(b, dyR, dyC, d);
                                            dotProd += pixel * mask
                                        }
                                    }
                                    dx.set(dotProd, b, dxR, dxC, d)
                                }
                            }
                        }
                    }
                    return dx.toTensor()
                };
                MathBackendCPU.prototype.avgPoolBackprop = function (dy, x, convInfo) {
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var padLeft = filterWidth - 1 - convInfo.padInfo.left;
                    var padTop = filterHeight - 1 - convInfo.padInfo.top;
                    var dx = ops.buffer(x.shape, "float32");
                    var avgMultiplier = 1 / (filterHeight * filterWidth);
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d = 0; d < convInfo.inChannels; ++d) {
                            for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                                for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                                    var dyRCorner = dxR - padTop;
                                    var dyCCorner = dxC - padLeft;
                                    var dotProd = 0;
                                    for (var wR = 0; wR < filterHeight; ++wR) {
                                        var dyR = (dyRCorner + wR) / strideHeight;
                                        if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
                                            continue
                                        }
                                        for (var wC = 0; wC < filterWidth; ++wC) {
                                            var dyC = (dyCCorner + wC) / strideWidth;
                                            if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                                                continue
                                            }
                                            var pixel = dy.get(b, dyR, dyC, d);
                                            dotProd += pixel
                                        }
                                    }
                                    dx.set(dotProd * avgMultiplier, b, dxR, dxC, d)
                                }
                            }
                        }
                    }
                    return dx.toTensor()
                };
                MathBackendCPU.prototype.cast = function (x, dtype) {
                    return backend_util.castTensor(x, dtype, this)
                };
                MathBackendCPU.prototype.reshape = function (x, shape) {
                    return backend_util.reshapeTensor(x, shape)
                };
                MathBackendCPU.prototype.avgPool = function (x, convInfo) {
                    return this.pool(x, convInfo, "avg").toFloat()
                };
                MathBackendCPU.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
                    var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
                    var output = ops.buffer([batch, newHeight, newWidth, numChannels], x.dtype);
                    var effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];
                    var effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];
                    for (var b = 0; b < batch; b++) {
                        for (var r = 0; r < newHeight; r++) {
                            for (var c = 0; c < newWidth; c++) {
                                for (var d = 0; d < numChannels; d++) {
                                    var sourceFracRow = effectiveInputSize[0] * r / effectiveOutputSize[0];
                                    var sourceFracCol = effectiveInputSize[1] * c / effectiveOutputSize[1];
                                    var sourceRowFloor = Math.floor(sourceFracRow);
                                    var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
                                    var sourceColFloor = Math.floor(sourceFracCol);
                                    var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
                                    var topLeft = x.get(b, sourceRowFloor, sourceColFloor, d);
                                    var bottomLeft = x.get(b, sourceRowCeil, sourceColFloor, d);
                                    var topRight = x.get(b, sourceRowFloor, sourceColCeil, d);
                                    var bottomRight = x.get(b, sourceRowCeil, sourceColCeil, d);
                                    var rowFrac = sourceFracRow - sourceRowFloor;
                                    var colFrac = sourceFracCol - sourceColFloor;
                                    var top_1 = topLeft + (topRight - topLeft) * colFrac;
                                    var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                                    var newValue = top_1 + (bottom - top_1) * rowFrac;
                                    output.set(newValue, b, r, c, d)
                                }
                            }
                        }
                    }
                    return output.toTensor()
                };
                MathBackendCPU.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
                    var _a = x.shape, batch = _a[0], xHeight = _a[1], xWidth = _a[2], depth = _a[3];
                    var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
                    var output = ops.buffer([batch, xHeight, xWidth, depth], x.dtype);
                    var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];
                    var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];
                    var heightScale = effectiveXSize[0] / effectiveYSize[0];
                    var widthScale = effectiveXSize[1] / effectiveYSize[1];
                    for (var b = 0; b < batch; b++) {
                        for (var r = 0; r < yHeight; r++) {
                            var dxR = r * heightScale;
                            var topDxRIndex = Math.floor(dxR);
                            var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
                            var dxRLerp = dxR - topDxRIndex;
                            var inverseDxRLerp = 1 - dxRLerp;
                            for (var c = 0; c < yWidth; c++) {
                                var dxC = c * widthScale;
                                var leftDxCIndex = Math.floor(dxC);
                                var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
                                var dxCLerp = dxC - leftDxCIndex;
                                var inverseDxCLerp = 1 - dxCLerp;
                                for (var d = 0; d < depth; d++) {
                                    var dyVal = dy.get(b, r, c, d);
                                    var topLeft = output.get(b, topDxRIndex, leftDxCIndex, d);
                                    topLeft += dyVal * inverseDxRLerp * inverseDxCLerp;
                                    output.set(topLeft, b, topDxRIndex, leftDxCIndex, d);
                                    var topRight = output.get(b, topDxRIndex, rightDxCIndex, d);
                                    topRight += dyVal * inverseDxRLerp * dxCLerp;
                                    output.set(topRight, b, topDxRIndex, rightDxCIndex, d);
                                    var bottomLeft = output.get(b, bottomDxRIndex, leftDxCIndex, d);
                                    bottomLeft += dyVal * dxRLerp * inverseDxCLerp;
                                    output.set(bottomLeft, b, bottomDxRIndex, leftDxCIndex, d);
                                    var bottomRight = output.get(b, bottomDxRIndex, rightDxCIndex, d);
                                    bottomRight += dyVal * dxRLerp * dxCLerp;
                                    output.set(bottomRight, b, bottomDxRIndex, rightDxCIndex, d)
                                }
                            }
                        }
                    }
                    return output.toTensor()
                };
                MathBackendCPU.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
                    var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
                    var output = ops.buffer([batch, newHeight, newWidth, numChannels], x.dtype);
                    var effectiveInputSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
                    var effectiveOutputSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
                    for (var b = 0; b < batch; b++) {
                        for (var r = 0; r < newHeight; r++) {
                            for (var c = 0; c < newWidth; c++) {
                                for (var d = 0; d < numChannels; d++) {
                                    var sourceFracRow = effectiveInputSize[0] * r / effectiveOutputSize[0];
                                    var sourceFracCol = effectiveInputSize[1] * c / effectiveOutputSize[1];
                                    var sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
                                    var sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
                                    var newValue = x.get(b, sourceNearestRow, sourceNearestCol, d);
                                    output.set(newValue, b, r, c, d)
                                }
                            }
                        }
                    }
                    return output.toTensor()
                };
                MathBackendCPU.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    var xValues = x.dataSync();
                    var meanValues = mean.dataSync();
                    var varianceValues = variance.dataSync();
                    var scaleValues = scale ? scale.dataSync() : new Float32Array([1]);
                    var offsetValues = offset ? offset.dataSync() : new Float32Array([0]);
                    var outValues = new Float32Array(xValues.length);
                    for (var i = 0; i < xValues.length; i++) {
                        outValues[i] = offsetValues[i % offsetValues.length] + (xValues[i] - meanValues[i % meanValues.length]) * scaleValues[i % scaleValues.length] / Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon)
                    }
                    return ops_1.tensor4d(outValues, x.shape)
                };
                MathBackendCPU.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
                    var output = ops.buffer(x.shape, "float32");
                    var rad = radius;
                    var maxD = output.shape[3] - 1;

                    function sumAcrossChannels(b, r, c, d) {
                        var sum = 0;
                        for (var j = Math.max(0, d - rad); j <= Math.min(d + rad, maxD); j++) {
                            var z = x.get(b, r, c, j);
                            sum += z * z
                        }
                        return sum
                    }

                    for (var b = 0; b < output.shape[0]; b++) {
                        for (var r = 0; r <= output.shape[1]; r++) {
                            for (var c = 0; c < output.shape[2]; c++) {
                                for (var d = 0; d < output.shape[3]; d++) {
                                    var sum = sumAcrossChannels(b, r, c, d);
                                    var val = x.get(b, r, c, d) * Math.pow(bias + alpha * sum, -beta);
                                    output.set(val, b, r, c, d)
                                }
                            }
                        }
                    }
                    return output.toTensor()
                };
                MathBackendCPU.prototype.multinomial = function (logits, normalized, numSamples, seed) {
                    var probabilities = normalized ? logits : ops.softmax(logits);
                    var batchSize = probabilities.shape[0];
                    var numEvents = probabilities.shape[1];
                    var res = ops.zeros([batchSize, numSamples], "int32");
                    var resVals = res.dataSync();
                    var probVals = probabilities.dataSync();
                    for (var b = 0; b < batchSize; ++b) {
                        var offset = b * numEvents;
                        var cdf = new Float32Array(numEvents - 1);
                        cdf[0] = probVals[offset];
                        for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                            cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1]
                        }
                        var random = seedrandom.alea(seed.toString());
                        var outOffset = b * numSamples;
                        for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                            var r = random();
                            resVals[outOffset + sampleId] = cdf.length;
                            for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                                if (r < cdf[event_2]) {
                                    resVals[outOffset + sampleId] = event_2;
                                    break
                                }
                            }
                        }
                    }
                    return res
                };
                MathBackendCPU.prototype.oneHot = function (indices, depth, onValue, offValue) {
                    var res = new Float32Array(indices.size * depth);
                    res.fill(offValue);
                    for (var event_3 = 0; event_3 < indices.size; ++event_3) {
                        res[event_3 * depth + indices.get(event_3)] = onValue
                    }
                    return ops.tensor2d(res, [indices.size, depth])
                };
                MathBackendCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
                    var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var result = ops.buffer(newShape, dtype);
                    var aValues = a.dataSync();
                    var bValues = b.dataSync();
                    var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
                    var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
                    var aBuf = a.buffer();
                    var bBuf = b.buffer();
                    var _loop_2 = function (i) {
                        var loc = result.indexToLoc(i);
                        var aLoc = loc.slice(-a.rank);
                        aBroadcastDims.forEach(function (d) {
                            return aLoc[d] = 0
                        });
                        var aIndex = aBuf.locToIndex(aLoc);
                        var bLoc = loc.slice(-b.rank);
                        bBroadcastDims.forEach(function (d) {
                            return bLoc[d] = 0
                        });
                        var bIndex = bBuf.locToIndex(bLoc);
                        result.values[i] = op(aValues[aIndex], bValues[bIndex])
                    };
                    for (var i = 0; i < result.values.length; ++i) {
                        _loop_2(i)
                    }
                    return result.toTensor()
                };
                MathBackendCPU.prototype.dispose = function () {
                };
                return MathBackendCPU
            }();
            exports.MathBackendCPU = MathBackendCPU;
            environment_1.ENV.registerBackend("cpu", function () {
                return new MathBackendCPU
            }, 1)
        }, {
            "../environment": 47,
            "../ops/axis_util": 102,
            "../ops/broadcast_util": 105,
            "../ops/concat_util": 108,
            "../ops/erf_util": 111,
            "../ops/ops": 122,
            "../ops/selu_util": 128,
            "../ops/slice_util": 130,
            "../tensor": 147,
            "../types": 152,
            "../util": 153,
            "./backend_util": 62,
            seedrandom: 212
        }],
        62: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var __1 = require("..");
            var array_ops_1 = require("../ops/array_ops");

            function castTensor(x, dtype, backend) {
                if (!__1.util.hasEncodingLoss(x.dtype, dtype)) {
                    return __1.Tensor.make(x.shape, {dataId: x.dataId}, dtype)
                }
                if (dtype === "int32") {
                    return backend.int(x)
                } else if (dtype === "bool") {
                    return backend.notEqual(x, array_ops_1.ArrayOps.scalar(0, x.dtype))
                } else {
                    throw new Error("Error in Cast: unknown dtype argument (" + dtype + ")")
                }
            }

            exports.castTensor = castTensor;

            function reshapeTensor(x, shape) {
                return __1.Tensor.make(shape, {dataId: x.dataId}, x.dtype)
            }

            exports.reshapeTensor = reshapeTensor
        }, {"..": 50, "../ops/array_ops": 101}],
        63: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var axis_util = require("../ops/axis_util");
            var ops = require("../ops/ops");
            var reduce_util = require("../ops/reduce_util");
            var slice_util_1 = require("../ops/slice_util");
            var tensor_1 = require("../tensor");
            var types = require("../types");
            var util = require("../util");
            var backend_util = require("./backend_util");
            var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
            var avg_pool_backprop_gpu_1 = require("./webgl/avg_pool_backprop_gpu");
            var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
            var binaryop_gpu = require("./webgl/binaryop_gpu");
            var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
            var clip_gpu_1 = require("./webgl/clip_gpu");
            var concat_gpu_1 = require("./webgl/concat_gpu");
            var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
            var conv_gpu_1 = require("./webgl/conv_gpu");
            var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
            var cumsum_gpu_1 = require("./webgl/cumsum_gpu");
            var from_pixels_gpu_1 = require("./webgl/from_pixels_gpu");
            var gather_gpu_1 = require("./webgl/gather_gpu");
            var gpgpu_context_1 = require("./webgl/gpgpu_context");
            var gpgpu_math = require("./webgl/gpgpu_math");
            var gpgpu_util = require("./webgl/gpgpu_util");
            var logical_gpu_1 = require("./webgl/logical_gpu");
            var lrn_gpu_1 = require("./webgl/lrn_gpu");
            var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
            var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
            var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
            var onehot_gpu_1 = require("./webgl/onehot_gpu");
            var pad_gpu_1 = require("./webgl/pad_gpu");
            var pool_gpu_1 = require("./webgl/pool_gpu");
            var reduce_gpu_1 = require("./webgl/reduce_gpu");
            var resize_bilinear_backprop_gpu_1 = require("./webgl/resize_bilinear_backprop_gpu");
            var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
            var resize_nearest_neighbor_gpu_1 = require("./webgl/resize_nearest_neighbor_gpu");
            var reverse_gpu_1 = require("./webgl/reverse_gpu");
            var slice_gpu_1 = require("./webgl/slice_gpu");
            var strided_slice_gpu_1 = require("./webgl/strided_slice_gpu");
            var tex_util_1 = require("./webgl/tex_util");
            var texture_manager_1 = require("./webgl/texture_manager");
            var tile_gpu_1 = require("./webgl/tile_gpu");
            var transpose_gpu_1 = require("./webgl/transpose_gpu");
            var unary_op = require("./webgl/unaryop_gpu");
            var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
            var webgl_util = require("./webgl/webgl_util");
            var MathBackendWebGL = function () {
                function MathBackendWebGL(gpgpu, delayedStorage) {
                    if (delayedStorage === void 0) {
                        delayedStorage = true
                    }
                    this.gpgpu = gpgpu;
                    this.delayedStorage = delayedStorage;
                    this.texData = new WeakMap;
                    this.uploadWaitMs = 0;
                    this.downloadWaitMs = 0;
                    this.binaryCache = {};
                    this.disposed = false;
                    if (environment_1.ENV.get("WEBGL_VERSION") < 1) {
                        throw new Error("WebGL is not supported on this device")
                    }
                    if (typeof document !== "undefined") {
                        this.canvas = document.createElement("canvas")
                    }
                    if (gpgpu == null) {
                        this.gpgpu = new gpgpu_context_1.GPGPUContext(gpgpu_util.createWebGLContext(this.canvas));
                        this.gpgpuCreatedLocally = true
                    } else {
                        this.gpgpuCreatedLocally = false
                    }
                    this.textureManager = new texture_manager_1.TextureManager(this.gpgpu)
                }

                MathBackendWebGL.prototype.register = function (dataId, shape, dtype) {
                    if (this.texData.has(dataId)) {
                        throw new Error("Data buffer is already registered")
                    }
                    this.texData.set(dataId, {
                        shape: shape,
                        dtype: dtype,
                        values: null,
                        texture: null,
                        texShape: null,
                        texType: tex_util_1.TextureType.FLOAT
                    })
                };
                MathBackendWebGL.prototype.fromPixels = function (pixels, numChannels) {
                    if (pixels == null) {
                        throw new Error("MathBackendWebGL.writePixels(): pixels can not be null")
                    }
                    var texShape = [pixels.height, pixels.width];
                    var outShape = [pixels.height, pixels.width, numChannels];
                    if (pixels instanceof HTMLVideoElement) {
                        if (this.canvas == null) {
                            throw new Error("Can't read pixels from HTMLImageElement outside " + "the browser.")
                        }
                        this.canvas.width = pixels.width;
                        this.canvas.height = pixels.height;
                        this.canvas.getContext("2d").drawImage(pixels, 0, 0, pixels.width, pixels.height);
                        pixels = this.canvas
                    }
                    var tempPixelArray = tensor_1.Tensor.make(texShape, {}, "int32");
                    this.texData.get(tempPixelArray.dataId).texType = tex_util_1.TextureType.UNSIGNED_BYTE;
                    this.gpgpu.uploadPixelDataToTexture(this.getTexture(tempPixelArray.dataId), pixels);
                    var program = new from_pixels_gpu_1.FromPixelsProgram(outShape);
                    var res = this.compileAndRun(program, [tempPixelArray]);
                    tempPixelArray.dispose();
                    return res
                };
                MathBackendWebGL.prototype.write = function (dataId, values) {
                    if (values == null) {
                        throw new Error("MathBackendWebGL.write(): values can not be null")
                    }
                    this.throwIfNoData(dataId);
                    var texData = this.texData.get(dataId);
                    var texture = texData.texture, texShape = texData.texShape, texType = texData.texType;
                    if (texture != null) {
                        this.textureManager.releaseTexture(texture, texShape, texType);
                        texData.texture = null;
                        texData.texShape = null
                    }
                    texData.values = values;
                    if (!this.delayedStorage) {
                        this.uploadToGPU(dataId)
                    }
                };
                MathBackendWebGL.prototype.readSync = function (dataId) {
                    this.throwIfNoData(dataId);
                    var texData = this.texData.get(dataId);
                    var texture = texData.texture, values = texData.values, texShape = texData.texShape;
                    if (values != null) {
                        this.cacheOnCPU(dataId);
                        return values
                    }
                    var shouldTimeProgram = this.activeTimers != null;
                    var start;
                    if (shouldTimeProgram) {
                        start = performance.now()
                    }
                    var float32Values = this.gpgpu.downloadMatrixFromTexture(texture, texShape[0], texShape[1]);
                    if (shouldTimeProgram) {
                        this.downloadWaitMs += performance.now() - start
                    }
                    this.cacheOnCPU(dataId, float32Values);
                    return texData.values
                };
                MathBackendWebGL.prototype.read = function (dataId) {
                    return __awaiter(this, void 0, void 0, function () {
                        var texData, texture, values, texShape, float32Values;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.throwIfNoData(dataId);
                                    texData = this.texData.get(dataId);
                                    texture = texData.texture, values = texData.values, texShape = texData.texShape;
                                    if (values != null) {
                                        this.cacheOnCPU(dataId);
                                        return [2, values]
                                    }
                                    if (!environment_1.ENV.get("WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED")) return [3, 2];
                                    return [4, this.gpgpu.downloadMatrixFromTextureAsync(texture, texShape[0], texShape[1])];
                                case 1:
                                    float32Values = _a.sent();
                                    this.cacheOnCPU(dataId, float32Values);
                                    return [2, texData.values];
                                case 2:
                                    if (environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 0) {
                                        return [2, this.readSync(dataId)]
                                    }
                                    return [4, this.gpgpu.runQuery(function () {
                                    })];
                                case 3:
                                    _a.sent();
                                    return [2, this.readSync(dataId)]
                            }
                        })
                    })
                };
                MathBackendWebGL.prototype.time = function (f) {
                    return __awaiter(this, void 0, void 0, function () {
                        var oldActiveTimers, newActiveTimers, outerMostTime, flattenedActiveTimers, kernelMs, res;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    oldActiveTimers = this.activeTimers;
                                    newActiveTimers = [];
                                    outerMostTime = false;
                                    if (this.programTimersStack == null) {
                                        this.programTimersStack = newActiveTimers;
                                        outerMostTime = true
                                    } else {
                                        this.activeTimers.push(newActiveTimers)
                                    }
                                    this.activeTimers = newActiveTimers;
                                    f();
                                    flattenedActiveTimers = util.flatten(this.activeTimers);
                                    this.activeTimers = oldActiveTimers;
                                    if (outerMostTime) {
                                        this.programTimersStack = null
                                    }
                                    return [4, Promise.all(flattenedActiveTimers).then(function (results) {
                                        var sum = 0;
                                        results.forEach(function (result) {
                                            return sum += result
                                        });
                                        return sum
                                    })];
                                case 1:
                                    kernelMs = _a.sent();
                                    res = {
                                        uploadWaitMs: this.uploadWaitMs,
                                        downloadWaitMs: this.downloadWaitMs,
                                        kernelMs: kernelMs,
                                        wallMs: null
                                    };
                                    this.uploadWaitMs = 0;
                                    this.downloadWaitMs = 0;
                                    return [2, res]
                            }
                        })
                    })
                };
                MathBackendWebGL.prototype.memory = function () {
                    return {unreliable: false}
                };
                MathBackendWebGL.prototype.startTimer = function () {
                    if (environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
                        return this.gpgpu.beginQuery()
                    }
                    return {startMs: performance.now(), endMs: null}
                };
                MathBackendWebGL.prototype.endTimer = function (query) {
                    if (environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
                        this.gpgpu.endQuery();
                        return query
                    }
                    query.endMs = performance.now();
                    return query
                };
                MathBackendWebGL.prototype.getQueryTime = function (query) {
                    return __awaiter(this, void 0, void 0, function () {
                        var timerQuery;
                        return __generator(this, function (_a) {
                            if (environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
                                return [2, this.gpgpu.pollQueryTime(query)]
                            }
                            timerQuery = query;
                            return [2, timerQuery.endMs - timerQuery.startMs]
                        })
                    })
                };
                MathBackendWebGL.prototype.disposeData = function (dataId) {
                    if (this.texData.has(dataId)) {
                        var _a = this.texData.get(dataId), texture = _a.texture, texShape = _a.texShape,
                            texType = _a.texType;
                        if (texture != null) {
                            this.textureManager.releaseTexture(texture, texShape, texType)
                        }
                        this.texData.delete(dataId)
                    }
                };
                MathBackendWebGL.prototype.getTexture = function (dataId) {
                    this.uploadToGPU(dataId);
                    return this.texData.get(dataId).texture
                };
                MathBackendWebGL.prototype.getTextureData = function (dataId) {
                    this.uploadToGPU(dataId);
                    return this.texData.get(dataId)
                };
                MathBackendWebGL.prototype.getGPGPUContext = function () {
                    return this.gpgpu
                };
                MathBackendWebGL.prototype.getCanvas = function () {
                    return this.canvas
                };
                MathBackendWebGL.prototype.slice = function (x, begin, size) {
                    var program = new slice_gpu_1.SliceProgram(size);
                    var customSetup = program.getCustomSetupFunc(begin);
                    return this.compileAndRun(program, [x], null, customSetup)
                };
                MathBackendWebGL.prototype.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
                    var _a = slice_util_1.getStridedSlicedInfo(x.shape, begin, end, strides, beginMask, endMask),
                        beginIndex = _a[0], size = _a[1];
                    if (size.some(function (axis) {
                        return axis === 0
                    })) {
                        return ops.tensor([], size)
                    }
                    var program = new strided_slice_gpu_1.StridedSliceProgram(beginIndex, strides, size);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.reverse = function (x, axis) {
                    var program = new reverse_gpu_1.ReverseProgram(x.shape, axis);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.concat = function (a, b) {
                    var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape);
                    return this.compileAndRun(program, [a, b])
                };
                MathBackendWebGL.prototype.neg = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.NEG);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.matMul = function (a, b, transposeA, transposeB) {
                    var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, transposeA, transposeB);
                    return this.compileAndRun(program, [a, b])
                };
                MathBackendWebGL.prototype.multiply = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    var inputs = [x, mean, variance];
                    var offsetShape = null;
                    if (offset != null) {
                        offsetShape = offset.shape;
                        inputs.push(offset)
                    }
                    var scaleShape = null;
                    if (scale != null) {
                        scaleShape = scale.shape;
                        inputs.push(scale)
                    }
                    var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
                    return this.compileAndRun(program, inputs)
                };
                MathBackendWebGL.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {
                    var program = new lrn_gpu_1.LRNProgram(x.shape, radius, bias, alpha, beta);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.tile = function (x, reps) {
                    var program = new tile_gpu_1.TileProgram(x.shape, reps);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.pad = function (x, paddings, constantValue) {
                    var program = new pad_gpu_1.PadProgram(x.shape, paddings, constantValue);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.transpose = function (x, perm) {
                    var program = new transpose_gpu_1.TransposeProgram(x.shape, perm);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.gather = function (x, indices, axis) {
                    var program = new gather_gpu_1.GatherProgram(x.shape, indices.size, axis);
                    return this.compileAndRun(program, [x, indices])
                };
                MathBackendWebGL.prototype.reduce = function (x, reduceType, dtype) {
                    var batchSize = x.shape[0];
                    var inSize = x.shape[1];
                    var windowSize = reduce_util.computeOptimalWindowSize(inSize);
                    var reduceInfo = {windowSize: windowSize, inSize: inSize, batchSize: batchSize};
                    var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
                    var _a = program.outputShape, rows = _a[0], cols = _a[1];
                    var output = this.makeOutputArray([rows, cols], dtype);
                    this.compileAndRun(program, [x], output);
                    if (output.shape[1] === 1) {
                        return output
                    }
                    return this.reduce(output, reduceType, dtype)
                };
                MathBackendWebGL.prototype.argReduce = function (x, reduceType, bestIndicesA) {
                    if (bestIndicesA === void 0) {
                        bestIndicesA = null
                    }
                    var batchSize = x.shape[0];
                    var inSize = x.shape[1];
                    if (bestIndicesA != null) {
                        batchSize = bestIndicesA.shape[0];
                        inSize = bestIndicesA.shape[1]
                    }
                    var windowSize = reduce_util.computeOptimalWindowSize(inSize);
                    var reduceInfo = {windowSize: windowSize, inSize: inSize, batchSize: batchSize};
                    var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
                    var _a = program.outputShape, rows = _a[0], cols = _a[1];
                    var output = this.makeOutputArray([rows, cols], "int32");
                    var inputs = [x];
                    if (bestIndicesA != null) {
                        inputs.push(bestIndicesA)
                    }
                    this.compileAndRun(program, inputs, output);
                    if (output.shape[1] === 1) {
                        return output
                    }
                    return this.argReduce(x, reduceType, output)
                };
                MathBackendWebGL.prototype.sum = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims("sum", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    var outputDType = types.sumOutType(x.dtype);
                    return this.reduce(a2D, "sum", outputDType).reshape(outShape)
                };
                MathBackendWebGL.prototype.argMin = function (x, axis) {
                    var axes = [axis];
                    axis_util.assertAxesAreInnerMostDims("argMin", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    return this.argReduce(a2D, "min").reshape(outShape)
                };
                MathBackendWebGL.prototype.argMax = function (x, axis) {
                    var axes = [axis];
                    axis_util.assertAxesAreInnerMostDims("argMax", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    return this.argReduce(a2D, "max").reshape(outShape)
                };
                MathBackendWebGL.prototype.cumsum = function (x, axis, exclusive, reverse) {
                    if (axis !== x.rank - 1) {
                        throw new Error("WebGL cumsum shader expects an inner-most axis=" + (x.rank - 1) + " " + ("but got axis=" + axis))
                    }
                    var program = new cumsum_gpu_1.CumSumProgram(x.shape, exclusive, reverse);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.equal = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, "bool");
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.notEqual = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, "bool");
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.less = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, "bool");
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.lessEqual = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, "bool");
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.greater = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, "bool");
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.greaterEqual = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, "bool");
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.logicalNot = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.logicalAnd = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, "bool");
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.logicalOr = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, "bool");
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.where = function (condition, a, b, dtype) {
                    var program = new logical_gpu_1.WhereProgram(condition.rank, a.shape, a.rank);
                    var output = this.makeOutputArray(program.outputShape, dtype);
                    return this.compileAndRun(program, [condition, a, b], output)
                };
                MathBackendWebGL.prototype.topKValues = function (x, k) {
                    throw new Error("topKValues GPU not yet implemented!")
                };
                MathBackendWebGL.prototype.topKIndices = function (x, k) {
                    throw new Error("topKIndices GPU not yet implemented!")
                };
                MathBackendWebGL.prototype.min = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims("min", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    return this.reduce(a2D, "min", a2D.dtype).reshape(outShape)
                };
                MathBackendWebGL.prototype.minimum = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b])
                };
                MathBackendWebGL.prototype.mod = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MOD, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b])
                };
                MathBackendWebGL.prototype.max = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims("max", axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    return this.reduce(a2D, "max", a2D.dtype).reshape(outShape)
                };
                MathBackendWebGL.prototype.maximum = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b])
                };
                MathBackendWebGL.prototype.squaredDifference = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SQUARED_DIFFERENCE, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b])
                };
                MathBackendWebGL.prototype.divide = function (a, b) {
                    var op;
                    var outputDtype;
                    if (a.dtype === "int32" && b.dtype === "int32") {
                        op = binaryop_gpu.INT_DIV;
                        outputDtype = "int32"
                    } else {
                        op = binaryop_gpu.DIV;
                        outputDtype = "float32"
                    }
                    var program = new binaryop_gpu_1.BinaryOpProgram(op, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, outputDtype);
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.add = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.subtract = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.pow = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
                    return this.compileAndRun(program, [a, b], output)
                };
                MathBackendWebGL.prototype.ceil = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.CEIL);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.floor = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.FLOOR);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.sign = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGN);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.round = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ROUND);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.exp = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXP);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.expm1 = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXPM1);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.log = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.log1p = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG1P);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.sqrt = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQRT);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.rsqrt = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RSQRT);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.square = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.reciprocal = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RECIPROCAL);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.relu = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RELU);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.elu = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.eluDer = function (dy, y) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ELU_DER, dy.shape, y.shape);
                    return this.compileAndRun(program, [dy, y])
                };
                MathBackendWebGL.prototype.selu = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SELU);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.int = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TO_INT);
                    var output = this.makeOutputArray(program.outputShape, "int32");
                    return this.compileAndRun(program, [x], output)
                };
                MathBackendWebGL.prototype.clip = function (x, min, max) {
                    var program = new clip_gpu_1.ClipProgram(x.shape, min, max);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.abs = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ABS);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.sigmoid = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGMOID);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.softplus = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SOFTPLUS);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.sin = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIN);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.cos = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COS);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.tan = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TAN);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.asin = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASIN);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.acos = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOS);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.atan = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATAN);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.atan2 = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ATAN2, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b])
                };
                MathBackendWebGL.prototype.sinh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SINH);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.cosh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COSH);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.tanh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TANH);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.asinh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASINH);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.acosh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOSH);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.atanh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATANH);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.erf = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ERF);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.step = function (x, alpha) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.STEP(alpha));
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.conv2d = function (x, filter, convInfo) {
                    var program = new conv_gpu_1.Conv2DProgram(convInfo);
                    return this.compileAndRun(program, [x, filter])
                };
                MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {
                    var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
                    return this.compileAndRun(program, [dy, filter])
                };
                MathBackendWebGL.prototype.conv2dDerFilter = function (x, dy, convInfo) {
                    var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);
                    return this.compileAndRun(program, [x, dy])
                };
                MathBackendWebGL.prototype.depthwiseConv2D = function (x, filter, convInfo) {
                    var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
                    return this.compileAndRun(program, [x, filter])
                };
                MathBackendWebGL.prototype.maxPool = function (x, convInfo) {
                    var program = new pool_gpu_1.Pool2DProgram(convInfo, "max", false);
                    var output = this.makeOutputArray(program.outputShape, x.dtype);
                    return this.compileAndRun(program, [x], output)
                };
                MathBackendWebGL.prototype.avgPool = function (x, convInfo) {
                    var program = new pool_gpu_1.Pool2DProgram(convInfo, "avg", false);
                    var output = this.makeOutputArray(program.outputShape, "float32");
                    return this.compileAndRun(program, [x], output)
                };
                MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {
                    var getPositions = true;
                    var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, "max", getPositions);
                    var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
                    var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
                    var output = this.makeOutputArray(maxPoolBackPropProgram.outputShape, x.dtype);
                    var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions], output);
                    maxPoolPositions.dispose();
                    return result
                };
                MathBackendWebGL.prototype.avgPoolBackprop = function (dy, x, convInfo) {
                    var avgPoolBackpropProgram = new avg_pool_backprop_gpu_1.AvgPool2DBackpropProgram(convInfo);
                    var output = this.makeOutputArray(avgPoolBackpropProgram.outputShape, x.dtype);
                    return this.compileAndRun(avgPoolBackpropProgram, [dy], output)
                };
                MathBackendWebGL.prototype.cast = function (x, dtype) {
                    return backend_util.castTensor(x, dtype, this)
                };
                MathBackendWebGL.prototype.reshape = function (x, shape) {
                    return backend_util.reshapeTensor(x, shape)
                };
                MathBackendWebGL.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
                    var program = new resize_bilinear_gpu_1.ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {
                    var program = new resize_bilinear_backprop_gpu_1.ResizeBilinearBackpropProgram(dy, x, alignCorners);
                    return this.compileAndRun(program, [dy])
                };
                MathBackendWebGL.prototype.resizeNearestNeighbor = function (x, newHeight, newWidth, alignCorners) {
                    var program = new resize_nearest_neighbor_gpu_1.ResizeNearestNeighborProgram(x.shape, newHeight, newWidth, alignCorners);
                    return this.compileAndRun(program, [x])
                };
                MathBackendWebGL.prototype.multinomial = function (logits, normalized, numSamples, seed) {
                    var probs = normalized ? logits : ops.softmax(logits);
                    var batchSize = probs.shape[0];
                    var numOutcomes = probs.shape[1];
                    var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
                    var output = this.makeOutputArray(program.outputShape, "int32");
                    var customSetup = program.getCustomSetupFunc(seed);
                    return this.compileAndRun(program, [probs], output, customSetup)
                };
                MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {
                    var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
                    return this.compileAndRun(program, [indices])
                };
                MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {
                    return tensor_1.Tensor.make(shape, {}, dtype)
                };
                MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup) {
                    var _this = this;
                    if (output == null) {
                        output = this.makeOutputArray(program.outputShape, inputs[0].dtype)
                    }
                    var inputsData = inputs.map(function (input) {
                        _this.uploadToGPU(input.dataId);
                        return {tensor: input, texData: _this.texData.get(input.dataId)}
                    });
                    this.uploadToGPU(output.dataId);
                    var outputData = {tensor: output, texData: this.texData.get(output.dataId)};
                    var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);
                    var binary = this.getAndSaveBinary(key, function () {
                        return gpgpu_math.compileProgram(_this.gpgpu, program, inputsData, outputData)
                    });
                    var shouldTimeProgram = this.activeTimers != null;
                    var query;
                    if (shouldTimeProgram) {
                        query = this.startTimer()
                    }
                    gpgpu_math.runProgram(binary, inputsData, outputData, customSetup);
                    if (shouldTimeProgram) {
                        query = this.endTimer(query);
                        this.activeTimers.push(this.getQueryTime(query))
                    }
                    return output
                };
                MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {
                    if (!(key in this.binaryCache)) {
                        this.binaryCache[key] = getBinary()
                    }
                    return this.binaryCache[key]
                };
                MathBackendWebGL.prototype.getTextureManager = function () {
                    return this.textureManager
                };
                MathBackendWebGL.prototype.dispose = function () {
                    if (this.disposed) {
                        return
                    }
                    for (var key in this.binaryCache) {
                        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram)
                    }
                    this.textureManager.dispose();
                    this.canvas.remove();
                    if (this.gpgpuCreatedLocally) {
                        this.gpgpu.dispose()
                    }
                    this.disposed = true
                };
                MathBackendWebGL.prototype.throwIfNoData = function (dataId) {
                    if (!this.texData.has(dataId)) {
                        throw new Error("WebGL backend: No data found for this tensor. " + "Did you change your backend in the middle of the program? " + "New backends can't use Tensors created with previous backends")
                    }
                };
                MathBackendWebGL.prototype.uploadToGPU = function (dataId) {
                    this.throwIfNoData(dataId);
                    var texData = this.texData.get(dataId);
                    var shape = texData.shape, values = texData.values, texture = texData.texture,
                        dtype = texData.dtype, texType = texData.texType;
                    if (texture != null) {
                        return
                    }
                    var shouldTimeProgram = this.activeTimers != null;
                    var start;
                    if (shouldTimeProgram) {
                        start = performance.now()
                    }
                    var texShape = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
                    texData.texShape = texShape;
                    var newTexture = this.textureManager.acquireTexture(texShape, texType);
                    texData.texture = newTexture;
                    if (values != null) {
                        this.gpgpu.uploadMatrixToTexture(newTexture, texShape[0], texShape[1], typedArrayToFloat32(values, dtype));
                        texData.values = null;
                        if (shouldTimeProgram) {
                            this.uploadWaitMs += performance.now() - start
                        }
                    }
                };
                MathBackendWebGL.prototype.cacheOnCPU = function (dataId, float32Values) {
                    var dontKeepCopyOnGPU = this.delayedStorage;
                    var texData = this.texData.get(dataId);
                    var texture = texData.texture, texShape = texData.texShape, dtype = texData.dtype,
                        texType = texData.texType;
                    if (dontKeepCopyOnGPU && texture != null) {
                        this.textureManager.releaseTexture(texture, texShape, texType);
                        texData.texture = null;
                        texData.texShape = null
                    }
                    if (float32Values != null) {
                        texData.values = float32ToTypedArray(float32Values, dtype)
                    }
                };
                return MathBackendWebGL
            }();
            exports.MathBackendWebGL = MathBackendWebGL;
            environment_1.ENV.registerBackend("webgl", function () {
                return new MathBackendWebGL
            }, 2);

            function float32ToTypedArray(a, dtype) {
                if (dtype === "float32") {
                    return a
                } else if (dtype === "int32" || dtype === "bool") {
                    var result = dtype === "int32" ? new Int32Array(a.length) : new Uint8Array(a.length);
                    for (var i = 0; i < result.length; ++i) {
                        result[i] = Math.round(a[i])
                    }
                    return result
                } else {
                    throw new Error("Unknown dtype " + dtype)
                }
            }

            function typedArrayToFloat32(a, dtype) {
                return a instanceof Float32Array ? a : new Float32Array(a)
            }
        }, {
            "../environment": 47,
            "../ops/axis_util": 102,
            "../ops/ops": 122,
            "../ops/reduce_util": 125,
            "../ops/slice_util": 130,
            "../tensor": 147,
            "../types": 152,
            "../util": 153,
            "./backend_util": 62,
            "./webgl/argminmax_gpu": 64,
            "./webgl/avg_pool_backprop_gpu": 65,
            "./webgl/batchnorm_gpu": 66,
            "./webgl/binaryop_gpu": 67,
            "./webgl/clip_gpu": 68,
            "./webgl/concat_gpu": 69,
            "./webgl/conv_backprop_gpu": 70,
            "./webgl/conv_gpu": 71,
            "./webgl/conv_gpu_depthwise": 72,
            "./webgl/cumsum_gpu": 73,
            "./webgl/from_pixels_gpu": 74,
            "./webgl/gather_gpu": 75,
            "./webgl/gpgpu_context": 76,
            "./webgl/gpgpu_math": 77,
            "./webgl/gpgpu_util": 78,
            "./webgl/logical_gpu": 79,
            "./webgl/lrn_gpu": 80,
            "./webgl/max_pool_backprop_gpu": 81,
            "./webgl/mulmat_gpu": 82,
            "./webgl/multinomial_gpu": 83,
            "./webgl/onehot_gpu": 84,
            "./webgl/pad_gpu": 85,
            "./webgl/pool_gpu": 86,
            "./webgl/reduce_gpu": 87,
            "./webgl/resize_bilinear_backprop_gpu": 88,
            "./webgl/resize_bilinear_gpu": 89,
            "./webgl/resize_nearest_neighbor_gpu": 90,
            "./webgl/reverse_gpu": 91,
            "./webgl/slice_gpu": 93,
            "./webgl/strided_slice_gpu": 94,
            "./webgl/tex_util": 95,
            "./webgl/texture_manager": 96,
            "./webgl/tile_gpu": 97,
            "./webgl/transpose_gpu": 98,
            "./webgl/unaryop_gpu": 99,
            "./webgl/webgl_util": 100
        }],
        64: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ArgMinMaxProgram = function () {
                function ArgMinMaxProgram(reduceInfo, op, firstPass) {
                    this.variableNames = ["A"];
                    var windowSize = reduceInfo.windowSize;
                    var batchSize = reduceInfo.batchSize;
                    var inSize = reduceInfo.inSize;
                    var outSize = Math.ceil(inSize / windowSize);
                    if (!firstPass) {
                        this.variableNames.push("bestIndicesA")
                    }
                    this.outputShape = [batchSize, outSize];
                    var compOp = op === "max" ? ">" : "<";
                    var indexSnippet = firstPass ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
                    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "
                }

                return ArgMinMaxProgram
            }();
            exports.ArgMinMaxProgram = ArgMinMaxProgram
        }, {}],
        65: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var AvgPool2DBackpropProgram = function () {
                function AvgPool2DBackpropProgram(convInfo) {
                    this.variableNames = ["dy"];
                    this.outputShape = convInfo.inShape;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = filterHeight - 1 - convInfo.padInfo.top;
                    var padLeft = filterWidth - 1 - convInfo.padInfo.left;
                    var avgMultiplier = 1 / (filterHeight * filterWidth);
                    this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float avgMultiplier = float(" + avgMultiplier + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
                }

                return AvgPool2DBackpropProgram
            }();
            exports.AvgPool2DBackpropProgram = AvgPool2DBackpropProgram
        }, {}],
        66: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var broadcast_util = require("../../ops/broadcast_util");
            var BatchNormProgram = function () {
                function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
                    this.outputShape = [];
                    this.supportsBroadcasting = true;
                    this.variableNames = ["x", "mean", "variance"];
                    broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
                    broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
                    var offsetSnippet = "0.0";
                    if (offsetShape != null) {
                        broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
                        this.variableNames.push("offset");
                        offsetSnippet = "getOffsetAtOutCoords()"
                    }
                    var scaleSnippet = "1.0";
                    if (scaleShape != null) {
                        broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
                        this.variableNames.push("scale");
                        scaleSnippet = "getScaleAtOutCoords()"
                    }
                    this.outputShape = xShape;
                    this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale * inversesqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    "
                }

                return BatchNormProgram
            }();
            exports.BatchNormProgram = BatchNormProgram
        }, {"../../ops/broadcast_util": 105}],
        67: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var broadcast_util = require("../../ops/broadcast_util");
            var CHECK_NAN_SNIPPET = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n";
            exports.ADD = "return a + b;";
            exports.SUB = "return a - b;";
            exports.MUL = "return a * b;";
            exports.DIV = "return a / b;";
            exports.INT_DIV = "\n  float resultSign = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  int result = ia / ib;\n  int amodb = ia - ib * result;\n\n  if (resultSign < 0.0 && amodb != 0) {\n    result -= 1;\n  }\n  return float(result);\n";
            exports.POW = "\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
            exports.SQUARED_DIFFERENCE = "return (a - b) * (a - b);";
            exports.EQUAL = "return float(a == b);";
            exports.NOT_EQUAL = "return float(a != b);";
            exports.LESS = "return float(a < b);";
            exports.LESS_EQUAL = "return float(a <= b);";
            exports.GREATER = "return float(a > b);";
            exports.GREATER_EQUAL = "return float(a >= b);";
            exports.LOGICAL_AND = "return float(a >= 1.0 && b >= 1.0);";
            exports.LOGICAL_OR = "return float(a >= 1.0 || b >= 1.0);";
            exports.MAX = CHECK_NAN_SNIPPET + "\n  return max(a, b);\n";
            exports.MIN = CHECK_NAN_SNIPPET + "\n  return min(a, b);\n";
            exports.MOD = "return mod(a, b);";
            exports.ATAN2 = CHECK_NAN_SNIPPET + "\n  return atan(a, b);\n";
            exports.ELU_DER = "return (b >= 1.0) ? a : a * (b + 1.0);";
            var BinaryOpProgram = function () {
                function BinaryOpProgram(op, aShape, bShape) {
                    this.variableNames = ["A", "B"];
                    this.supportsBroadcasting = true;
                    this.outputShape = broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
                    this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "
                }

                return BinaryOpProgram
            }();
            exports.BinaryOpProgram = BinaryOpProgram
        }, {"../../ops/broadcast_util": 105}],
        68: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ClipProgram = function () {
                function ClipProgram(aShape, min, max) {
                    this.variableNames = ["A"];
                    this.outputShape = aShape;
                    var minFixed = min.toFixed(20);
                    var maxFixed = max.toFixed(20);
                    this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    "
                }

                return ClipProgram
            }();
            exports.ClipProgram = ClipProgram
        }, {}],
        69: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var concat_util = require("../../ops/concat_util");
            var ConcatProgram = function () {
                function ConcatProgram(aShape, bShape) {
                    this.variableNames = ["A", "B"];
                    this.outputShape = [];
                    this.outputShape = concat_util.computeOutShape(aShape, bShape, 1);
                    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < " + aShape[1] + ") {\n          value = getA(yR, yC);\n        } else {\n          yC -= " + aShape[1] + ";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    "
                }

                return ConcatProgram
            }();
            exports.ConcatProgram = ConcatProgram
        }, {"../../ops/concat_util": 108}],
        70: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Conv2DDerFilterProgram = function () {
                function Conv2DDerFilterProgram(convInfo) {
                    this.variableNames = ["x", "dy"];
                    this.outputShape = convInfo.filterShape;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
                }

                return Conv2DDerFilterProgram
            }();
            exports.Conv2DDerFilterProgram = Conv2DDerFilterProgram;
            var Conv2DDerInputProgram = function () {
                function Conv2DDerInputProgram(convInfo) {
                    this.variableNames = ["dy", "W"];
                    this.outputShape = convInfo.inShape;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = filterHeight - 1 - convInfo.padInfo.top;
                    var padLeft = filterWidth - 1 - convInfo.padInfo.left;
                    this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + convInfo.outChannels + "; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
                }

                return Conv2DDerInputProgram
            }();
            exports.Conv2DDerInputProgram = Conv2DDerInputProgram
        }, {}],
        71: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Conv2DProgram = function () {
                function Conv2DProgram(convInfo) {
                    this.variableNames = ["x", "W"];
                    this.outputShape = convInfo.outShape;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var dilationHeight = convInfo.dilationHeight;
                    var dilationWidth = convInfo.dilationWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
                    var inputDepthVec4Remainder = convInfo.inChannels % 4;
                    this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR * " + dilationHeight + ";\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC * " + dilationWidth + ";\n\n            if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
                }

                return Conv2DProgram
            }();
            exports.Conv2DProgram = Conv2DProgram
        }, {}],
        72: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var DepthwiseConv2DProgram = function () {
                function DepthwiseConv2DProgram(convInfo) {
                    this.variableNames = ["x", "W"];
                    this.outputShape = convInfo.outShape;
                    var xNumRows = convInfo.inHeight;
                    var xNumCols = convInfo.inWidth;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var dilationHeight = convInfo.dilationHeight;
                    var dilationWidth = convInfo.dilationWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var channelMul = convInfo.outChannels / convInfo.inChannels;
                    this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR * " + dilationHeight + ";\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC * " + dilationWidth + ";\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
                }

                return DepthwiseConv2DProgram
            }();
            exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram
        }, {}],
        73: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var CumSumProgram = function () {
                function CumSumProgram(shape, exclusive, reverse) {
                    this.variableNames = ["x"];
                    this.outputShape = shape;
                    var rank = shape.length;
                    var finalDim = shape[shape.length - 1];
                    var comparator = reverse ? "<" : ">";
                    this.userCode = "\n      int getIndex(int i) {\n        " + (reverse ? "return " + finalDim + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + shader_compiler_1.getCoordsDataType(rank) + " coords = getOutputCoords();\n        int end = " + getFinalCoord(rank, "coords") + ";\n        float val = 0.0;\n        for (int i = " + finalDim + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + comparator + " end) {\n            continue;\n          }\n          if (idx == end && " + exclusive + ") {\n            continue;\n          }\n          " + getFinalCoord(rank, "coords") + " = idx;\n          val += getX(" + getCoords(rank, "coords") + ");\n        }\n        setOutput(val);\n      }\n    "
                }

                return CumSumProgram
            }();
            exports.CumSumProgram = CumSumProgram;

            function getCoords(rank, name) {
                if (rank === 1) {
                    return "" + name
                } else if (rank === 2) {
                    return name + ".x, " + name + ".y"
                } else if (rank === 3) {
                    return name + ".x, " + name + ".y, " + name + ".z"
                } else if (rank === 4) {
                    return name + ".x, " + name + ".y, " + name + ".z, " + name + ".w"
                } else {
                    throw Error("Cumulative sum for rank " + rank + " is not yet supported")
                }
            }

            function getFinalCoord(rank, name) {
                if (rank === 1) {
                    return "" + name
                } else if (rank === 2) {
                    return name + ".y"
                } else if (rank === 3) {
                    return name + ".z"
                } else if (rank === 4) {
                    return name + ".w"
                } else {
                    throw Error("Cumulative sum for rank " + rank + " is not yet supported")
                }
            }
        }, {"./shader_compiler": 92}],
        74: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var FromPixelsProgram = function () {
                function FromPixelsProgram(outputShape) {
                    this.variableNames = ["A"];
                    var height = outputShape[0], width = outputShape[1];
                    this.outputShape = outputShape;
                    this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + width + ".0, " + height + ".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "
                }

                return FromPixelsProgram
            }();
            exports.FromPixelsProgram = FromPixelsProgram
        }, {}],
        75: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var GatherProgram = function () {
                function GatherProgram(aShape, indicesLength, axis) {
                    this.variableNames = ["A", "indices"];
                    var outputShape = aShape.slice();
                    outputShape[axis] = indicesLength;
                    this.outputShape = outputShape;
                    this.rank = outputShape.length;
                    var dtype = shader_compiler_1.getCoordsDataType(this.rank);
                    var sourceCoords = getSourceCoords(aShape, axis);
                    this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    "
                }

                return GatherProgram
            }();
            exports.GatherProgram = GatherProgram;

            function getSourceCoords(aShape, axis) {
                var rank = aShape.length;
                if (rank > 4) {
                    throw Error("Gather for rank " + rank + " is not yet supported")
                }
                if (rank === 1) {
                    return "int(getIndices(resRC))"
                }
                var currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
                var sourceCoords = [];
                for (var i = 0; i < aShape.length; i++) {
                    if (i === axis) {
                        sourceCoords.push("int(getIndices(" + currentCoords[i] + "))")
                    } else {
                        sourceCoords.push("" + currentCoords[i])
                    }
                }
                return sourceCoords.join()
            }
        }, {"./shader_compiler": 92}],
        76: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var util = require("../../util");
            var gpgpu_util = require("./gpgpu_util");
            var tex_util = require("./tex_util");
            var webgl_util = require("./webgl_util");
            var GPGPUContext = function () {
                function GPGPUContext(gl) {
                    this.outputTexture = null;
                    this.program = null;
                    this.disposed = false;
                    this.autoDebugValidate = false;
                    this.vertexAttrsAreBound = false;
                    if (gl != null) {
                        this.gl = gl
                    } else {
                        this.gl = gpgpu_util.createWebGLContext()
                    }
                    if (environment_1.ENV.get("WEBGL_VERSION") === 1) {
                        this.textureFloatExtension = webgl_util.getExtensionOrThrow(this.gl, "OES_texture_float");
                        this.colorBufferFloatExtension = this.gl.getExtension("WEBGL_color_buffer_float")
                    } else {
                        this.colorBufferFloatExtension = webgl_util.getExtensionOrThrow(this.gl, "EXT_color_buffer_float")
                    }
                    this.loseContextExtension = webgl_util.getExtensionOrThrow(this.gl, "WEBGL_lose_context");
                    if (environment_1.ENV.get("WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED")) {
                        this.getBufferSubDataAsyncExtension = this.gl.getExtension("WEBGL_get_buffer_sub_data_async")
                    }
                    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
                    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
                    this.framebuffer = webgl_util.createFramebuffer(this.gl)
                }

                GPGPUContext.prototype.dispose = function () {
                    var _this = this;
                    if (this.disposed) {
                        return
                    }
                    if (this.program != null) {
                        console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram." + " This is probably a resource leak, delete the program with " + "GPGPUContext.deleteProgram before disposing.")
                    }
                    if (this.outputTexture != null) {
                        console.warn("Disposing a GPGPUContext that still has a bound output matrix " + "texture.  This is probably a resource leak, delete the output " + "matrix texture with GPGPUContext.deleteMatrixTexture before " + "disposing.")
                    }
                    var gl = this.gl;
                    webgl_util.callAndCheck(gl, function () {
                        return gl.finish()
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.bindFramebuffer(gl.FRAMEBUFFER, null)
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.deleteFramebuffer(_this.framebuffer)
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.bindBuffer(gl.ARRAY_BUFFER, null)
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.deleteBuffer(_this.vertexBuffer)
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.deleteBuffer(_this.indexBuffer)
                    });
                    this.loseContextExtension.loseContext();
                    this.disposed = true
                };
                GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
                    this.autoDebugValidate = enabled;
                    webgl_util.enableDebugWebGLErrorChecking(enabled)
                };
                GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
                    this.throwIfDisposed();
                    return gpgpu_util.createMatrixTexture(this.gl, rows, columns)
                };
                GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
                    this.throwIfDisposed();
                    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels)
                };
                GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
                    this.throwIfDisposed();
                    return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns)
                };
                GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
                    var _this = this;
                    this.throwIfDisposed();
                    if (this.outputTexture === texture) {
                        webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
                        this.outputTexture = null
                    }
                    webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.deleteTexture(texture)
                    })
                };
                GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
                    this.throwIfDisposed();
                    var numChannels = 1;
                    return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels)
                };
                GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
                    this.throwIfDisposed();
                    return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix)
                };
                GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
                    var _this = this;
                    return this.downloadMatrixDriver(texture, function () {
                        return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns)
                    })
                };
                GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.getBufferSubDataAsyncExtension == null) {
                                throw new Error("Cannot download matrix from output texture asynchronously, " + "WEBGL_get_buffer_sub_data_async is not enabled.")
                            }
                            return [2, this.downloadMatrixDriverAsync(texture, function () {
                                return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns)
                            })]
                        })
                    })
                };
                GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
                    var _this = this;
                    return this.downloadMatrixDriver(texture, function () {
                        return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels)
                    })
                };
                GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
                    var _this = this;
                    return this.downloadMatrixDriver(texture, function () {
                        return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns)
                    })
                };
                GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
                    this.throwIfDisposed();
                    var gl = this.gl;
                    var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
                    var vertexShader = gpgpu_util.createVertexShader(gl);
                    var program = webgl_util.createProgram(gl);
                    webgl_util.callAndCheck(gl, function () {
                        return gl.attachShader(program, vertexShader)
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.attachShader(program, fragmentShader)
                    });
                    webgl_util.linkProgram(gl, program);
                    if (this.autoDebugValidate) {
                        webgl_util.validateProgram(gl, program)
                    }
                    if (!this.vertexAttrsAreBound) {
                        this.setProgram(program);
                        this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer)
                    }
                    return program
                };
                GPGPUContext.prototype.deleteProgram = function (program) {
                    var _this = this;
                    this.throwIfDisposed();
                    if (program === this.program) {
                        this.program = null
                    }
                    if (program != null) {
                        webgl_util.callAndCheck(this.gl, function () {
                            return _this.gl.deleteProgram(program)
                        })
                    }
                };
                GPGPUContext.prototype.setProgram = function (program) {
                    var _this = this;
                    this.throwIfDisposed();
                    this.program = program;
                    if (this.program != null && this.autoDebugValidate) {
                        webgl_util.validateProgram(this.gl, this.program)
                    }
                    webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.useProgram(program)
                    })
                };
                GPGPUContext.prototype.getUniformLocation = function (program, uniformName, shouldThrow) {
                    if (shouldThrow === void 0) {
                        shouldThrow = true
                    }
                    this.throwIfDisposed();
                    if (shouldThrow) {
                        return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName)
                    } else {
                        return webgl_util.getProgramUniformLocation(this.gl, program, uniformName)
                    }
                };
                GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
                    var _this = this;
                    this.throwIfDisposed();
                    return webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.getAttribLocation(program, attribute)
                    })
                };
                GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
                    this.throwIfDisposed();
                    return this.gl.getUniformLocation(program, uniformName)
                };
                GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
                    this.throwIfDisposed();
                    this.throwIfNoProgram();
                    webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit)
                };
                GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
                    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows)
                };
                GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
                    this.throwIfDisposed();
                    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0],
                        height = _a[1];
                    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height)
                };
                GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
                    this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows)
                };
                GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
                    throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
                };
                GPGPUContext.prototype.debugValidate = function () {
                    if (this.program != null) {
                        webgl_util.validateProgram(this.gl, this.program)
                    }
                    webgl_util.validateFramebuffer(this.gl)
                };
                GPGPUContext.prototype.executeProgram = function () {
                    this.throwIfDisposed();
                    this.throwIfNoProgram();
                    var gl = this.gl;
                    if (this.autoDebugValidate) {
                        this.debugValidate()
                    }
                    webgl_util.callAndCheck(gl, function () {
                        return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0)
                    })
                };
                GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
                    var _this = this;
                    this.throwIfDisposed();
                    webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.finish()
                    })
                };
                GPGPUContext.prototype.getQueryTimerExtension = function () {
                    if (this.disjointQueryTimerExtension == null) {
                        this.disjointQueryTimerExtension = webgl_util.getExtensionOrThrow(this.gl, environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")
                    }
                    return this.disjointQueryTimerExtension
                };
                GPGPUContext.prototype.getQueryTimerExtensionWebGL2 = function () {
                    return this.getQueryTimerExtension()
                };
                GPGPUContext.prototype.getQueryTimerExtensionWebGL1 = function () {
                    return this.getQueryTimerExtension()
                };
                GPGPUContext.prototype.runQuery = function (queryFn) {
                    var query = this.beginQuery();
                    queryFn();
                    this.endQuery();
                    return this.pollQueryTime(query)
                };
                GPGPUContext.prototype.beginQuery = function () {
                    if (environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
                        var gl2 = this.gl;
                        var ext_1 = this.getQueryTimerExtensionWebGL2();
                        var query_1 = gl2.createQuery();
                        gl2.beginQuery(ext_1.TIME_ELAPSED_EXT, query_1);
                        return query_1
                    }
                    var ext = this.getQueryTimerExtensionWebGL1();
                    var query = ext.createQueryEXT();
                    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
                    return query
                };
                GPGPUContext.prototype.endQuery = function () {
                    if (environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
                        var gl2 = this.gl;
                        var ext_2 = this.getQueryTimerExtensionWebGL2();
                        gl2.endQuery(ext_2.TIME_ELAPSED_EXT);
                        return
                    }
                    var ext = this.getQueryTimerExtensionWebGL1();
                    ext.endQueryEXT(ext.TIME_ELAPSED_EXT)
                };
                GPGPUContext.prototype.isQueryAvailable = function (query, queryTimerVersion) {
                    if (queryTimerVersion === 0) {
                        return true
                    }
                    if (queryTimerVersion === 2) {
                        var gl2 = this.gl;
                        var ext = this.getQueryTimerExtensionWebGL2();
                        var available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
                        var disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                        return available && !disjoint
                    } else {
                        var ext = this.getQueryTimerExtensionWebGL1();
                        var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                        var disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                        return available && !disjoint
                    }
                };
                GPGPUContext.prototype.pollQueryTime = function (query) {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        var resolveWithWarning = function () {
                            console.warn("Disjoint query timer never available.");
                            resolve(-1)
                        };
                        var queryTimerVersion = environment_1.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION");
                        util.repeatedTry(function () {
                            return _this.isQueryAvailable(query, queryTimerVersion)
                        }).then(function () {
                            return resolve(_this.getQueryTime(query, queryTimerVersion))
                        }).catch(resolveWithWarning)
                    })
                };
                GPGPUContext.prototype.getQueryTime = function (query, queryTimerVersion) {
                    if (queryTimerVersion === 0) {
                        return null
                    }
                    if (queryTimerVersion === 2) {
                        var gl2 = this.gl;
                        var timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
                        return timeElapsedNanos / 1e6
                    } else {
                        var ext = this.getQueryTimerExtensionWebGL1();
                        var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
                        return timeElapsedNanos / 1e6
                    }
                };
                GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
                    this.throwIfDisposed();
                    webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
                    if (this.autoDebugValidate) {
                        webgl_util.validateFramebuffer(this.gl)
                    }
                };
                GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
                    if (this.outputTexture != null) {
                        webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
                        if (this.autoDebugValidate) {
                            webgl_util.validateFramebuffer(this.gl)
                        }
                    } else {
                        webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer)
                    }
                };
                GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
                    this.downloadMatrixDriverSetup(texture);
                    var result = downloadAndDecode();
                    this.downloadMatrixDriverTeardown();
                    return result
                };
                GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
                    return __awaiter(this, void 0, void 0, function () {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.downloadMatrixDriverSetup(texture);
                                    return [4, downloadAndDecode()];
                                case 1:
                                    result = _a.sent();
                                    this.downloadMatrixDriverTeardown();
                                    return [2, result]
                            }
                        })
                    })
                };
                GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
                    this.throwIfDisposed();
                    var gl = this.gl;
                    webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
                    if (this.autoDebugValidate) {
                        webgl_util.validateFramebuffer(gl)
                    }
                    this.outputTexture = outputMatrixTextureMaybePacked;
                    webgl_util.callAndCheck(gl, function () {
                        return gl.viewport(0, 0, width, height)
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.scissor(0, 0, width, height)
                    })
                };
                GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
                    var _this = this;
                    this.throwIfDisposed();
                    webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.scissor(x, y, width, height)
                    })
                };
                GPGPUContext.prototype.throwIfDisposed = function () {
                    if (this.disposed) {
                        throw new Error("Attempted to use disposed GPGPUContext.")
                    }
                };
                GPGPUContext.prototype.throwIfNoProgram = function () {
                    if (this.program == null) {
                        throw new Error("No GPU program is currently set.")
                    }
                };
                return GPGPUContext
            }();
            exports.GPGPUContext = GPGPUContext
        }, {"../../environment": 47, "../../util": 153, "./gpgpu_util": 78, "./tex_util": 95, "./webgl_util": 100}],
        77: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var util = require("../../util");
            var shader_compiler = require("./shader_compiler");
            var NAN_UNIFORM_NAME = "NaN";

            function shouldUploadNaNUniform() {
                return !environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")
            }

            function compileProgram(gpgpu, program, inputs, output) {
                var userCode = program.userCode;
                var inputInfos = inputs.map(function (input, i) {
                    var shapeInfo = {logicalShape: input.tensor.shape, texShape: input.texData.texShape};
                    return {name: program.variableNames[i], shapeInfo: shapeInfo}
                });
                var inShapeInfos = inputInfos.map(function (x) {
                    return x.shapeInfo
                });
                var outShapeInfo = {logicalShape: output.tensor.shape, texShape: output.texData.texShape};
                var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
                var webGLProgram = gpgpu.createProgram(source);
                var uniformLocations = {};
                for (var i = 0; i < program.variableNames.length; i++) {
                    var uniformName = program.variableNames[i];
                    uniformLocations[uniformName] = gpgpu.getUniformLocation(webGLProgram, uniformName)
                }
                if (shouldUploadNaNUniform()) {
                    var throwIfNaNUniformIsNotUsed = false;
                    uniformLocations[NAN_UNIFORM_NAME] = gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME, throwIfNaNUniformIsNotUsed)
                }
                return {
                    program: program,
                    source: source,
                    webGLProgram: webGLProgram,
                    uniformLocations: uniformLocations,
                    gpgpu: gpgpu,
                    inShapeInfos: inShapeInfos,
                    outShapeInfo: outShapeInfo
                }
            }

            exports.compileProgram = compileProgram;

            function validateBinaryAndProgram(shapeInfos, inputs) {
                if (shapeInfos.length !== inputs.length) {
                    throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " + ("was executed with " + inputs.length + " inputs"))
                }
                shapeInfos.forEach(function (s, i) {
                    var shapeA = s.logicalShape;
                    var texShapeA = s.texShape;
                    var shapeB = inputs[i].tensor.shape;
                    var texShapeB = inputs[i].texData.texShape;
                    if (!util.arraysEqual(shapeA, shapeB)) {
                        throw Error("Binary was compiled with different shapes than " + ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"))
                    }
                    if (!util.arraysEqual(texShapeA, texShapeB)) {
                        throw Error("Binary was compiled with different texture shapes than the" + (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"))
                    }
                })
            }

            function runProgram(binary, inputs, output, customSetup) {
                validateBinaryAndProgram(binary.inShapeInfos, inputs);
                validateBinaryAndProgram([binary.outShapeInfo], [output]);
                var outTex = output.texData.texture;
                var outTexShape = output.texData.texShape;
                var gpgpu = binary.gpgpu;
                gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
                gpgpu.setProgram(binary.webGLProgram);
                inputs.forEach(function (input, i) {
                    var tex = input.texData.texture;
                    var variableName = binary.program.variableNames[i];
                    var variableUniformLocation = binary.uniformLocations[variableName];
                    gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i)
                });
                if (shouldUploadNaNUniform()) {
                    gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN)
                }
                if (customSetup != null) {
                    customSetup(gpgpu, binary.webGLProgram)
                }
                gpgpu.executeProgram()
            }

            exports.runProgram = runProgram;

            function makeShaderKey(program, inputs, output) {
                var keyInputs = "";
                inputs.concat(output).forEach(function (x) {
                    keyInputs += x.tensor.shape + "_" + x.texData.texShape
                });
                var keyUserCode = program.userCode;
                var keyBroadcast = (program.supportsBroadcasting === true).toString();
                var key = program.constructor.name;
                key += "_" + keyBroadcast + "_" + keyInputs + "_" + keyUserCode;
                return key
            }

            exports.makeShaderKey = makeShaderKey
        }, {"../../environment": 47, "../../util": 153, "./shader_compiler": 92}],
        78: [function (require, module, exports) {
            "use strict";
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var tex_util = require("./tex_util");
            var webgl_util = require("./webgl_util");

            function getWebGLContextAttributes() {
                return {
                    alpha: false,
                    antialias: false,
                    premultipliedAlpha: false,
                    preserveDrawingBuffer: false,
                    depth: false,
                    stencil: false,
                    failIfMajorPerformanceCaveat: true
                }
            }

            exports.getWebGLContextAttributes = getWebGLContextAttributes;

            function createWebGLContext(canvas) {
                var attributes = getWebGLContextAttributes();
                var gl;
                if (canvas != null) {
                    gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes)
                } else {
                    gl = webgl_util.createWebGLRenderingContext(attributes)
                }
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.DEPTH_TEST)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.STENCIL_TEST)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.BLEND)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.DITHER)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.POLYGON_OFFSET_FILL)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.SAMPLE_COVERAGE)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.enable(gl.SCISSOR_TEST)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.enable(gl.CULL_FACE)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.cullFace(gl.BACK)
                });
                return gl
            }

            exports.createWebGLContext = createWebGLContext;

            function createVertexShader(gl) {
                var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
                return webgl_util.createVertexShader(gl, vertexShaderSource)
            }

            exports.createVertexShader = createVertexShader;

            function createVertexBuffer(gl) {
                var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
                return webgl_util.createStaticVertexBuffer(gl, vertexArray)
            }

            exports.createVertexBuffer = createVertexBuffer;

            function createIndexBuffer(gl) {
                var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
                return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices)
            }

            exports.createIndexBuffer = createIndexBuffer;

            function getTextureInternalFormat(gl, numChannels) {
                if (!environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")) {
                    return gl.RGBA
                }
                if (environment_1.ENV.get("WEBGL_VERSION") === 2) {
                    if (numChannels === 4) {
                        return gl.RGBA32F
                    }
                    return gl.R32F
                }
                return gl.RGBA
            }

            function getTextureFormat(gl, numChannels) {
                if (!environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")) {
                    return gl.RGBA
                }
                if (environment_1.ENV.get("WEBGL_VERSION") === 2) {
                    if (numChannels === 4) {
                        return gl.RGBA
                    }
                    return gl.RED
                }
                return gl.RGBA
            }

            function getTextureType(gl) {
                if (!environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")) {
                    return gl.UNSIGNED_BYTE
                }
                return gl.FLOAT
            }

            function createAndConfigureTexture(gl, width, height, numChannels) {
                webgl_util.validateTextureSize(gl, width, height);
                var texture = webgl_util.createTexture(gl);
                var tex2d = gl.TEXTURE_2D;
                var internalFormat = getTextureInternalFormat(gl, numChannels);
                var format = getTextureFormat(gl, numChannels);
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(tex2d, texture)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, null)
                });
                return texture
            }

            function createMatrixTexture(gl, rows, columns) {
                var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0],
                    height = _a[1];
                var numChannels = 1;
                return createAndConfigureTexture(gl, width, height, numChannels)
            }

            exports.createMatrixTexture = createMatrixTexture;

            function createColorMatrixTexture(gl, rows, columns) {
                var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
                var numChannels = 4;
                return createAndConfigureTexture(gl, width, height, numChannels)
            }

            exports.createColorMatrixTexture = createColorMatrixTexture;

            function createPackedMatrixTexture(gl, rows, columns) {
                var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
                var numChannels = 4;
                return createAndConfigureTexture(gl, width, height, numChannels)
            }

            exports.createPackedMatrixTexture = createPackedMatrixTexture;

            function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
                var posOffset = 0;
                var uvOffset = 3 * 4;
                var stride = 3 * 4 + 2 * 4;
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
                });
                var success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, "clipSpacePos", vertexBuffer, 3, stride, posOffset);
                return success && webgl_util.bindVertexBufferToProgramAttribute(gl, program, "uv", vertexBuffer, 2, stride, uvOffset)
            }

            exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;

            function uploadPixelDataToTexture(gl, texture, pixels) {
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, texture)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, null)
                })
            }

            exports.uploadPixelDataToTexture = uploadPixelDataToTexture;

            function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
                var textureFormat = getTextureFormat(gl, numChannels);
                webgl_util.validateTextureSize(gl, width, height);
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, texture)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data)
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, null)
                })
            }

            function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
                var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                var unpackedArray;
                if (environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")) {
                    var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
                    if (channelsPerTexture === 1) {
                        unpackedArray = matrix
                    } else {
                        unpackedArray = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
                        tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture)
                    }
                } else {
                    unpackedArray = tex_util.encodeFloatArray(matrix)
                }
                uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels)
            }

            exports.uploadMatrixToTexture = uploadMatrixToTexture;

            function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
                var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
                tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
                var numChannels = 4;
                uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels)
            }

            exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;

            function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
                var isFloatTexture = environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED");
                var downloadTarget;
                if (isFloatTexture) {
                    downloadTarget = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture))
                } else {
                    downloadTarget = new Uint8Array(rows * columns * channelsPerTexture)
                }
                return downloadTarget
            }

            function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
                var isFloatTexture = environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED");
                if (isFloatTexture) {
                    var matrix = new Float32Array(rows * columns);
                    tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
                    return matrix
                } else {
                    return tex_util.decodeToFloatArray(downloadTarget)
                }
            }

            function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
                return __awaiter(this, void 0, void 0, function () {
                    var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                gl2 = gl;
                                channelsPerPixel = 4;
                                downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                                bufferSizeBytes = downloadTarget instanceof Float32Array ? downloadTarget.length * 4 : downloadTarget;
                                buffer = gl.createBuffer();
                                webgl_util.callAndCheck(gl, function () {
                                    return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer)
                                });
                                webgl_util.callAndCheck(gl, function () {
                                    return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW)
                                });
                                webgl_util.callAndCheck(gl, function () {
                                    return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0)
                                });
                                return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                            case 1:
                                _a.sent();
                                return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)]
                        }
                    })
                })
            }

            exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;

            function downloadMatrixFromOutputTexture(gl, rows, columns) {
                var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                var channelsPerPixel = 4;
                var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                webgl_util.callAndCheck(gl, function () {
                    return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget)
                });
                return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)
            }

            exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;

            function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
                var size = rows * columns * 4;
                var downloadTarget = new Uint8Array(size);
                webgl_util.callAndCheck(gl, function () {
                    return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget)
                });
                var packedRGBA = new Float32Array(size);
                for (var i = 0; i < downloadTarget.length; i++) {
                    packedRGBA[i] = downloadTarget[i]
                }
                var matrix = new Float32Array(rows * columns * channels);
                tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
                return matrix
            }

            exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;

            function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
                var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
                webgl_util.callAndCheck(gl, function () {
                    return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA)
                });
                var matrix = new Float32Array(rows * columns);
                return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix)
            }

            exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture
        }, {"../../environment": 47, "./tex_util": 95, "./webgl_util": 100}],
        79: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var WhereProgram = function () {
                function WhereProgram(cRank, shape, rank) {
                    this.variableNames = ["c", "a", "b"];
                    this.outputShape = shape;
                    var cCoords;
                    var abCoords;
                    if (rank > 4) {
                        throw Error("Where for rank " + rank + " is not yet supported")
                    }
                    if (rank === 1) {
                        abCoords = "resRC";
                        cCoords = "resRC"
                    } else {
                        var currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
                        var cCoordVars = [];
                        var abCoordVars = [];
                        for (var i = 0; i < shape.length; i++) {
                            abCoordVars.push("" + currentCoords[i]);
                            if (i < cRank) {
                                cCoordVars.push("" + currentCoords[i])
                            }
                        }
                        cCoords = cCoordVars.join();
                        abCoords = abCoordVars.join()
                    }
                    var dtype = shader_compiler_1.getCoordsDataType(rank);
                    this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        float cVal = getC(" + cCoords + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + abCoords + "));\n        } else {\n          setOutput(getB(" + abCoords + "));\n        }\n      }\n    "
                }

                return WhereProgram
            }();
            exports.WhereProgram = WhereProgram
        }, {"./shader_compiler": 92}],
        80: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var LRNProgram = function () {
                function LRNProgram(xShape, radius, bias, alpha, beta) {
                    this.variableNames = ["x"];
                    this.outputShape = [];
                    var rad = radius;
                    var maxD = xShape[3] - 1;
                    this.outputShape = xShape;
                    var powOperator;
                    var basis = "float(" + bias + ") + float(" + alpha + ") * sum";
                    if (beta === .5) {
                        powOperator = "inversesqrt(" + basis + ")"
                    } else if (beta === 1) {
                        powOperator = "1.0/(" + basis + ")"
                    } else {
                        powOperator = "exp(log(" + basis + ") * float(-" + beta + "));"
                    }
                    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + rad + "; j <= " + rad + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + maxD + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + powOperator + ";\n        setOutput(val);\n      }\n    "
                }

                return LRNProgram
            }();
            exports.LRNProgram = LRNProgram
        }, {}],
        81: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var MaxPool2DBackpropProgram = function () {
                function MaxPool2DBackpropProgram(convInfo) {
                    this.variableNames = ["dy", "maxPos"];
                    this.outputShape = convInfo.inShape;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = filterHeight - 1 - convInfo.padInfo.top;
                    var padLeft = filterWidth - 1 - convInfo.padInfo.left;
                    var lastIndex = filterHeight * filterWidth - 1;
                    this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
                }

                return MaxPool2DBackpropProgram
            }();
            exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram
        }, {}],
        82: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var MatMulProgram = function () {
                function MatMulProgram(aShape, bShape, transposeA, transposeB) {
                    if (transposeA === void 0) {
                        transposeA = false
                    }
                    if (transposeB === void 0) {
                        transposeB = false
                    }
                    this.variableNames = ["matrixA", "matrixB"];
                    var outerShapeA = transposeA ? aShape[1] : aShape[0];
                    var outerShapeB = transposeB ? bShape[0] : bShape[1];
                    var sharedDim = transposeA ? aShape[0] : aShape[1];
                    this.outputShape = [outerShapeA, outerShapeB];
                    var aSnippetFromOffset = function (vec4Offset, indexVar) {
                        return transposeA ? indexVar + " + " + vec4Offset + ", aRow" : "aRow, " + indexVar + " + " + vec4Offset
                    };
                    var bSnippetFromOffset = function (vec4Offset, indexVar) {
                        return transposeB ? "bCol, " + indexVar + " + " + vec4Offset : indexVar + " + " + vec4Offset + ", bCol"
                    };
                    var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
                    var sharedDimVec4Remainder = sharedDim % 4;
                    this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, "i") + "),\n          getMatrixA(" + aSnippetFromOffset(1, "i") + "),\n          getMatrixA(" + aSnippetFromOffset(2, "i") + "),\n          getMatrixA(" + aSnippetFromOffset(3, "i") + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, "i") + "),\n          getMatrixB(" + bSnippetFromOffset(1, "i") + "),\n          getMatrixB(" + bSnippetFromOffset(2, "i") + "),\n          getMatrixB(" + bSnippetFromOffset(3, "i") + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    "
                }

                return MatMulProgram
            }();
            exports.MatMulProgram = MatMulProgram
        }, {}],
        83: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var MultinomialProgram = function () {
                function MultinomialProgram(batchSize, numOutcomes, numSamples) {
                    this.variableNames = ["probs"];
                    this.outputShape = [batchSize, numSamples];
                    this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    "
                }

                MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
                    var _this = this;
                    return function (gpgpu, webGLProgram) {
                        if (_this.seedLoc == null) {
                            _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, "seed")
                        }
                        gpgpu.gl.uniform1f(_this.seedLoc, seed)
                    }
                };
                return MultinomialProgram
            }();
            exports.MultinomialProgram = MultinomialProgram
        }, {}],
        84: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var OneHotProgram = function () {
                function OneHotProgram(numIndices, depth, onValue, offValue) {
                    this.variableNames = ["indices"];
                    this.outputShape = [numIndices, depth];
                    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    "
                }

                return OneHotProgram
            }();
            exports.OneHotProgram = OneHotProgram
        }, {}],
        85: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var PadProgram = function () {
                function PadProgram(xShape, paddings, constantValue) {
                    this.variableNames = ["x"];
                    this.outputShape = paddings.map(function (p, i) {
                        return p[0] + xShape[i] + p[1]
                    });
                    var rank = xShape.length;
                    var type = shader_compiler_1.getCoordsDataType(rank);
                    var start = paddings.map(function (p) {
                        return p[0]
                    }).join(",");
                    var end = paddings.map(function (p, i) {
                        return p[0] + xShape[i]
                    }).join(",");
                    var unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
                    if (rank === 1) {
                        this.userCode = "\n        int start = " + start + ";\n        int end = " + end + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + constantValue + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
                        return
                    }
                    this.userCode = "\n      " + type + " start = " + type + "(" + start + ");\n      " + type + " end = " + type + "(" + end + ");\n\n      void main() {\n        " + type + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + constantValue + "));\n        } else {\n          " + type + " coords = outC - start;\n          setOutput(getX(" + unpackedCoords + "));\n        }\n      }\n    "
                }

                return PadProgram
            }();
            exports.PadProgram = PadProgram
        }, {"./shader_compiler": 92}],
        86: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Pool2DProgram = function () {
                function Pool2DProgram(convInfo, poolType, computePositions) {
                    this.variableNames = ["x"];
                    if (poolType === "avg" && computePositions) {
                        throw new Error("Cannot compute positions for average pool.")
                    }
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    this.outputShape = convInfo.outShape;
                    var isAvgPool = poolType === "avg";
                    var initializationValue = "0.0";
                    if (!isAvgPool) {
                        initializationValue = "-1.0 / 0.0"
                    }
                    if (computePositions) {
                        var compareOp_1 = ">=";
                        this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
                        return
                    }
                    var compareOp = "max";
                    var returnValue = poolType + "(" + poolType + "(" + poolType + "(" + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                    if (poolType === "avg") {
                        returnValue = "avgValue / count"
                    }
                    var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
                    var filterWidthVec4Remainder = filterWidth % 4;
                    var updateSnippet = "\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
                    this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    "
                }

                return Pool2DProgram
            }();
            exports.Pool2DProgram = Pool2DProgram
        }, {}],
        87: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ReduceProgram = function () {
                function ReduceProgram(reduceInfo, reduceType) {
                    this.variableNames = ["x"];
                    var windowSize = reduceInfo.windowSize;
                    var batchSize = reduceInfo.batchSize;
                    var inSize = reduceInfo.inSize;
                    var outSize = Math.ceil(inSize / windowSize);
                    this.outputShape = [batchSize, outSize];
                    var isReduceSum = reduceType === "sum";
                    var initializationValue = "0.0";
                    if (!isReduceSum) {
                        if (reduceType === "min") {
                            initializationValue = "1.0 / 0.0"
                        } else {
                            initializationValue = "-1.0 / 0.0"
                        }
                    }
                    var compareOp = reduceType === "min" ? "min" : "max";
                    var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                    if (reduceType === "sum") {
                        returnValue = "sumValue"
                    }
                    var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
                    var windowSizeVec4Remainder = windowSize % 4;
                    var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
                    var checkOutOfBounds = "";
                    if (inSize % windowSize > 0) {
                        checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      "
                    }
                    this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    "
                }

                return ReduceProgram
            }();
            exports.ReduceProgram = ReduceProgram
        }, {}],
        88: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ResizeBilinearBackpropProgram = function () {
                function ResizeBilinearBackpropProgram(dy, x, alignCorners) {
                    this.variableNames = ["dy"];
                    this.outputShape = [];
                    this.outputShape = x.shape;
                    var _a = x.shape, xHeight = _a[1], xWidth = _a[2];
                    var _b = dy.shape, yHeight = _b[1], yWidth = _b[2];
                    var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];
                    var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];
                    var heightScale = effectiveXSize[0] / effectiveYSize[0];
                    var widthScale = effectiveXSize[1] / effectiveYSize[1];
                    var invHeightScale = 1 / heightScale;
                    var invWidthScale = 1 / widthScale;
                    var winHeight = Math.ceil(invHeightScale) * 2 + 2;
                    var winWidth = Math.ceil(invWidthScale) * 2 + 2;
                    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + heightScale + ");\n        const float widthScale = float(" + widthScale + ");\n\n        const float invHeightScale = float(" + invHeightScale + ");\n        const float invWidthScale = float(" + invWidthScale + ");\n\n        const int winHeight = int(" + winHeight + ");\n        const int winWidth = int(" + winWidth + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + yHeight + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + yWidth + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (xHeight - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (xWidth - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
                }

                return ResizeBilinearBackpropProgram
            }();
            exports.ResizeBilinearBackpropProgram = ResizeBilinearBackpropProgram
        }, {}],
        89: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ResizeBilinearProgram = function () {
                function ResizeBilinearProgram(inputShape, newHeight, newWidth, alignCorners) {
                    this.variableNames = ["A"];
                    this.outputShape = [];
                    var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2],
                        depth = inputShape[3];
                    this.outputShape = [batch, newHeight, newWidth, depth];
                    var effectiveInSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];
                    var effectiveOutSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];
                    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "
                }

                return ResizeBilinearProgram
            }();
            exports.ResizeBilinearProgram = ResizeBilinearProgram
        }, {}],
        90: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ResizeNearestNeighborProgram = function () {
                function ResizeNearestNeighborProgram(inputShape, newHeight, newWidth, alignCorners) {
                    this.variableNames = ["A"];
                    this.outputShape = [];
                    var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2],
                        depth = inputShape[3];
                    this.outputShape = [batch, newHeight, newWidth, depth];
                    var effectiveInSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
                    var effectiveOutSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
                    var roundBase = alignCorners ? "0.5" : "0.0";
                    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + roundBase + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "
                }

                return ResizeNearestNeighborProgram
            }();
            exports.ResizeNearestNeighborProgram = ResizeNearestNeighborProgram
        }, {}],
        91: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var ReverseProgram = function () {
                function ReverseProgram(xShape, axis) {
                    this.variableNames = ["x"];
                    var rank = xShape.length;
                    if (rank > 4) {
                        throw new Error("WebGL backend: Reverse of rank-" + rank + " tensor is not yet supported")
                    }
                    this.outputShape = xShape;
                    if (rank === 1) {
                        this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + xShape[0] + " - coord - 1));\n        }\n      ";
                        return
                    }
                    var getInCoord = function (i) {
                        if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
                            return xShape[i] + " - coords[" + i + "] - 1"
                        }
                        return "coords[" + i + "]"
                    };
                    var inCoords = xShape.map(function (_, i) {
                        return getInCoord(i)
                    }).join(",");
                    var type = shader_compiler_1.getCoordsDataType(rank);
                    this.userCode = "\n      void main() {\n        " + type + " coords = getOutputCoords();\n        setOutput(getX(" + inCoords + "));\n      }\n    "
                }

                return ReverseProgram
            }();
            exports.ReverseProgram = ReverseProgram
        }, {"./shader_compiler": 92}],
        92: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var util = require("../../util");
            var broadcast_util = require("../../ops/broadcast_util");
            var tex_util = require("./tex_util");

            function makeShader(inputsInfo, outputShape, userCode, broadcast) {
                var sampleSnippet = getSampleSnippet();
                var setOutputSnippet = getSetOutputSnippet();
                var inputPrefixSnippet = inputsInfo.map(function (x) {
                    return "uniform sampler2D " + x.name + ";"
                }).join("\n");
                var inputSamplingSnippet = inputsInfo.map(function (x) {
                    return getInputSamplingSnippet(x, outputShape, broadcast)
                }).join("\n");
                var outTexShape = outputShape.texShape;
                var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
                var source = [SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode].join("\n");
                return source
            }

            exports.makeShader = makeShader;

            function getSampleSnippet() {
                return environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED") ? FLOAT_TEXTURE_SAMPLE_SNIPPET : UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET
            }

            function getSetOutputSnippet() {
                return environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED") ? FLOAT_TEXTURE_SETOUTPUT_SNIPPET : UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET
            }

            function getSamplerFromInInfo(inInfo) {
                var shape = inInfo.shapeInfo.logicalShape;
                switch (shape.length) {
                    case 0:
                        return getSamplerScalar(inInfo);
                    case 1:
                        return getSampler1D(inInfo);
                    case 2:
                        return getSampler2D(inInfo);
                    case 3:
                        return getSampler3D(inInfo);
                    case 4:
                        return getSampler4D(inInfo);
                    default:
                        throw new Error(shape.length + "-D input sampling" + " is not yet supported")
                }
            }

            function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
                var res = getSamplerFlat(inInfo);
                res += getSamplerFromInInfo(inInfo);
                if (broadcast || util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
                    res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast)
                }
                return res
            }

            function getOutputSamplingSnippet(outShape, outTexShape) {
                switch (outShape.length) {
                    case 0:
                        return getOutputScalarCoords();
                    case 1:
                        return getOutput1DCoords(outShape, outTexShape);
                    case 2:
                        return getOutput2DCoords(outShape, outTexShape);
                    case 3:
                        return getOutput3DCoords(outShape, outTexShape);
                    case 4:
                        return getOutput4DCoords(outShape, outTexShape);
                    default:
                        throw new Error(outShape.length + "-D output sampling is not yet supported")
                }
            }

            var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
            var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
            var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
            var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
            var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    vec4 sampleValue = texture2D(textureSampler, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
            var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
            var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n";
            var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
            var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n";

            function getOutputScalarCoords() {
                return "\n    int getOutputCoords() {\n      return 0;\n    }\n  "
            }

            function getOutput1DCoords(shape, texShape) {
                if (texShape[0] === 1) {
                    return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    "
                }
                if (texShape[1] === 1) {
                    return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    "
                }
                return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  "
            }

            function getOutput3DCoords(shape, texShape) {
                var stride0 = shape[1] * shape[2];
                var stride1 = shape[2];
                return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  "
            }

            function getOutput4DCoords(shape, texShape) {
                var stride2 = shape[3];
                var stride1 = shape[2] * stride2;
                var stride0 = shape[1] * stride1;
                return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  "
            }

            function getOutput2DCoords(shape, texShape) {
                if (util.arraysEqual(shape, texShape)) {
                    return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    "
                }
                if (shape[1] === 1) {
                    return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    "
                }
                if (shape[0] === 1) {
                    return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    "
                }
                return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  "
            }

            function getSamplerScalar(inputInfo) {
                var texName = inputInfo.name;
                var funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
                return "\n    float " + funcName + "() {\n      return sampleTexture(" + texName + ", halfCR);\n    }\n  "
            }

            function getSampler1D(inputInfo) {
                var texName = inputInfo.name;
                var funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
                return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  "
            }

            function getSampler2D(inputInfo) {
                var shape = inputInfo.shapeInfo.logicalShape;
                var texShape = inputInfo.shapeInfo.texShape;
                var texName = inputInfo.name;
                var funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
                var texNumR = texShape[0];
                var texNumC = texShape[1];
                if (util.arraysEqual(shape, texShape)) {
                    return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  "
                }
                var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
                var squeezedShape = newShape;
                if (squeezedShape.length < shape.length) {
                    var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
                    var params = ["row", "col"];
                    return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    "
                }
                if (texNumC === 1) {
                    return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  "
                }
                if (texNumR === 1) {
                    return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sampleTexture(" + texName + ", uv);\n    }\n  "
                }
                return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sampleTexture(" + texName + ", uv);\n  }\n"
            }

            function getSampler3D(inputInfo) {
                var texShape = inputInfo.shapeInfo.texShape;
                var shape = inputInfo.shapeInfo.logicalShape;
                var texName = inputInfo.name;
                var funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
                var texNumR = texShape[0];
                var texNumC = texShape[1];
                var stride0 = shape[1] * shape[2];
                var stride1 = shape[2];
                var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
                var squeezedShape = newShape;
                if (squeezedShape.length < shape.length) {
                    var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
                    var params = ["row", "col", "depth"];
                    return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      "
                }
                if (texNumC === stride0) {
                    return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sampleTexture(" + texName + ", uv);\n        }\n      "
                }
                if (texNumC === stride1) {
                    return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sampleTexture(" + texName + ", uv);\n    }\n  "
                }
                return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sampleTexture(" + texName + ", uv);\n      }\n  "
            }

            function getSampler4D(inputInfo) {
                var shape = inputInfo.shapeInfo.logicalShape;
                var texShape = inputInfo.shapeInfo.texShape;
                var texName = inputInfo.name;
                var funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
                var texNumR = texShape[0];
                var texNumC = texShape[1];
                var stride2 = shape[3];
                var stride1 = shape[2] * stride2;
                var stride0 = shape[1] * stride1;
                var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
                if (newShape.length < shape.length) {
                    var newInputInfo = squeezeInputInfo(inputInfo, newShape);
                    var params = ["row", "col", "depth", "depth2"];
                    return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    "
                }
                if (texNumC === stride0) {
                    return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    "
                }
                if (texNumC === stride2) {
                    return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    "
                }
                return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sampleTexture(" + texName + ", uv);\n    }\n  "
            }

            function getSamplerFlat(inputInfo) {
                var texName = inputInfo.name;
                var texShape = inputInfo.shapeInfo.texShape;
                var funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1) + "Flat";
                var tNumR = texShape[0];
                var tNumC = texShape[1];
                if (tNumC === 1 && tNumR === 1) {
                    return "\n      float " + funcName + "(int index) {\n        return sampleTexture(" + texName + ", halfCR);\n      }\n    "
                }
                if (tNumC === 1) {
                    return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sampleTexture(" + texName + ", uv);\n      }\n    "
                }
                if (tNumR === 1) {
                    return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sampleTexture(" + texName + ", uv);\n      }\n    "
                }
                return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sampleTexture(" + texName + ", uv);\n    }\n  "
            }

            function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
                var inRank = inputInfo.shapeInfo.logicalShape.length;
                var outRank = outShapeInfo.logicalShape.length;
                var type = "int";
                if (outRank === 2) {
                    type = "ivec2"
                } else if (outRank === 3) {
                    type = "ivec3"
                } else if (outRank === 4) {
                    type = "ivec4"
                }
                var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
                var rankDiff = outRank - inRank;
                var coordsSnippet;
                if (inRank === 0) {
                    coordsSnippet = ""
                } else if (outRank < 2 && broadcastDims.length >= 1) {
                    coordsSnippet = "coords = 0;"
                } else {
                    coordsSnippet = broadcastDims.map(function (d) {
                        return "coords[" + (d + rankDiff) + "] = 0;"
                    }).join("\n")
                }
                var unpackedCoordsSnippet = "";
                if (outRank < 2 && inRank > 0) {
                    unpackedCoordsSnippet = "coords"
                } else {
                    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map(function (s, i) {
                        return "coords[" + (i + rankDiff) + "]"
                    }).join(", ")
                }
                return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  "
            }

            function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
                var inTexShape = inputInfo.shapeInfo.texShape;
                var texName = inputInfo.name;
                var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
                var funcName = "get" + texFuncSnippet + "AtOutCoords";
                var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
                var inRank = inputInfo.shapeInfo.logicalShape.length;
                var outRank = outShapeInfo.logicalShape.length;
                var doBroadcast = supportsBroadcasting && (outRank > inRank || broadcastDims.length > 0);
                var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
                if (doBroadcast && !broadcastOverOuter) {
                    return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName)
                }
                var outTexShape = outShapeInfo.texShape;
                if (util.arraysEqual(inTexShape, outTexShape)) {
                    return "\n      float " + funcName + "() {\n        return sampleTexture(" + texName + ", resultUV);\n      }\n    "
                }
                var inSize = util.sizeFromShape(inTexShape);
                var broadcastSnippet = "";
                if (doBroadcast && broadcastOverOuter) {
                    broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      "
                }
                return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexShape[1] + ";\n      int texC = index - texR * " + inTexShape[1] + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      return sampleTexture(" + texName + ", uv);\n    }\n  "
            }

            function getCoordsDataType(rank) {
                if (rank <= 1) {
                    return "int"
                } else if (rank === 2) {
                    return "ivec2"
                } else if (rank === 3) {
                    return "ivec3"
                } else if (rank === 4) {
                    return "ivec4"
                } else {
                    throw Error("GPU for rank " + rank + " is not yet supported")
                }
            }

            exports.getCoordsDataType = getCoordsDataType;

            function squeezeInputInfo(inInfo, squeezedShape) {
                var newInputInfo = JSON.parse(JSON.stringify(inInfo));
                newInputInfo.shapeInfo.logicalShape = squeezedShape;
                return newInputInfo
            }

            function getSqueezedParams(params, keptDims) {
                return keptDims.map(function (d) {
                    return params[d]
                }).join(", ")
            }
        }, {"../../environment": 47, "../../ops/broadcast_util": 105, "../../util": 153, "./tex_util": 95}],
        93: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var SliceProgram = function () {
                function SliceProgram(destSize) {
                    this.variableNames = ["source"];
                    this.outputShape = destSize;
                    this.rank = destSize.length;
                    var dtype = shader_compiler_1.getCoordsDataType(this.rank);
                    var sourceCoords = getCoords(this.rank);
                    this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    "
                }

                SliceProgram.prototype.getCustomSetupFunc = function (start) {
                    var _this = this;
                    if (start.length !== this.rank) {
                        throw Error("The rank (" + this.rank + ") of the program must match the " + ("length of start (" + start.length + ")"))
                    }
                    return function (gpgpu, webGLProgram) {
                        if (_this.startLoc == null) {
                            _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "start");
                            if (_this.startLoc == null) {
                                return
                            }
                        }
                        if (_this.rank === 1) {
                            gpgpu.gl.uniform1i(_this.startLoc, start[0])
                        } else if (_this.rank === 2) {
                            gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1])
                        } else if (_this.rank === 3) {
                            gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2])
                        } else if (_this.rank === 4) {
                            gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3])
                        } else {
                            throw Error("Slicing for rank " + _this.rank + " is not yet supported")
                        }
                    }
                };
                return SliceProgram
            }();
            exports.SliceProgram = SliceProgram;

            function getCoords(rank) {
                if (rank === 1) {
                    return "sourceLoc"
                } else if (rank === 2) {
                    return "sourceLoc.x, sourceLoc.y"
                } else if (rank === 3) {
                    return "sourceLoc.x, sourceLoc.y, sourceLoc.z"
                } else if (rank === 4) {
                    return "sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w"
                } else {
                    throw Error("Slicing for rank " + rank + " is not yet supported")
                }
            }
        }, {"./shader_compiler": 92}],
        94: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var StridedSliceProgram = function () {
                function StridedSliceProgram(begin, strides, shape) {
                    this.variableNames = ["x"];
                    this.outputShape = shape;
                    this.rank = shape.length;
                    var dtype = shader_compiler_1.getCoordsDataType(this.rank);
                    var newCoords = "";
                    if (this.rank === 1) {
                        newCoords = "coords * strides + begin"
                    } else {
                        newCoords = shape.map(function (_, i) {
                            return "coords[" + i + "] * strides[" + i + "] + begin[" + i + "]"
                        }).join(",")
                    }
                    this.userCode = "\n      " + dtype + " begin = " + dtype + "(" + begin + ");\n      " + dtype + " strides = " + dtype + "(" + strides + ");\n\n      void main() {\n        " + dtype + " coords = getOutputCoords();\n        setOutput(getX(" + newCoords + "));\n      }\n    "
                }

                return StridedSliceProgram
            }();
            exports.StridedSliceProgram = StridedSliceProgram
        }, {"./shader_compiler": 92}],
        95: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var TextureType;
            (function (TextureType) {
                TextureType[TextureType["FLOAT"] = 0] = "FLOAT";
                TextureType[TextureType["UNSIGNED_BYTE"] = 1] = "UNSIGNED_BYTE"
            })(TextureType = exports.TextureType || (exports.TextureType = {}));

            function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
                return [columns, rows]
            }

            exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;

            function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
                return matrixSize * channelsPerTexture
            }

            exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;

            function getColorMatrixTextureShapeWidthHeight(rows, columns) {
                return [columns * 4, rows]
            }

            exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;

            function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
                if (unpackedSize % channelsPerTexture !== 0) {
                    throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " + ("" + channelsPerTexture))
                }
                return unpackedSize / channelsPerTexture
            }

            exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;

            function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
                var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
                if (unpackedArray.length < requiredSize) {
                    throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " + ("" + requiredSize))
                }
                var dst = 0;
                for (var src = 0; src < matrix.length; ++src) {
                    unpackedArray[dst] = matrix[src];
                    dst += channelsPerTexture
                }
            }

            exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
            exports.FLOAT_MAX = 2e4;
            exports.FLOAT_MIN = -exports.FLOAT_MAX;
            var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
            var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
            var FLOAT_POWERS = [1, 255, 255 * 255];
            exports.BYTE_NAN_VALUE = 0;

            function encodeFloatArray(floatArray) {
                var uintArray = new Uint8Array(floatArray.length * 4);
                var _loop_1 = function (i) {
                    var value = floatArray[i / 4];
                    if (isNaN(value)) {
                        uintArray[i] = exports.BYTE_NAN_VALUE;
                        uintArray[i + 1] = exports.BYTE_NAN_VALUE;
                        uintArray[i + 2] = exports.BYTE_NAN_VALUE;
                        uintArray[i + 3] = exports.BYTE_NAN_VALUE;
                        return "continue"
                    }
                    var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
                    var enc = FLOAT_POWERS.map(function (pow) {
                        return pow * normalizedValue
                    });
                    var buckets = enc.map(function (value) {
                        return Math.floor(value % 1 * 255)
                    });
                    uintArray[i] = Math.floor(normalizedValue);
                    uintArray[i + 1] = buckets[0];
                    uintArray[i + 2] = buckets[1];
                    uintArray[i + 3] = buckets[2]
                };
                for (var i = 0; i < uintArray.length; i += 4) {
                    _loop_1(i)
                }
                return uintArray
            }

            exports.encodeFloatArray = encodeFloatArray;

            function decodeToFloatArray(uintArray) {
                var floatArray = new Float32Array(uintArray.length / 4);
                var _loop_2 = function (i) {
                    if (uintArray[i] === exports.BYTE_NAN_VALUE && uintArray[i + 1] === exports.BYTE_NAN_VALUE && uintArray[i + 2] === exports.BYTE_NAN_VALUE && uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
                        floatArray[i / 4] = NaN;
                        return "continue"
                    }
                    var dot = 0;
                    FLOAT_DELTAS.forEach(function (delta, j) {
                        dot += delta * uintArray[i + j]
                    });
                    var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
                    floatArray[i / 4] = value
                };
                for (var i = 0; i < uintArray.length; i += 4) {
                    _loop_2(i)
                }
                return floatArray
            }

            exports.decodeToFloatArray = decodeToFloatArray;

            function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
                var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
                if (matrix.length < requiredSize) {
                    throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize)
                }
                var dst = 0;
                for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
                    matrix[dst++] = unpackedArray[src]
                }
            }

            exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;

            function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
                var requiredSize = unpackedArray.length * channels / 4;
                if (matrix.length < requiredSize) {
                    throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize)
                }
                var dst = 0;
                for (var src = 0; src < unpackedArray.length; src += 4) {
                    for (var c = 0; c < channels; c++) {
                        matrix[dst++] = unpackedArray[src + c]
                    }
                }
            }

            exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;

            function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
                return [Math.ceil(columns / 2), Math.ceil(rows / 2)]
            }

            exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;

            function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
                var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                return w * h * 4
            }

            exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;

            function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
                var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
                if (packedRGBA.length < requiredSize) {
                    throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize)
                }
                var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0],
                    textureHeight = _a[1];
                var oddWidth = columns % 2 === 1;
                var oddHeight = rows % 2 === 1;
                var widthInFullBlocks = Math.floor(columns / 2);
                var heightInFullBlocks = Math.floor(rows / 2);
                {
                    var dstStride = oddWidth ? 4 : 0;
                    var oneRow = columns;
                    var dst = 0;
                    for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
                        var matrixSrcRow = blockY * 2 * columns;
                        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                            var matrixSrcCol = blockX * 2;
                            var src = matrixSrcRow + matrixSrcCol;
                            packedRGBA[dst] = matrix[src];
                            packedRGBA[dst + 1] = matrix[src + 1];
                            packedRGBA[dst + 2] = matrix[src + oneRow];
                            packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                            dst += 4
                        }
                        dst += dstStride
                    }
                }
                if (oddWidth) {
                    var src = columns - 1;
                    var dst = (textureWidth - 1) * 4;
                    var srcStride = 2 * columns;
                    var dstStride = textureWidth * 4;
                    for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
                        packedRGBA[dst] = matrix[src];
                        packedRGBA[dst + 2] = matrix[src + columns];
                        src += srcStride;
                        dst += dstStride
                    }
                }
                if (oddHeight) {
                    var src = (rows - 1) * columns;
                    var dst = (textureHeight - 1) * textureWidth * 4;
                    for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                        packedRGBA[dst++] = matrix[src++];
                        packedRGBA[dst++] = matrix[src++];
                        dst += 2
                    }
                }
                if (oddWidth && oddHeight) {
                    packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1]
                }
                return packedRGBA
            }

            exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;

            function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
                var requiredSize = rows * columns;
                if (requiredSize < matrix.length) {
                    throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize)
                }
                var oddWidth = columns % 2 === 1;
                var oddHeight = rows % 2 === 1;
                var widthInFullBlocks = Math.floor(columns / 2);
                var heightInFullBlocks = Math.floor(rows / 2);
                var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0],
                    textureHeight = _a[1];
                {
                    var srcStride = oddWidth ? 4 : 0;
                    var dstStride = columns + (oddWidth ? 1 : 0);
                    var src = 0;
                    var dstRow1 = 0;
                    var dstRow2 = columns;
                    for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
                        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                            matrix[dstRow1++] = packedRGBA[src++];
                            matrix[dstRow1++] = packedRGBA[src++];
                            matrix[dstRow2++] = packedRGBA[src++];
                            matrix[dstRow2++] = packedRGBA[src++]
                        }
                        src += srcStride;
                        dstRow1 += dstStride;
                        dstRow2 += dstStride
                    }
                }
                if (oddWidth) {
                    var src = (textureWidth - 1) * 4;
                    var dst = columns - 1;
                    var srcStride = textureWidth * 4;
                    var dstStride = 2 * columns;
                    for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
                        matrix[dst] = packedRGBA[src];
                        matrix[dst + columns] = packedRGBA[src + 2];
                        src += srcStride;
                        dst += dstStride
                    }
                }
                if (oddHeight) {
                    var src = (textureHeight - 1) * textureWidth * 4;
                    var dst = (rows - 1) * columns;
                    for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                        matrix[dst++] = packedRGBA[src++];
                        matrix[dst++] = packedRGBA[src++];
                        src += 2
                    }
                }
                if (oddWidth && oddHeight) {
                    matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4]
                }
                return matrix
            }

            exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA
        }, {}],
        96: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tex_util_1 = require("./tex_util");
            var TextureManager = function () {
                function TextureManager(gpgpu) {
                    this.gpgpu = gpgpu;
                    this.numUsedTextures = 0;
                    this.numFreeTextures = 0;
                    this.freeTextures = {};
                    this.logEnabled = false;
                    this.allocatedTextures = [];
                    this.usedTextureCount = {}
                }

                TextureManager.prototype.acquireTexture = function (shapeRC, texType) {
                    if (texType === void 0) {
                        texType = tex_util_1.TextureType.FLOAT
                    }
                    var shapeKey = getKeyFromTextureShape(shapeRC, texType);
                    if (!(shapeKey in this.freeTextures)) {
                        this.freeTextures[shapeKey] = []
                    }
                    if (!(shapeKey in this.usedTextureCount)) {
                        this.usedTextureCount[shapeKey] = 0
                    }
                    this.usedTextureCount[shapeKey]++;
                    if (this.freeTextures[shapeKey].length > 0) {
                        this.numFreeTextures--;
                        this.numUsedTextures++;
                        this.log();
                        return this.freeTextures[shapeKey].shift()
                    }
                    this.numUsedTextures++;
                    this.log();
                    var newTexture = this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
                    this.allocatedTextures.push(newTexture);
                    return newTexture
                };
                TextureManager.prototype.releaseTexture = function (texture, shape, texType) {
                    if (texType === void 0) {
                        texType = tex_util_1.TextureType.FLOAT
                    }
                    var shapeKey = getKeyFromTextureShape(shape, texType);
                    if (!(shapeKey in this.freeTextures)) {
                        this.freeTextures[shapeKey] = []
                    }
                    this.freeTextures[shapeKey].push(texture);
                    this.numFreeTextures++;
                    this.numUsedTextures--;
                    this.usedTextureCount[shapeKey]--;
                    this.log()
                };
                TextureManager.prototype.log = function () {
                    if (!this.logEnabled) {
                        return
                    }
                    var total = this.numFreeTextures + this.numUsedTextures;
                    console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")")
                };
                TextureManager.prototype.getNumUsedTextures = function () {
                    return this.numUsedTextures
                };
                TextureManager.prototype.getNumFreeTextures = function () {
                    return this.numFreeTextures
                };
                TextureManager.prototype.dispose = function () {
                    var _this = this;
                    if (this.allocatedTextures == null) {
                        return
                    }
                    this.allocatedTextures.forEach(function (texture) {
                        _this.gpgpu.deleteMatrixTexture(texture)
                    });
                    this.freeTextures = null;
                    this.allocatedTextures = null;
                    this.usedTextureCount = null;
                    this.numUsedTextures = 0;
                    this.numFreeTextures = 0
                };
                return TextureManager
            }();
            exports.TextureManager = TextureManager;

            function getKeyFromTextureShape(shapeRowsCol, texType) {
                return shapeRowsCol[0] + "_" + shapeRowsCol[1] + "_" + texType
            }
        }, {"./tex_util": 95}],
        97: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var TileProgram = function () {
                function TileProgram(aShape, reps) {
                    this.variableNames = ["A"];
                    var outputShape = new Array(aShape.length);
                    for (var i = 0; i < outputShape.length; i++) {
                        outputShape[i] = aShape[i] * reps[i]
                    }
                    this.outputShape = outputShape;
                    this.rank = outputShape.length;
                    var dtype = shader_compiler_1.getCoordsDataType(this.rank);
                    var sourceCoords = getSourceCoords(aShape);
                    this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    "
                }

                return TileProgram
            }();
            exports.TileProgram = TileProgram;

            function getSourceCoords(aShape) {
                var rank = aShape.length;
                if (rank > 4) {
                    throw Error("Tile for rank " + rank + " is not yet supported")
                }
                if (rank === 1) {
                    return "imod(resRC, " + aShape[0] + ")"
                }
                var currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
                var sourceCoords = [];
                for (var i = 0; i < aShape.length; i++) {
                    sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")")
                }
                return sourceCoords.join()
            }
        }, {"./shader_compiler": 92}],
        98: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var TransposeProgram = function () {
                function TransposeProgram(aShape, newDim) {
                    this.variableNames = ["A"];
                    var outputShape = new Array(aShape.length);
                    for (var i = 0; i < outputShape.length; i++) {
                        outputShape[i] = aShape[newDim[i]]
                    }
                    this.outputShape = outputShape;
                    this.rank = outputShape.length;
                    var dtype = shader_compiler_1.getCoordsDataType(this.rank);
                    var switched = getSwitchedCoords(newDim);
                    this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    "
                }

                return TransposeProgram
            }();
            exports.TransposeProgram = TransposeProgram;

            function getSwitchedCoords(newDim) {
                var rank = newDim.length;
                if (rank > 4) {
                    throw Error("Transpose for rank " + rank + " is not yet supported")
                }
                var originalOrder = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
                var switchedCoords = new Array(rank);
                for (var i = 0; i < newDim.length; i++) {
                    switchedCoords[newDim[i]] = originalOrder[i]
                }
                return switchedCoords.join()
            }
        }, {"./shader_compiler": 92}],
        99: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var erf_util = require("../../ops/erf_util");
            var selu_util = require("../../ops/selu_util");
            var UnaryOpProgram = function () {
                function UnaryOpProgram(aShape, opSnippet) {
                    this.variableNames = ["A"];
                    this.outputShape = aShape;
                    this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
                }

                return UnaryOpProgram
            }();
            exports.UnaryOpProgram = UnaryOpProgram;
            var CHECK_NAN_SNIPPET = "if (isNaN(x)) return x;";
            exports.ABS = "return abs(x);";
            exports.RELU = CHECK_NAN_SNIPPET + "\n  return (x < 0.0) ? 0.0 : x;\n";
            exports.ELU = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
            exports.SELU = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + selu_util.SELU_SCALEALPHA + ";\n  float scale = " + selu_util.SELU_SCALE + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";

            function STEP(alpha) {
                if (alpha === void 0) {
                    alpha = 0
                }
                return CHECK_NAN_SNIPPET + ("\n    return x > 0.0 ? 1.0 : float(" + alpha + ");\n  ")
            }

            exports.STEP = STEP;
            exports.NEG = "return -x;";
            exports.CEIL = "return ceil(x);";
            exports.FLOOR = "return floor(x);";
            exports.SIGN = "\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n";
            exports.ROUND = "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n";
            exports.EXP = "return exp(x);";
            exports.EXPM1 = "return exp(x) - 1.0;";
            exports.LOG = "return log(x);";
            exports.LOG1P = "return log(1.0 + x);";
            exports.SQRT = "return sqrt(x);";
            exports.RSQRT = "return inversesqrt(x);";
            exports.SIGMOID = "return 1.0 / (1.0 + exp(-1.0 * x));";
            exports.SOFTPLUS = "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n";
            exports.SIN = "return sin(x);";
            exports.COS = "return cos(x);";
            exports.TAN = "return tan(x);";
            exports.ASIN = "return asin(x);";
            exports.ACOS = "return acos(x);";
            exports.ATAN = CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
            exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
            exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
            exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
            exports.ASINH = "return log(x + sqrt(x * x + 1.0));";
            exports.ACOSH = "return log(x + sqrt(x * x - 1.0));";
            exports.ATANH = "return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
            exports.ERF = '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ' + erf_util.ERF_P + ";\n  float a1 = " + erf_util.ERF_A1 + ";\n  float a2 = " + erf_util.ERF_A2 + ";\n  float a3 = " + erf_util.ERF_A3 + ";\n  float a4 = " + erf_util.ERF_A4 + ";\n  float a5 = " + erf_util.ERF_A5 + ";\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n";
            exports.SQUARE = "return x * x;";
            exports.RECIPROCAL = "return 1.0 / x;";
            exports.LOGICAL_NOT = "return float(!(x >= 1.0));";
            exports.TO_INT = "return float(int(x));"
        }, {"../../ops/erf_util": 111, "../../ops/selu_util": 128}],
        100: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var MAX_TEXTURE_SIZE = null;
            var util = require("../../util");
            var environment_1 = require("../../environment");

            function createWebGLRenderingContext(attributes) {
                var canvas = document.createElement("canvas");
                canvas.width = 1;
                canvas.height = 1;
                return createWebGLRenderingContextFromCanvas(canvas, attributes)
            }

            exports.createWebGLRenderingContext = createWebGLRenderingContext;

            function createWebGLRenderingContextFromCanvas(canvas, attributes) {
                var gl;
                var webglVersion = environment_1.ENV.get("WEBGL_VERSION");
                if (webglVersion === 2) {
                    gl = canvas.getContext("webgl2", attributes)
                } else if (webglVersion === 1) {
                    gl = canvas.getContext("webgl", attributes) || canvas.getContext("experimental-webgl", attributes)
                }
                if (webglVersion === 0 || gl == null) {
                    throw new Error("This browser does not support WebGL.")
                }
                return gl
            }

            exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;

            function callAndCheck(gl, func) {
                var returnValue = func();
                checkWebGLError(gl);
                return returnValue
            }

            exports.callAndCheck = callAndCheck;
            var webGLDebugErrorCheckingEnabled = false;

            function enableDebugWebGLErrorChecking(enabled) {
                webGLDebugErrorCheckingEnabled = enabled
            }

            exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;

            function checkWebGLError(gl) {
                if (webGLDebugErrorCheckingEnabled) {
                    var error = gl.getError();
                    if (error !== gl.NO_ERROR) {
                        throw new Error("WebGL Error: " + getWebGLErrorMessage(gl, error))
                    }
                }
            }

            exports.checkWebGLError = checkWebGLError;

            function getWebGLErrorMessage(gl, status) {
                switch (status) {
                    case gl.NO_ERROR:
                        return "NO_ERROR";
                    case gl.INVALID_ENUM:
                        return "INVALID_ENUM";
                    case gl.INVALID_VALUE:
                        return "INVALID_VALUE";
                    case gl.INVALID_OPERATION:
                        return "INVALID_OPERATION";
                    case gl.INVALID_FRAMEBUFFER_OPERATION:
                        return "INVALID_FRAMEBUFFER_OPERATION";
                    case gl.OUT_OF_MEMORY:
                        return "OUT_OF_MEMORY";
                    case gl.CONTEXT_LOST_WEBGL:
                        return "CONTEXT_LOST_WEBGL";
                    default:
                        return "Unknown error code " + status
                }
            }

            exports.getWebGLErrorMessage = getWebGLErrorMessage;

            function getExtensionOrThrow(gl, extensionName) {
                return throwIfNull(gl, function () {
                    return gl.getExtension(extensionName)
                }, 'Extension "' + extensionName + '" not supported on this browser.')
            }

            exports.getExtensionOrThrow = getExtensionOrThrow;

            function createVertexShader(gl, vertexShaderSource) {
                var vertexShader = throwIfNull(gl, function () {
                    return gl.createShader(gl.VERTEX_SHADER)
                }, "Unable to create vertex WebGLShader.");
                callAndCheck(gl, function () {
                    return gl.shaderSource(vertexShader, vertexShaderSource)
                });
                callAndCheck(gl, function () {
                    return gl.compileShader(vertexShader)
                });
                if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
                    console.log(gl.getShaderInfoLog(vertexShader));
                    throw new Error("Failed to compile vertex shader.")
                }
                return vertexShader
            }

            exports.createVertexShader = createVertexShader;

            function createFragmentShader(gl, fragmentShaderSource) {
                var fragmentShader = throwIfNull(gl, function () {
                    return gl.createShader(gl.FRAGMENT_SHADER)
                }, "Unable to create fragment WebGLShader.");
                callAndCheck(gl, function () {
                    return gl.shaderSource(fragmentShader, fragmentShaderSource)
                });
                callAndCheck(gl, function () {
                    return gl.compileShader(fragmentShader)
                });
                if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
                    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
                    throw new Error("Failed to compile fragment shader.")
                }
                return fragmentShader
            }

            exports.createFragmentShader = createFragmentShader;
            var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;

            function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
                var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
                if (lineNumberRegexResult == null) {
                    console.log("Couldn't parse line number in error: " + shaderInfoLog);
                    console.log(shaderSource);
                    return
                }
                var lineNumber = +lineNumberRegexResult[1];
                var shaderLines = shaderSource.split("\n");
                var pad = shaderLines.length.toString().length + 2;
                var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
                    return util.rightPad((lineNumber + 1).toString(), pad) + line
                });
                var maxLineLength = 0;
                for (var i = 0; i < linesWithLineNumbers.length; i++) {
                    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength)
                }
                var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
                var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
                var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
                console.log(beforeErrorLines.join("\n"));
                console.log(shaderInfoLog.split("\n")[0]);
                console.log("%c " + util.rightPad(errorLine[0], maxLineLength), "border:1px solid red; background-color:#e3d2d2; color:#a61717");
                console.log(afterErrorLines.join("\n"))
            }

            function createProgram(gl) {
                return throwIfNull(gl, function () {
                    return gl.createProgram()
                }, "Unable to create WebGLProgram.")
            }

            exports.createProgram = createProgram;

            function linkProgram(gl, program) {
                callAndCheck(gl, function () {
                    return gl.linkProgram(program)
                });
                if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
                    console.log(gl.getProgramInfoLog(program));
                    throw new Error("Failed to link vertex and fragment shaders.")
                }
            }

            exports.linkProgram = linkProgram;

            function validateProgram(gl, program) {
                callAndCheck(gl, function () {
                    return gl.validateProgram(program)
                });
                if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
                    console.log(gl.getProgramInfoLog(program));
                    throw new Error("Shader program validation failed.")
                }
            }

            exports.validateProgram = validateProgram;

            function createStaticVertexBuffer(gl, data) {
                var buffer = throwIfNull(gl, function () {
                    return gl.createBuffer()
                }, "Unable to create WebGLBuffer");
                callAndCheck(gl, function () {
                    return gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
                });
                callAndCheck(gl, function () {
                    return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
                });
                return buffer
            }

            exports.createStaticVertexBuffer = createStaticVertexBuffer;

            function createStaticIndexBuffer(gl, data) {
                var buffer = throwIfNull(gl, function () {
                    return gl.createBuffer()
                }, "Unable to create WebGLBuffer");
                callAndCheck(gl, function () {
                    return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)
                });
                callAndCheck(gl, function () {
                    return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW)
                });
                return buffer
            }

            exports.createStaticIndexBuffer = createStaticIndexBuffer;

            function queryMaxTextureSize(gl) {
                if (MAX_TEXTURE_SIZE != null) {
                    return MAX_TEXTURE_SIZE
                }
                MAX_TEXTURE_SIZE = callAndCheck(gl, function () {
                    return gl.getParameter(gl.MAX_TEXTURE_SIZE)
                });
                return MAX_TEXTURE_SIZE
            }

            exports.queryMaxTextureSize = queryMaxTextureSize;

            function getChannelsPerTexture() {
                if (!environment_1.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")) {
                    return 4
                }
                if (environment_1.ENV.get("WEBGL_VERSION") === 2) {
                    return 1
                }
                return 4
            }

            exports.getChannelsPerTexture = getChannelsPerTexture;

            function createTexture(gl) {
                return throwIfNull(gl, function () {
                    return gl.createTexture()
                }, "Unable to create WebGLTexture.")
            }

            exports.createTexture = createTexture;

            function validateTextureSize(gl, width, height) {
                var maxTextureSize = queryMaxTextureSize(gl);
                if (width <= 0 || height <= 0) {
                    var requested = "[" + width + "x" + height + "]";
                    throw new Error("Requested texture size " + requested + " is invalid.")
                }
                if (width > maxTextureSize || height > maxTextureSize) {
                    var requested = "[" + width + "x" + height + "]";
                    var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
                    throw new Error("Requested texture size " + requested + " greater than WebGL maximum on this browser / GPU " + max + ".")
                }
            }

            exports.validateTextureSize = validateTextureSize;

            function createFramebuffer(gl) {
                return throwIfNull(gl, function () {
                    return gl.createFramebuffer()
                }, "Unable to create WebGLFramebuffer.")
            }

            exports.createFramebuffer = createFramebuffer;

            function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
                var loc = gl.getAttribLocation(program, attribute);
                if (loc === -1) {
                    return false
                }
                callAndCheck(gl, function () {
                    return gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
                });
                callAndCheck(gl, function () {
                    return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes)
                });
                callAndCheck(gl, function () {
                    return gl.enableVertexAttribArray(loc)
                });
                return true
            }

            exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;

            function bindTextureUnit(gl, texture, textureUnit) {
                validateTextureUnit(gl, textureUnit);
                callAndCheck(gl, function () {
                    return gl.activeTexture(gl.TEXTURE0 + textureUnit)
                });
                callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, texture)
                })
            }

            exports.bindTextureUnit = bindTextureUnit;

            function unbindTextureUnit(gl, textureUnit) {
                validateTextureUnit(gl, textureUnit);
                callAndCheck(gl, function () {
                    return gl.activeTexture(gl.TEXTURE0 + textureUnit)
                });
                callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, null)
                })
            }

            exports.unbindTextureUnit = unbindTextureUnit;

            function getProgramUniformLocationOrThrow(gl, program, uniformName) {
                return throwIfNull(gl, function () {
                    return gl.getUniformLocation(program, uniformName)
                }, 'uniform "' + uniformName + '" not present in program.')
            }

            exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;

            function getProgramUniformLocation(gl, program, uniformName) {
                return gl.getUniformLocation(program, uniformName)
            }

            exports.getProgramUniformLocation = getProgramUniformLocation;

            function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
                callAndCheck(gl, function () {
                    return bindTextureUnit(gl, texture, textureUnit)
                });
                callAndCheck(gl, function () {
                    return gl.uniform1i(uniformSamplerLocation, textureUnit)
                })
            }

            exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;

            function bindCanvasToFramebuffer(gl) {
                callAndCheck(gl, function () {
                    return gl.bindFramebuffer(gl.FRAMEBUFFER, null)
                });
                callAndCheck(gl, function () {
                    return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
                });
                callAndCheck(gl, function () {
                    return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height)
                })
            }

            exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;

            function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
                callAndCheck(gl, function () {
                    return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer)
                });
                callAndCheck(gl, function () {
                    return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0)
                })
            }

            exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;

            function unbindColorTextureFromFramebuffer(gl, framebuffer) {
                callAndCheck(gl, function () {
                    return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer)
                });
                callAndCheck(gl, function () {
                    return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0)
                })
            }

            exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;

            function validateFramebuffer(gl) {
                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    throw new Error("Error binding framebuffer: " + getFramebufferErrorMessage(gl, status))
                }
            }

            exports.validateFramebuffer = validateFramebuffer;

            function getFramebufferErrorMessage(gl, status) {
                switch (status) {
                    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
                    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
                    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
                    case gl.FRAMEBUFFER_UNSUPPORTED:
                        return "FRAMEBUFFER_UNSUPPORTED";
                    default:
                        return "unknown error " + status
                }
            }

            exports.getFramebufferErrorMessage = getFramebufferErrorMessage;

            function throwIfNull(gl, returnTOrNull, failureMessage) {
                var tOrNull = callAndCheck(gl, function () {
                    return returnTOrNull()
                });
                if (tOrNull == null) {
                    throw new Error(failureMessage)
                }
                return tOrNull
            }

            function validateTextureUnit(gl, textureUnit) {
                var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
                var glTextureUnit = textureUnit + gl.TEXTURE0;
                if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
                    var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
                    throw new Error("textureUnit must be in " + textureUnitRange + ".")
                }
            }

            function getTextureShapeFromLogicalShape(gl, logShape) {
                if (logShape.length !== 2) {
                    var squeezeResult = util.squeezeShape(logShape);
                    logShape = squeezeResult.newShape
                }
                var maxTexSize = queryMaxTextureSize(gl);
                var size = util.sizeFromShape(logShape);
                if (logShape.length <= 1 && size <= maxTexSize) {
                    return [size, 1]
                } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {
                    return logShape
                } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {
                    return [logShape[0], logShape[1] * logShape[2]]
                } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
                    return [logShape[0], logShape[1] * logShape[2] * logShape[3]]
                } else {
                    return util.sizeToSquarishShape(size)
                }
            }

            exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape
        }, {"../../environment": 47, "../../util": 153}],
        101: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var tensor_1 = require("../tensor");
            var tensor_util = require("../tensor_util");
            var util = require("../util");
            var axis_util_1 = require("./axis_util");
            var concat_1 = require("./concat");
            var operation_1 = require("./operation");
            var rand_1 = require("./rand");
            var reduction_ops_1 = require("./reduction_ops");
            var ArrayOps = function () {
                function ArrayOps() {
                }

                ArrayOps.tensor = function (values, shape, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    var inferredShape = util.inferShape(values);
                    if (shape != null && inferredShape.length !== 1) {
                        util.assertShapesMatch(shape, inferredShape, "Error creating a new Tensor. " + ("Inferred shape (" + inferredShape + ") does not match the ") + ("provided shape (" + shape + "). "))
                    }
                    if (!util.isTypedArray(values) && !Array.isArray(values)) {
                        values = [values]
                    }
                    shape = shape || inferredShape;
                    return tensor_1.Tensor.make(shape, {values: toTypedArray(values, dtype)}, dtype)
                };
                ArrayOps.scalar = function (value, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    if (util.isTypedArray(value) || Array.isArray(value)) {
                        throw new Error("Error creating a new Scalar: value must be a primitive " + "(number|boolean)")
                    }
                    return ArrayOps.tensor(value, [], dtype)
                };
                ArrayOps.tensor1d = function (values, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    var inferredShape = util.inferShape(values);
                    if (inferredShape.length !== 1) {
                        throw new Error("tensor1d() requires values to be a flat/TypedArray")
                    }
                    return ArrayOps.tensor(values, inferredShape, dtype)
                };
                ArrayOps.tensor2d = function (values, shape, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    if (shape != null && shape.length !== 2) {
                        throw new Error("tensor2d() requires shape to have two numbers")
                    }
                    var inferredShape = util.inferShape(values);
                    if (inferredShape.length !== 2 && inferredShape.length !== 1) {
                        throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray")
                    }
                    if (inferredShape.length === 1 && shape == null) {
                        throw new Error("tensor2d() requires shape to be provided when `values` " + "are a flat/TypedArray")
                    }
                    shape = shape || inferredShape;
                    return ArrayOps.tensor(values, shape, dtype)
                };
                ArrayOps.tensor3d = function (values, shape, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    if (shape != null && shape.length !== 3) {
                        throw new Error("tensor3d() requires shape to have three numbers")
                    }
                    var inferredShape = util.inferShape(values);
                    if (inferredShape.length !== 3 && inferredShape.length !== 1) {
                        throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray")
                    }
                    if (inferredShape.length === 1 && shape == null) {
                        throw new Error("tensor3d() requires shape to be provided when `values` " + "are a flat array")
                    }
                    shape = shape || inferredShape;
                    return ArrayOps.tensor(values, shape, dtype)
                };
                ArrayOps.tensor4d = function (values, shape, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    if (shape != null && shape.length !== 4) {
                        throw new Error("tensor4d() requires shape to have four numbers")
                    }
                    var inferredShape = util.inferShape(values);
                    if (inferredShape.length !== 4 && inferredShape.length !== 1) {
                        throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray")
                    }
                    if (inferredShape.length === 1 && shape == null) {
                        throw new Error("tensor4d() requires shape to be provided when `values` " + "are a flat array")
                    }
                    shape = shape || inferredShape;
                    return ArrayOps.tensor(values, shape, dtype)
                };
                ArrayOps.ones = function (shape, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    var values = makeOnesTypedArray(util.sizeFromShape(shape), dtype);
                    return tensor_1.Tensor.make(shape, {values: values}, dtype)
                };
                ArrayOps.zeros = function (shape, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
                    return tensor_1.Tensor.make(shape, {values: values}, dtype)
                };
                ArrayOps.fill = function (shape, value, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    var values = util.getTypedArrayFromDType(dtype, util.sizeFromShape(shape));
                    values.fill(value);
                    return tensor_1.Tensor.make(shape, {values: values}, dtype)
                };
                ArrayOps.onesLike = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "onesLike");
                    return ArrayOps.ones(x.shape, x.dtype)
                };
                ArrayOps.zerosLike = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "zerosLike");
                    return ArrayOps.zeros(x.shape, x.dtype)
                };
                ArrayOps.clone = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "clone");
                    var der = function (dy) {
                        return {
                            x: function () {
                                return dy.toFloat()
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return tensor_1.Tensor.make(x.shape, {dataId: x.dataId}, x.dtype)
                    }, {x: x}, der)
                };
                ArrayOps.eye = function (numRows, numColumns, batchShape, dtype) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    if (numColumns == null) {
                        numColumns = numRows
                    }
                    var buffer = ArrayOps.buffer([numRows, numColumns], dtype);
                    var n = numRows <= numColumns ? numRows : numColumns;
                    for (var i = 0; i < n; ++i) {
                        buffer.set(1, i, i)
                    }
                    var out = buffer.toTensor().as2D(numRows, numColumns);
                    if (batchShape == null) {
                        return out
                    } else {
                        if (batchShape.length === 1) {
                            return ArrayOps.tile(ArrayOps.expandDims(out, 0), [batchShape[0], 1, 1])
                        } else if (batchShape.length === 2) {
                            return ArrayOps.tile(ArrayOps.expandDims(ArrayOps.expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1])
                        } else {
                            throw new Error("eye() currently supports only 1D and 2D " + ("batchShapes, but received " + batchShape.length + "D."))
                        }
                    }
                };
                ArrayOps.randomNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0
                    }
                    if (stdDev === void 0) {
                        stdDev = 1
                    }
                    if (dtype != null && dtype === "bool") {
                        throw new Error("Unsupported data type " + dtype)
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
                    var res = ArrayOps.buffer(shape, dtype);
                    for (var i = 0; i < res.values.length; i++) {
                        res.values[i] = randGauss.nextValue()
                    }
                    return res.toTensor()
                };
                ArrayOps.truncatedNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0
                    }
                    if (stdDev === void 0) {
                        stdDev = 1
                    }
                    if (dtype != null && dtype === "bool") {
                        throw new Error("Unsupported data type " + dtype)
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
                    var res = ArrayOps.buffer(shape, dtype);
                    for (var i = 0; i < res.values.length; i++) {
                        res.values[i] = randGauss.nextValue()
                    }
                    return res.toTensor()
                };
                ArrayOps.randomUniform = function (shape, minval, maxval, dtype) {
                    if (minval === void 0) {
                        minval = 0
                    }
                    if (maxval === void 0) {
                        maxval = 1
                    }
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    var res = ArrayOps.buffer(shape, dtype);
                    for (var i = 0; i < res.values.length; i++) {
                        res.values[i] = util.randUniform(minval, maxval)
                    }
                    return res.toTensor()
                };
                ArrayOps.rand = function (shape, randFunction, dtype) {
                    var size = util.sizeFromShape(shape);
                    var values = null;
                    if (dtype == null || dtype === "float32") {
                        values = new Float32Array(size)
                    } else if (dtype === "int32") {
                        values = new Int32Array(size)
                    } else if (dtype === "bool") {
                        values = new Uint8Array(size)
                    } else {
                        throw new Error("Unknown data type " + dtype)
                    }
                    for (var i = 0; i < size; i++) {
                        values[i] = randFunction()
                    }
                    return tensor_1.Tensor.make(shape, {values: values}, dtype)
                };
                ArrayOps.multinomial = function (logits, numSamples, seed, normalized) {
                    if (normalized === void 0) {
                        normalized = false
                    }
                    util.assertArgumentsAreTensors({logits: logits}, "multinomial");
                    var numOutcomes = logits.size;
                    var origRank = logits.rank;
                    if (numOutcomes < 2) {
                        throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + (numOutcomes + "."))
                    }
                    if (origRank > 2) {
                        throw new Error("Rank of probabilities must be 1 or 2, but is " + origRank)
                    }
                    seed = seed || Math.random();
                    var logits2D = origRank === 1 ? logits.as2D(1, -1) : logits;
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.multinomial(logits2D, normalized, numSamples, seed)
                    }, {logits2D: logits2D});
                    return origRank === 1 ? res.as1D() : res
                };
                ArrayOps.oneHot = function (indices, depth, onValue, offValue) {
                    if (onValue === void 0) {
                        onValue = 1
                    }
                    if (offValue === void 0) {
                        offValue = 0
                    }
                    util.assert(indices.dtype === "int32", "Indices must be of dtype `int32`");
                    if (depth < 2) {
                        throw new Error("Error in oneHot: depth must be >=2, but it is " + depth)
                    }
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.oneHot(indices, depth, onValue, offValue)
                    }, {indices: indices})
                };
                ArrayOps.fromPixels = function (pixels, numChannels) {
                    if (numChannels === void 0) {
                        numChannels = 3
                    }
                    if (numChannels > 4) {
                        throw new Error("Cannot construct Tensor with more than 4 channels from pixels.")
                    }
                    return environment_1.ENV.engine.fromPixels(pixels, numChannels)
                };
                ArrayOps.toPixels = function (img, canvas) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, height, width, depth, minTensor, maxTensor, min, max, data, multiplier, bytes, i, r, g,
                            b, a, j, ctx, imageData;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    util.assertArgumentsAreTensors({img: img}, "toPixels");
                                    if (img.rank !== 2 && img.rank !== 3) {
                                        throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + img.rank + ".")
                                    }
                                    _a = img.shape.slice(0, 2), height = _a[0], width = _a[1];
                                    depth = img.rank === 2 ? 1 : img.shape[2];
                                    if (depth > 4 || depth === 2) {
                                        throw new Error("toPixels only supports depth of size " + ("1, 3 or 4 but got " + depth))
                                    }
                                    minTensor = img.min();
                                    maxTensor = img.max();
                                    return [4, minTensor.data()];
                                case 1:
                                    min = _b.sent()[0];
                                    return [4, maxTensor.data()];
                                case 2:
                                    max = _b.sent()[0];
                                    minTensor.dispose();
                                    maxTensor.dispose();
                                    if (img.dtype === "float32") {
                                        if (min < 0 || max > 1) {
                                            throw new Error("Tensor values for a float32 Tensor must be in the " + ("range [0 - 1] but got range [" + min + " - " + max + "]."))
                                        }
                                    } else if (img.dtype === "int32") {
                                        if (min < 0 || max > 255) {
                                            throw new Error("Tensor values for a int32 Tensor must be in the " + ("range [0 - 255] but got range [" + min + " - " + max + "]."))
                                        }
                                    } else {
                                        throw new Error("Unsupported type for toPixels: " + img.dtype + "." + " Please use float32 or int32 tensors.")
                                    }
                                    return [4, img.data()];
                                case 3:
                                    data = _b.sent();
                                    multiplier = img.dtype === "float32" ? 255 : 1;
                                    bytes = new Uint8ClampedArray(width * height * 4);
                                    for (i = 0; i < height * width; ++i) {
                                        r = void 0, g = void 0, b = void 0, a = void 0;
                                        if (depth === 1) {
                                            r = data[i] * multiplier;
                                            g = data[i] * multiplier;
                                            b = data[i] * multiplier;
                                            a = 255
                                        } else if (depth === 3) {
                                            r = data[i * 3] * multiplier;
                                            g = data[i * 3 + 1] * multiplier;
                                            b = data[i * 3 + 2] * multiplier;
                                            a = 255
                                        } else if (depth === 4) {
                                            r = data[i * 4] * multiplier;
                                            g = data[i * 4 + 1] * multiplier;
                                            b = data[i * 4 + 2] * multiplier;
                                            a = data[i * 4 + 3] * multiplier
                                        }
                                        j = i * 4;
                                        bytes[j + 0] = Math.round(r);
                                        bytes[j + 1] = Math.round(g);
                                        bytes[j + 2] = Math.round(b);
                                        bytes[j + 3] = Math.round(a)
                                    }
                                    if (canvas != null) {
                                        canvas.width = width;
                                        canvas.height = height;
                                        ctx = canvas.getContext("2d");
                                        imageData = new ImageData(bytes, width, height);
                                        ctx.putImageData(imageData, 0, 0)
                                    }
                                    return [2, bytes]
                            }
                        })
                    })
                };
                ArrayOps.reshape = function (x, shape) {
                    util.assertArgumentsAreTensors({x: x}, "reshape");
                    shape = util.inferFromImplicitShape(shape, x.size);
                    util.assert(x.size === util.sizeFromShape(shape), "new shape and old shape must have the same number of elements.");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.reshape(x.shape)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.reshape(x, shape)
                    }, {x: x}, grad)
                };
                ArrayOps.squeeze = function (x, axis) {
                    util.assertArgumentsAreTensors({x: x}, "squeeze");
                    return ArrayOps.reshape(x, util.squeezeShape(x.shape, axis).newShape)
                };
                ArrayOps.cast = function (x, dtype) {
                    util.assertArgumentsAreTensors({x: x}, "cast");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.clone()
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.cast(x, dtype)
                    }, {x: x}, grad)
                };
                ArrayOps.tile = function (x, reps) {
                    util.assertArgumentsAreTensors({x: x}, "tile");
                    util.assert(x.rank === reps.length, "Error in transpose: rank of input " + x.rank + " " + ("must match length of reps " + reps + "."));
                    var grad = function (dy) {
                        var derX = function () {
                            var xGrad = ArrayOps.zerosLike(x);
                            if (x.rank === 1) {
                                for (var i = 0; i < reps[0]; ++i) {
                                    xGrad = xGrad.add(dy.slice([i * x.shape[0]], [x.shape[0]]))
                                }
                            } else if (x.rank === 2) {
                                for (var i = 0; i < reps[0]; ++i) {
                                    for (var j = 0; j < reps[1]; ++j) {
                                        xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1]], [x.shape[0], x.shape[1]]))
                                    }
                                }
                            } else if (x.rank === 3) {
                                for (var i = 0; i < reps[0]; ++i) {
                                    for (var j = 0; j < reps[1]; ++j) {
                                        for (var k = 0; k < reps[2]; ++k) {
                                            xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]))
                                        }
                                    }
                                }
                            } else if (x.rank === 4) {
                                for (var i = 0; i < reps[0]; ++i) {
                                    for (var j = 0; j < reps[1]; ++j) {
                                        for (var k = 0; k < reps[2]; ++k) {
                                            for (var l = 0; l < reps[3]; ++l) {
                                                xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1], k * x.shape[2], l * x.shape[3]], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]))
                                            }
                                        }
                                    }
                                }
                            } else {
                                throw new Error("Gradient for tile operation is not implemented for rank-" + (x.rank + " tensors yet."))
                            }
                            return xGrad
                        };
                        return {x: derX}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.tile(x, reps)
                    }, {x: x}, grad)
                };
                ArrayOps.gather = function (x, indices, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    util.assertArgumentsAreTensors({x: x, indices: indices}, "gather");
                    util.assert(indices.dtype === "int32", "Indices must be of dtype `int32`");
                    axis = axis_util_1.parseAxisParam(axis, x.shape)[0];
                    var grad = function (dy) {
                        var derX = function () {
                            return reduction_ops_1.ReductionOps.unsortedSegmentSum(dy, indices, x.shape[axis], axis)
                        };
                        return {x: derX}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.gather(x, indices, axis)
                    }, {x: x}, grad)
                };
                ArrayOps.pad1d = function (x, paddings, constantValue) {
                    if (constantValue === void 0) {
                        constantValue = 0
                    }
                    util.assert(paddings.length === 2, "Invalid number of paddings. Must be length of 2.");
                    return ArrayOps.pad(x, [paddings], constantValue)
                };
                ArrayOps.pad2d = function (x, paddings, constantValue) {
                    if (constantValue === void 0) {
                        constantValue = 0
                    }
                    util.assert(paddings.length === 2 && paddings[0].length === 2 && paddings[1].length === 2, "Invalid number of paddings. Must be length of 2 each.");
                    return ArrayOps.pad(x, paddings, constantValue)
                };
                ArrayOps.pad3d = function (x, paddings, constantValue) {
                    if (constantValue === void 0) {
                        constantValue = 0
                    }
                    util.assert(paddings.length === 3 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2, "Invalid number of paddings. Must be length of 2 each.");
                    return ArrayOps.pad(x, paddings, constantValue)
                };
                ArrayOps.pad4d = function (x, paddings, constantValue) {
                    if (constantValue === void 0) {
                        constantValue = 0
                    }
                    util.assert(paddings.length === 4 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2 && paddings[3].length === 2, "Invalid number of paddings. Must be length of 2 each.");
                    return ArrayOps.pad(x, paddings, constantValue)
                };
                ArrayOps.pad = function (x, paddings, constantValue) {
                    if (constantValue === void 0) {
                        constantValue = 0
                    }
                    util.assertArgumentsAreTensors({x: x}, "pad");
                    if (x.rank === 0) {
                        throw new Error("pad(scalar) is not defined. Pass non-scalar to pad")
                    }
                    var begin = paddings.map(function (p) {
                        return p[0]
                    });
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.slice(begin, x.shape)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.pad(x, paddings, constantValue)
                    }, {x: x}, grad)
                };
                ArrayOps.stack = function (tensors, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    util.assertArgumentsAreTensors({tensors: tensors}, "stack");
                    util.assert(tensors.length >= 1, "Pass at least one tensor to tf.stack");
                    if (tensors.length === 1) {
                        return tensors[0].expandDims(axis)
                    }
                    var rank = tensors[0].rank;
                    var shape = tensors[0].shape;
                    var dtype = tensors[0].dtype;
                    util.assert(axis <= rank, "Axis must be <= rank of the tensor");
                    tensors.forEach(function (t) {
                        util.assertShapesMatch(shape, t.shape, "All tensors passed to stack must have matching shapes")
                    });
                    tensors.forEach(function (t) {
                        util.assert(dtype === t.dtype, "All tensors passed to stack must have matching dtypes")
                    });
                    var expandedTensors = tensors.map(function (t) {
                        return t.expandDims(axis)
                    });
                    return concat_1.ConcatOps.concat(expandedTensors, axis)
                };
                ArrayOps.unstack = function (value, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    var num = value.shape[axis];
                    var outputShape = Array(value.rank - 1).fill(0);
                    var outIndex = 0;
                    for (var i = 0; i < value.rank; i++) {
                        if (i !== axis) {
                            outputShape[outIndex] = value.shape[i];
                            outIndex++
                        }
                    }
                    var splitSizes;
                    splitSizes = Array(num).fill(1);
                    var begin = Array(value.rank).fill(0);
                    var size = value.shape.slice();
                    return splitSizes.map(function (s) {
                        size[axis] = s;
                        var slice = value.slice(begin, size);
                        begin[axis] += s;
                        return slice.reshape(outputShape)
                    })
                };
                ArrayOps.split = function (x, numOrSizeSplits, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    util.assertArgumentsAreTensors({x: x}, "split");
                    axis = axis_util_1.parseAxisParam(axis, x.shape)[0];
                    var splitSizes;
                    if (typeof numOrSizeSplits === "number") {
                        util.assert(x.shape[axis] % numOrSizeSplits === 0, "Number of splits must evenly divide the axis.");
                        splitSizes = Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits)
                    } else {
                        util.assert(x.shape[axis] === numOrSizeSplits.reduce(function (a, b) {
                            return a + b
                        }), "The sum of sizes must match the size of the axis dimension.");
                        splitSizes = numOrSizeSplits
                    }
                    var begin = Array(x.rank).fill(0);
                    var size = x.shape.slice();
                    return splitSizes.map(function (s) {
                        size[axis] = s;
                        var slice = x.slice(begin, size);
                        begin[axis] += s;
                        return slice
                    })
                };
                ArrayOps.cumsum = function (x, axis, exclusive, reverse) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    if (exclusive === void 0) {
                        exclusive = false
                    }
                    if (reverse === void 0) {
                        reverse = false
                    }
                    util.assertArgumentsAreTensors({x: x}, "cumsum");
                    axis = axis | 0;
                    var permutation = axis_util_1.getAxesPermutation([axis], x.rank);
                    var permutedX = x;
                    if (permutation != null) {
                        permutedX = x.transpose(permutation)
                    }
                    var permutedAxis = axis_util_1.getInnerMostAxes(1, x.rank)[0];
                    var grad = function (dy) {
                        return {
                            permutedX: function () {
                                return dy.cumsum(axis, exclusive, !reverse)
                            }
                        }
                    };
                    var value = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.cumsum(permutedX, permutedAxis, exclusive, reverse)
                    }, {permutedX: permutedX}, grad);
                    if (permutation != null) {
                        value = value.transpose(permutation)
                    }
                    return value
                };
                ArrayOps.expandDims = function (x, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    util.assertArgumentsAreTensors({x: x}, "expandDims");
                    util.assert(axis <= x.rank, "Axis must be <= rank of the tensor");
                    var newShape = x.shape.slice();
                    newShape.splice(axis, 0, 1);
                    return ArrayOps.reshape(x, newShape)
                };
                ArrayOps.linspace = function (start, stop, num) {
                    if (num === 0) {
                        throw new Error("Cannot request zero samples")
                    }
                    var step = (stop - start) / (num - 1);
                    var values = makeZerosTypedArray(num, "float32");
                    values[0] = start;
                    for (var i = 1; i < values.length; i++) {
                        values[i] = values[i - 1] + step
                    }
                    return ArrayOps.tensor1d(values, "float32")
                };
                ArrayOps.range = function (start, stop, step, dtype) {
                    if (step === void 0) {
                        step = 1
                    }
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    if (step === 0) {
                        throw new Error("Cannot have a step of zero")
                    }
                    var sameStartStop = start === stop;
                    var increasingRangeNegativeStep = start < stop && step < 0;
                    var decreasingRangePositiveStep = stop < start && step > 1;
                    if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {
                        return ArrayOps.zeros([0], dtype)
                    }
                    var numElements = Math.abs(Math.ceil((stop - start) / step));
                    var values = makeZerosTypedArray(numElements, dtype);
                    if (stop < start && step === 1) {
                        step = -1
                    }
                    values[0] = start;
                    for (var i = 1; i < values.length; i++) {
                        values[i] = values[i - 1] + step
                    }
                    return ArrayOps.tensor1d(values, dtype)
                };
                ArrayOps.buffer = function (shape, dtype, values) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    return new tensor_1.TensorBuffer(shape, dtype, values)
                };
                ArrayOps.print = function (x, verbose) {
                    if (verbose === void 0) {
                        verbose = false
                    }
                    console.log(tensor_util.tensorToString(x, verbose))
                };
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], ArrayOps, "tensor", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], ArrayOps, "scalar", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], ArrayOps, "tensor1d", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], ArrayOps, "tensor2d", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], ArrayOps, "tensor3d", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], ArrayOps, "tensor4d", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "ones", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "zeros", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "fill", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "onesLike", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "zerosLike", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "clone", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "eye", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "randomNormal", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "truncatedNormal", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "randomUniform", null);
                __decorate([operation_1.operation], ArrayOps, "rand", null);
                __decorate([operation_1.operation], ArrayOps, "multinomial", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "oneHot", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                }), operation_1.operation], ArrayOps, "fromPixels", null);
                __decorate([doc_1.doc({heading: "Visualization"})], ArrayOps, "toPixels", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Transformations"
                }), operation_1.operation], ArrayOps, "reshape", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Transformations"})], ArrayOps, "squeeze", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Transformations"
                }), operation_1.operation], ArrayOps, "cast", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], ArrayOps, "tile", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], ArrayOps, "gather", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Transformations"
                }), operation_1.operation], ArrayOps, "pad", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], ArrayOps, "stack", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], ArrayOps, "unstack", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], ArrayOps, "split", null);
                __decorate([doc_1.doc({heading: "Operations", subheading: "Scan"})], ArrayOps, "cumsum", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Transformations"
                }), operation_1.operation], ArrayOps, "expandDims", null);
                __decorate([operation_1.operation, doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                })], ArrayOps, "linspace", null);
                __decorate([operation_1.operation, doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                })], ArrayOps, "range", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], ArrayOps, "buffer", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], ArrayOps, "print", null);
                return ArrayOps
            }();
            exports.ArrayOps = ArrayOps;

            function makeZerosTypedArray(size, dtype) {
                if (dtype == null || dtype === "float32") {
                    return new Float32Array(size)
                } else if (dtype === "int32") {
                    return new Int32Array(size)
                } else if (dtype === "bool") {
                    return new Uint8Array(size)
                } else {
                    throw new Error("Unknown data type $ {dtype}")
                }
            }

            function makeOnesTypedArray(size, dtype) {
                var array = makeZerosTypedArray(size, dtype);
                for (var i = 0; i < array.length; i++) {
                    array[i] = 1
                }
                return array
            }

            function toTypedArray(a, dtype) {
                if (noConversionNeeded(a, dtype)) {
                    return a
                }
                if (Array.isArray(a)) {
                    a = util.flatten(a)
                }
                return util.copyTypedArray(a, dtype)
            }

            function noConversionNeeded(a, dtype) {
                return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool"
            }
        }, {
            "../doc": 45,
            "../environment": 47,
            "../tensor": 147,
            "../tensor_util": 148,
            "../util": 153,
            "./axis_util": 102,
            "./concat": 107,
            "./operation": 121,
            "./rand": 124,
            "./reduction_ops": 126
        }],
        102: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../util");

            function axesAreInnerMostDims(axes, rank) {
                for (var i = 0; i < axes.length; ++i) {
                    if (axes[axes.length - i - 1] !== rank - 1 - i) {
                        return false
                    }
                }
                return true
            }

            exports.axesAreInnerMostDims = axesAreInnerMostDims;

            function combineLocations(outputLoc, reduceLoc, axes) {
                var rank = outputLoc.length + reduceLoc.length;
                var loc = [];
                var outIdx = 0;
                var reduceIdx = 0;
                for (var dim = 0; dim < rank; dim++) {
                    if (axes.indexOf(dim) === -1) {
                        loc.push(outputLoc[outIdx++])
                    } else {
                        loc.push(reduceLoc[reduceIdx++])
                    }
                }
                return loc
            }

            exports.combineLocations = combineLocations;

            function computeOutAndReduceShapes(aShape, axes) {
                var outShape = [];
                var rank = aShape.length;
                for (var dim = 0; dim < rank; dim++) {
                    if (axes.indexOf(dim) === -1) {
                        outShape.push(aShape[dim])
                    }
                }
                var reduceShape = axes.map(function (dim) {
                    return aShape[dim]
                });
                return [outShape, reduceShape]
            }

            exports.computeOutAndReduceShapes = computeOutAndReduceShapes;

            function expandShapeToKeepDim(shape, axes) {
                var reduceSubShape = axes.map(function (x) {
                    return 1
                });
                return combineLocations(shape, reduceSubShape, axes)
            }

            exports.expandShapeToKeepDim = expandShapeToKeepDim;

            function parseAxisParam(axis, shape) {
                var rank = shape.length;
                axis = axis == null ? shape.map(function (s, i) {
                    return i
                }) : [].concat(axis);
                util.assert(axis.every(function (ax) {
                    return ax >= -rank && ax < rank
                }), "All values in axis param must be in range [-" + rank + ", " + rank + ") but " + ("got axis " + axis));
                util.assert(axis.every(function (ax) {
                    return util.isInt(ax)
                }), "All values in axis param must be integers but " + ("got axis " + axis));
                return axis.map(function (a) {
                    return a < 0 ? rank + a : a
                })
            }

            exports.parseAxisParam = parseAxisParam;

            function assertAxesAreInnerMostDims(msg, axes, rank) {
                util.assert(axesAreInnerMostDims(axes, rank), msg + " supports only inner-most axes for now. " + ("Got axes " + axes + " and rank-" + rank + " input."))
            }

            exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;

            function getAxesPermutation(axes, rank) {
                if (axesAreInnerMostDims(axes, rank)) {
                    return null
                }
                var result = [];
                for (var i = 0; i < rank; ++i) {
                    if (axes.indexOf(i) === -1) {
                        result.push(i)
                    }
                }
                axes.forEach(function (axis) {
                    return result.push(axis)
                });
                return result
            }

            exports.getAxesPermutation = getAxesPermutation;

            function getUndoAxesPermutation(axes) {
                return axes.map(function (axis, i) {
                    return [i, axis]
                }).sort(function (a, b) {
                    return a[1] - b[1]
                }).map(function (x) {
                    return x[0]
                })
            }

            exports.getUndoAxesPermutation = getUndoAxesPermutation;

            function getInnerMostAxes(numAxes, rank) {
                var res = [];
                for (var i = rank - numAxes; i < rank; ++i) {
                    res.push(i)
                }
                return res
            }

            exports.getInnerMostAxes = getInnerMostAxes
        }, {"../util": 153}],
        103: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var array_ops_1 = require("./array_ops");
            var broadcast_util_1 = require("./broadcast_util");
            var operation_1 = require("./operation");
            var ops_1 = require("./ops");
            var BatchNormOps = function () {
                function BatchNormOps() {
                }

                BatchNormOps.batchNormalization2d = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    if (varianceEpsilon === void 0) {
                        varianceEpsilon = .001
                    }
                    util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " + (x.rank + "."));
                    util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " + ("got rank " + mean.rank + "."));
                    util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " + ("but got rank " + variance.rank + "."));
                    if (scale != null) {
                        util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " + ("but got rank " + scale.rank + "."))
                    }
                    if (offset != null) {
                        util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " + ("but got rank " + offset.rank + "."))
                    }
                    return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset)
                };
                BatchNormOps.batchNormalization3d = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    if (varianceEpsilon === void 0) {
                        varianceEpsilon = .001
                    }
                    util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " + (x.rank + "."));
                    util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " + ("got rank " + mean.rank + "."));
                    util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " + ("but got rank " + variance.rank + "."));
                    if (scale != null) {
                        util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " + ("but got rank " + scale.rank + "."))
                    }
                    if (offset != null) {
                        util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " + ("but got rank " + offset.rank + "."))
                    }
                    return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset)
                };
                BatchNormOps.batchNormalization4d = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    if (varianceEpsilon === void 0) {
                        varianceEpsilon = .001
                    }
                    util.assert(x.rank === 4, "Error in batchNormalization4D: x must be rank 4 but got rank " + (x.rank + "."));
                    util.assert(mean.rank === 4 || mean.rank === 1, "Error in batchNormalization4D: mean must be rank 4 or rank 1 but " + ("got rank " + mean.rank + "."));
                    util.assert(variance.rank === 4 || variance.rank === 1, "Error in batchNormalization4D: variance must be rank 4 or rank 1 " + ("but got rank " + variance.rank + "."));
                    if (scale != null) {
                        util.assert(scale.rank === 4 || scale.rank === 1, "Error in batchNormalization4D: scale must be rank 4 or rank 1 " + ("but got rank " + scale.rank + "."))
                    }
                    if (offset != null) {
                        util.assert(offset.rank === 4 || offset.rank === 1, "Error in batchNormalization4D: offset must be rank 4 or rank 1 " + ("but got rank " + offset.rank + "."))
                    }
                    return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset)
                };
                BatchNormOps.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    if (varianceEpsilon === void 0) {
                        varianceEpsilon = .001
                    }
                    util.assertArgumentsAreTensors({x: x, mean: mean, variance: variance}, "batchNormalization");
                    if (scale != null) {
                        util.assertArgumentsAreTensors({scale: scale}, "batchNormalization")
                    }
                    if (offset != null) {
                        util.assertArgumentsAreTensors({offset: offset}, "batchNormalization")
                    }
                    util.assert(mean.rank === variance.rank, "Batch normalization gradient requires mean and variance to have " + "equal ranks.");
                    util.assert(offset == null || mean.rank === offset.rank, "Batch normalization gradient requires mean and offset to have " + "equal ranks.");
                    util.assert(scale == null || mean.rank === scale.rank, "Batch normalization gradient requires mean and scale to have " + "equal ranks.");
                    var x4D;
                    if (x.rank === 0 || x.rank === 1) {
                        x4D = x.as4D(1, 1, 1, x.size)
                    } else if (x.rank === 2) {
                        x4D = x.as4D(1, 1, x.shape[0], x.shape[1])
                    } else if (x.rank === 3) {
                        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                    } else {
                        x4D = x
                    }
                    var der = function (dy) {
                        var scaleValue = scale == null ? array_ops_1.ArrayOps.scalar(1) : scale;
                        var reductionAxes = broadcast_util_1.getReductionAxes(mean.shape, x4D.shape);
                        var tileShape = [];
                        if (mean.rank === 1) {
                            for (var i = 0; i < x4D.shape.length - 1; ++i) {
                                tileShape.push(x4D.shape[i])
                            }
                            tileShape.push(1)
                        }
                        var xMinusMean = x.sub(mean);
                        var dyTimesScaleValue = dy.mul(scaleValue);
                        var oneOverSqrtVariance = ops_1.rsqrt(variance.add(array_ops_1.ArrayOps.scalar(varianceEpsilon)));
                        var minusHalfRCube = oneOverSqrtVariance.mul(oneOverSqrtVariance).mul(oneOverSqrtVariance).mul(array_ops_1.ArrayOps.scalar(-.5));
                        var derX = function () {
                            if (mean.rank === 1) {
                                return dy.mul(array_ops_1.ArrayOps.tile(oneOverSqrtVariance.as4D(1, 1, 1, mean.shape[0]), tileShape)).mul(scaleValue).reshape(x.shape)
                            } else {
                                return dy.mul(oneOverSqrtVariance).mul(scaleValue).reshape(x.shape)
                            }
                        };
                        var derMean = function () {
                            var meanDer = oneOverSqrtVariance.mul(array_ops_1.ArrayOps.scalar(-1)).mul(dyTimesScaleValue);
                            if (mean.rank === 1) {
                                meanDer = meanDer.sum(reductionAxes)
                            }
                            return meanDer.reshape(mean.shape)
                        };
                        var derVariance = function () {
                            var varianceDer = minusHalfRCube.mul(xMinusMean).mul(dyTimesScaleValue);
                            if (mean.rank === 1) {
                                varianceDer = varianceDer.sum(reductionAxes)
                            }
                            return varianceDer.reshape(mean.shape)
                        };
                        var derScale = function () {
                            var xMinusMean2TimesRsqrt = xMinusMean.mul(oneOverSqrtVariance);
                            var scaleDer = dy.mul(xMinusMean2TimesRsqrt);
                            if (mean.rank === 1) {
                                scaleDer = scaleDer.sum(reductionAxes)
                            }
                            return scaleDer.reshape(mean.shape)
                        };
                        var derOffset = function () {
                            var offsetDer = dy;
                            if (mean.rank === 1) {
                                offsetDer = offsetDer.sum(reductionAxes)
                            }
                            return offsetDer.reshape(mean.shape)
                        };
                        return {x: derX, mean: derMean, variance: derVariance, scale: derScale, offset: derOffset}
                    };
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.batchNormalization(x4D, batchnormReshape4D(mean), batchnormReshape4D(variance), varianceEpsilon, batchnormReshape4D(scale), batchnormReshape4D(offset))
                    }, {x: x, mean: mean, variance: variance, scale: scale, offset: offset}, der);
                    return res.reshape(x.shape)
                };
                __decorate([operation_1.operation], BatchNormOps, "batchNormalization2d", null);
                __decorate([operation_1.operation], BatchNormOps, "batchNormalization3d", null);
                __decorate([operation_1.operation], BatchNormOps, "batchNormalization4d", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Normalization"
                })], BatchNormOps, "batchNormalization", null);
                return BatchNormOps
            }();
            exports.BatchNormOps = BatchNormOps;

            function batchnormReshape4D(x) {
                if (x == null) {
                    return null
                }
                if (x.rank === 0) {
                    return x.as1D()
                } else if (x.rank === 1) {
                    return x
                } else if (x.rank === 2) {
                    return x.as4D(1, 1, x.shape[0], x.shape[1])
                } else if (x.rank === 3) {
                    return x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                }
                return x
            }
        }, {
            "../doc": 45,
            "../environment": 47,
            "../util": 153,
            "./array_ops": 101,
            "./broadcast_util": 105,
            "./operation": 121,
            "./ops": 122
        }],
        104: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var types_1 = require("../types");
            var util = require("../util");
            var broadcast_util = require("./broadcast_util");
            var operation_1 = require("./operation");
            var ops_1 = require("./ops");
            var BinaryOps = function () {
                function BinaryOps() {
                }

                BinaryOps.add = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "add");
                    util.assertTypesMatch(a, b);
                    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var derA = function () {
                            var res = dy;
                            var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes)
                            }
                            return res.reshape(a.shape)
                        };
                        var derB = function () {
                            var res = dy;
                            var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes)
                            }
                            return res.reshape(b.shape)
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.add(a, b)
                    }, {a: a, b: b}, der)
                };
                BinaryOps.addStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in addStrict: ");
                    return a.add(b)
                };
                BinaryOps.sub = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "sub");
                    util.assertTypesMatch(a, b);
                    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var derA = function () {
                            var res = dy;
                            var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes)
                            }
                            return res.reshape(a.shape)
                        };
                        var derB = function () {
                            var res = dy;
                            var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes)
                            }
                            return res.neg().reshape(b.shape)
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.subtract(a, b)
                    }, {a: a, b: b}, der)
                };
                BinaryOps.subStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in subStrict: ");
                    return a.sub(b)
                };
                BinaryOps.pow = function (base, exp) {
                    util.assertArgumentsAreTensors({base: base, exp: exp}, "pow");
                    var outShape = broadcast_util.assertAndGetBroadcastShape(base.shape, exp.shape);
                    base = base.cast(types_1.upcastType(base.dtype, exp.dtype));
                    exp = exp.cast(types_1.upcastType(base.dtype, exp.dtype));
                    var grad = function (dy, saved) {
                        var y = saved[0];
                        var derBase = function () {
                            var res = dy.mul(exp.toFloat().mul(y.div(base)));
                            var reduceAxes = broadcast_util.getReductionAxes(base.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes)
                            }
                            return res.reshape(base.shape)
                        };
                        var derExp = function () {
                            var res = dy.mul(y.mul(base.log()).toFloat());
                            var reduceAxes = broadcast_util.getReductionAxes(exp.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes)
                            }
                            return res.reshape(exp.shape)
                        };
                        return {base: derBase, exp: derExp}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend, save) {
                        return save(backend.pow(base, exp))
                    }, {base: base, exp: exp}, grad)
                };
                BinaryOps.powStrict = function (base, exp) {
                    util.assertShapesMatch(base.shape, exp.shape, "Error in powStrict: ");
                    return base.pow(exp)
                };
                BinaryOps.mul = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "mul");
                    util.assertTypesMatch(a, b);
                    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var derA = function () {
                            var res = dy.mul(b.toFloat());
                            var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                            if (reduceAxes.length > 0) {
                                return res.sum(reduceAxes).reshape(a.shape)
                            }
                            return res
                        };
                        var derB = function () {
                            var res = dy.mul(a.toFloat());
                            var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                            if (reduceAxes.length > 0) {
                                return res.sum(reduceAxes).reshape(b.shape)
                            }
                            return res
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.multiply(a, b)
                    }, {a: a, b: b}, der)
                };
                BinaryOps.mulStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in multiplyStrict: ");
                    return a.mul(b)
                };
                BinaryOps.div = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "div");
                    util.assertTypesMatch(a, b);
                    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var derA = function () {
                            var res = dy.div(b.toFloat());
                            var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                            if (reduceAxes.length > 0) {
                                return res.sum(reduceAxes).reshape(a.shape)
                            }
                            return res
                        };
                        var derB = function () {
                            var res = dy.mul(a.toFloat());
                            var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes).reshape(b.shape)
                            }
                            var tmp = b.square();
                            return res.div(tmp.toFloat()).neg()
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.divide(a, b)
                    }, {a: a, b: b}, der)
                };
                BinaryOps.divStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in divideStrict: ");
                    return a.div(b)
                };
                BinaryOps.mod = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "mod");
                    util.assertTypesMatch(a, b);
                    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var derA = function () {
                            var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                            if (reduceAxes.length > 0) {
                                return dy.sum(reduceAxes).reshape(a.shape)
                            }
                            return dy
                        };
                        var derB = function () {
                            var res = dy.mul(a.div(b).floor().neg());
                            var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                            if (reduceAxes.length > 0) {
                                return res.sum(reduceAxes).reshape(b.shape)
                            }
                            return res
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.mod(a, b)
                    }, {a: a, b: b}, der)
                };
                BinaryOps.modStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in modStrict: ");
                    return a.mod(b)
                };
                BinaryOps.minimum = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "minimum");
                    util.assertTypesMatch(a, b);
                    if (a.dtype === "bool") {
                        a = a.toInt()
                    }
                    if (b.dtype === "bool") {
                        b = b.toInt()
                    }
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var derA = function () {
                            return dy.mul(a.lessEqual(b).toFloat())
                        };
                        var derB = function () {
                            return dy.mul(a.greater(b).toFloat())
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.minimum(a, b)
                    }, {a: a, b: b}, der)
                };
                BinaryOps.minimumStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in minimumStrict: ");
                    return a.minimum(b)
                };
                BinaryOps.maximum = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "maximum");
                    util.assertTypesMatch(a, b);
                    if (a.dtype === "bool") {
                        a = a.toInt()
                    }
                    if (b.dtype === "bool") {
                        b = b.toInt()
                    }
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var derA = function () {
                            return dy.mul(a.greaterEqual(b).toFloat())
                        };
                        var derB = function () {
                            return dy.mul(a.less(b).toFloat())
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.maximum(a, b)
                    }, {a: a, b: b}, der)
                };
                BinaryOps.maximumStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in minimumStrict: ");
                    return a.maximum(b)
                };
                BinaryOps.squaredDifference = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "squaredDifference");
                    util.assertTypesMatch(a, b);
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var two = ops_1.scalar(2);
                        var derA = function () {
                            return dy.mul(a.sub(b).mul(two))
                        };
                        var derB = function () {
                            return dy.mul(b.sub(a).mul(two))
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.squaredDifference(a, b)
                    }, {a: a, b: b}, der)
                };
                BinaryOps.squaredDifferenceStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in squaredDifferenceStrict: ");
                    return a.squaredDifference(b)
                };
                BinaryOps.atan2 = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "atan2");
                    util.assertTypesMatch(a, b);
                    var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var der = function (dy) {
                        var derA = function () {
                            var d = BinaryOps.add(ops_1.square(a), ops_1.square(b));
                            var res = dy.mul(b.div(d));
                            var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes)
                            }
                            return res.reshape(a.shape)
                        };
                        var derB = function () {
                            var d = BinaryOps.add(ops_1.square(a), ops_1.square(b));
                            var res = ops_1.neg(dy.mul(a.div(d)));
                            var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                            if (reduceAxes.length > 0) {
                                res = res.sum(reduceAxes)
                            }
                            return res.reshape(b.shape)
                        };
                        return {a: derA, b: derB}
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.atan2(a, b)
                    }, {a: a, b: b}, der)
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "add", null);
                __decorate([operation_1.operation], BinaryOps, "addStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "sub", null);
                __decorate([operation_1.operation], BinaryOps, "subStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "pow", null);
                __decorate([operation_1.operation], BinaryOps, "powStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "mul", null);
                __decorate([operation_1.operation], BinaryOps, "mulStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "div", null);
                __decorate([operation_1.operation], BinaryOps, "divStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "mod", null);
                __decorate([operation_1.operation], BinaryOps, "modStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "minimum", null);
                __decorate([operation_1.operation], BinaryOps, "minimumStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "maximum", null);
                __decorate([operation_1.operation], BinaryOps, "maximumStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Arithmetic"
                }), operation_1.operation], BinaryOps, "squaredDifference", null);
                __decorate([operation_1.operation], BinaryOps, "squaredDifferenceStrict", null);
                __decorate([operation_1.operation], BinaryOps, "atan2", null);
                return BinaryOps
            }();
            exports.BinaryOps = BinaryOps
        }, {
            "../doc": 45,
            "../environment": 47,
            "../types": 152,
            "../util": 153,
            "./broadcast_util": 105,
            "./operation": 121,
            "./ops": 122
        }],
        105: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function getBroadcastDims(inShape, outShape) {
                var inRank = inShape.length;
                var dims = [];
                for (var i = 0; i < inRank; i++) {
                    var dim = inRank - 1 - i;
                    var a = inShape[dim] || 1;
                    var b = outShape[outShape.length - 1 - i] || 1;
                    if (b > 1 && a === 1) {
                        dims.unshift(dim)
                    }
                }
                return dims
            }

            exports.getBroadcastDims = getBroadcastDims;

            function getReductionAxes(inShape, outShape) {
                var result = [];
                for (var i = 0; i < outShape.length; i++) {
                    var inDim = inShape[inShape.length - i - 1];
                    var outAxis = outShape.length - i - 1;
                    var outDim = outShape[outAxis];
                    if (inDim == null || inDim === 1 && outDim > 1) {
                        result.unshift(outAxis)
                    }
                }
                return result
            }

            exports.getReductionAxes = getReductionAxes;

            function broadcastDimsAreOuter(dims) {
                for (var i = 0; i < dims.length; i++) {
                    if (dims[i] !== i) {
                        return false
                    }
                }
                return true
            }

            exports.broadcastDimsAreOuter = broadcastDimsAreOuter;

            function assertAndGetBroadcastShape(shapeA, shapeB) {
                var result = [];
                var errMsg = "Operands could not be broadcast together with shapes " + (shapeA + " and " + shapeB + ".");
                var l = Math.max(shapeA.length, shapeB.length);
                for (var i = 0; i < l; i++) {
                    var a = shapeA[shapeA.length - i - 1] || 1;
                    var b = shapeB[shapeB.length - i - 1] || 1;
                    if (a > 1 && b > 1 && a !== b) {
                        throw Error(errMsg)
                    }
                    result.unshift(Math.max(a, b))
                }
                return result
            }

            exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape
        }, {}],
        106: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var broadcast_util = require("./broadcast_util");
            var operation_1 = require("./operation");
            var CompareOps = function () {
                function CompareOps() {
                }

                CompareOps.notEqual = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "notEqual");
                    util.assertTypesMatch(a, b);
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.notEqual(a, b)
                    }, {a: a, b: b})
                };
                CompareOps.notEqualStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in notEqualStrict: ");
                    return a.notEqual(b)
                };
                CompareOps.less = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "less");
                    util.assertTypesMatch(a, b);
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.less(a, b)
                    }, {a: a, b: b})
                };
                CompareOps.lessStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in lessStrict: ");
                    return a.less(b)
                };
                CompareOps.equal = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "equal");
                    util.assertTypesMatch(a, b);
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.equal(a, b)
                    }, {a: a, b: b})
                };
                CompareOps.equalStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in equalStrict: ");
                    return a.equal(b)
                };
                CompareOps.lessEqual = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "lessEqual");
                    util.assertTypesMatch(a, b);
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.lessEqual(a, b)
                    }, {a: a, b: b})
                };
                CompareOps.lessEqualStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in lessEqualStrict: ");
                    return a.lessEqual(b)
                };
                CompareOps.greater = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "greater");
                    util.assertTypesMatch(a, b);
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.greater(a, b)
                    }, {a: a, b: b})
                };
                CompareOps.greaterStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in greaterStrict: ");
                    return a.greater(b)
                };
                CompareOps.greaterEqual = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "greaterEqual");
                    util.assertTypesMatch(a, b);
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.greaterEqual(a, b)
                    }, {a: a, b: b})
                };
                CompareOps.greaterEqualStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, "Error in greaterEqualStrict: ");
                    return a.greaterEqual(b)
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], CompareOps, "notEqual", null);
                __decorate([operation_1.operation], CompareOps, "notEqualStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], CompareOps, "less", null);
                __decorate([operation_1.operation], CompareOps, "lessStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], CompareOps, "equal", null);
                __decorate([operation_1.operation], CompareOps, "equalStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], CompareOps, "lessEqual", null);
                __decorate([operation_1.operation], CompareOps, "lessEqualStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], CompareOps, "greater", null);
                __decorate([operation_1.operation], CompareOps, "greaterStrict", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], CompareOps, "greaterEqual", null);
                __decorate([operation_1.operation], CompareOps, "greaterEqualStrict", null);
                return CompareOps
            }();
            exports.CompareOps = CompareOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./broadcast_util": 105, "./operation": 121}],
        107: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var axis_util_1 = require("./axis_util");
            var concat_util = require("./concat_util");
            var operation_1 = require("./operation");
            var ConcatOps = function () {
                function ConcatOps() {
                }

                ConcatOps.concat1d = function (tensors) {
                    return ConcatOps.concat(tensors, 0)
                };
                ConcatOps.concat2d = function (tensors, axis) {
                    return ConcatOps.concat(tensors, axis)
                };
                ConcatOps.concat3d = function (tensors, axis) {
                    return ConcatOps.concat(tensors, axis)
                };
                ConcatOps.concat4d = function (tensors, axis) {
                    return ConcatOps.concat(tensors, axis)
                };
                ConcatOps.concat = function (tensors, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    util.assert(tensors.length >= 1, "Pass at least one tensor to concat");
                    util.assertArgumentsAreTensors({tensors: tensors}, "concat");
                    var result = tensors[0];
                    if (tensors.length === 1) {
                        return result
                    }
                    var axes = axis_util_1.parseAxisParam(axis, result.shape);
                    for (var i = 1; i < tensors.length; ++i) {
                        result = concat2Tensors(result, tensors[i], axes[0])
                    }
                    return result
                };
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], ConcatOps, "concat", null);
                return ConcatOps
            }();
            exports.ConcatOps = ConcatOps;

            function concat2Tensors(a, b, axis) {
                concat_util.assertParams(a.shape, b.shape, axis);
                var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
                var a2D = a.as2D(-1, util.sizeFromShape(a.shape.slice(axis)));
                var b2D = b.as2D(-1, util.sizeFromShape(b.shape.slice(axis)));
                var _a = concat_util.computeGradientSliceShapes(a2D.shape, b2D.shape), aBegin = _a.aBegin,
                    aSize = _a.aSize, bBegin = _a.bBegin, bSize = _a.bSize;
                var der = function (dy) {
                    return {
                        a: function () {
                            return dy.slice(aBegin, aSize)
                        }, b: function () {
                            return dy.slice(bBegin, bSize)
                        }
                    }
                };
                var res = environment_1.ENV.engine.runKernel(function (backend) {
                    return backend.concat(a2D, b2D)
                }, {a: a2D, b: b2D}, der);
                return res.reshape(outShape)
            }
        }, {
            "../doc": 45,
            "../environment": 47,
            "../util": 153,
            "./axis_util": 102,
            "./concat_util": 108,
            "./operation": 121
        }],
        108: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../util");

            function assertParams(aShape, bShape, axis) {
                var aRank = aShape.length;
                var bRank = bShape.length;
                util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " + "must be the same.");
                util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " + ("between 0 and " + (aRank - 1) + "."));
                for (var i = 0; i < aRank; i++) {
                    util.assert(i === axis || aShape[i] === bShape[i], "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " + ("(" + bShape + ") along the non-concatenated axis " + i + "."))
                }
            }

            exports.assertParams = assertParams;

            function computeOutShape1D(x1Shape, x2Shape) {
                util.assert(x1Shape.length === 1 && x2Shape.length === 1, "x1 and x2 should be 1d array.");
                var outputShape = x1Shape.slice();
                outputShape[0] += x2Shape[0];
                return outputShape
            }

            exports.computeOutShape1D = computeOutShape1D;

            function computeOutShape(x1Shape, x2Shape, axis) {
                util.assert(x1Shape.length === x2Shape.length, "x1 and x2 should have the same rank.");
                var outputShape = x1Shape.slice();
                outputShape[axis] += x2Shape[axis];
                return outputShape
            }

            exports.computeOutShape = computeOutShape;

            function computeGradientSliceShapes(aShape, bShape) {
                return {aBegin: [0, 0], aSize: aShape, bBegin: [0, aShape[1]], bSize: bShape}
            }

            exports.computeGradientSliceShapes = computeGradientSliceShapes
        }, {"../util": 153}],
        109: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var conv_util = require("./conv_util");
            var operation_1 = require("./operation");
            var ConvOps = function () {
                function ConvOps() {
                }

                ConvOps.conv1d = function (x, filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
                    if (dataFormat === void 0) {
                        dataFormat = "NWC"
                    }
                    if (dilation === void 0) {
                        dilation = 1
                    }
                    util.assertArgumentsAreTensors({x: x, filter: filter}, "conv1d");
                    var x3D = x;
                    var reshapedTo3D = false;
                    if (x.rank === 2) {
                        reshapedTo3D = true;
                        x3D = x.as3D(1, x.shape[0], x.shape[1])
                    }
                    util.assert(x3D.rank === 3, "Error in conv1d: input must be rank 3, but got rank " + x3D.rank + ".");
                    util.assert(filter.rank === 3, "Error in conv1d: filter must be rank 3, but got rank " + (filter.rank + "."));
                    if (dimRoundingMode != null) {
                        util.assert(util.isInt(pad), "Error in conv1d: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."))
                    }
                    util.assert(x3D.shape[2] === filter.shape[1], "Error in conv1d: depth of input (" + x3D.shape[2] + ") must match " + ("input depth for filter " + filter.shape[1] + "."));
                    util.assert(eitherStridesOrDilationsAreOne(stride, dilation), "Error in conv1D: Either stride or dilation must be 1. " + ("Got stride " + stride + " and dilation '" + dilation + "'"));
                    util.assert(dataFormat === "NWC", "Error in conv1d: got dataFormat of " + dataFormat + " but only NWC is currently supported.");
                    var filter4D = filter.as4D(1, filter.shape[0], filter.shape[1], filter.shape[2]);
                    var input4D = x3D.as4D(x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]);
                    var strides = [1, stride];
                    var dilations = [1, dilation];
                    var conv2dDataFormat = "NHWC";
                    var res = ConvOps.conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);
                    if (reshapedTo3D) {
                        return res.as2D(res.shape[2], res.shape[3])
                    }
                    return res.as3D(res.shape[0], res.shape[2], res.shape[3])
                };
                ConvOps.conv2d = function (x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
                    if (dataFormat === void 0) {
                        dataFormat = "NHWC"
                    }
                    if (dilations === void 0) {
                        dilations = [1, 1]
                    }
                    util.assertArgumentsAreTensors({x: x, filter: filter}, "conv2d");
                    var x4D = x;
                    var reshapedTo4D = false;
                    if (x.rank === 3) {
                        reshapedTo4D = true;
                        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                    }
                    util.assert(x4D.rank === 4, "Error in conv2d: input must be rank 4, but got rank " + x4D.rank + ".");
                    util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " + (filter.rank + "."));
                    if (dimRoundingMode != null) {
                        util.assert(util.isInt(pad), "Error in conv2d: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."))
                    }
                    util.assert(x4D.shape[3] === filter.shape[2], "Error in conv2d: depth of input (" + x4D.shape[3] + ") must match " + ("input depth for filter " + filter.shape[2] + "."));
                    util.assert(eitherStridesOrDilationsAreOne(strides, dilations), "Error in conv2D: Either strides or dilations must be 1. " + ("Got strides " + strides + " and dilations '" + dilations + "'"));
                    util.assert(dataFormat === "NHWC", "Error in conv2d: got dataFormat of " + dataFormat + " but only NHWC is currently supported.");
                    var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode);
                    var grad = function (dy) {
                        util.assert(tupleValuesAreOne(dilations), "Error in gradient of conv2D: dilation rates greater than 1 are not" + ("yet supported in gradients. Got dilations '" + dilations + "'"));
                        return {
                            x: function () {
                                return ConvOps.conv2dDerInput(x4D.shape, dy, filter, strides, pad)
                            }, filter: function () {
                                return ConvOps.conv2dDerFilter(x4D, dy, filter.shape, strides, pad)
                            }
                        }
                    };
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.conv2d(x4D, filter, convInfo)
                    }, {x: x4D, filter: filter}, grad);
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                ConvOps.conv2dDerInput = function (xShape, dy, filter, strides, pad, dimRoundingMode) {
                    util.assertArgumentsAreTensors({dy: dy, filter: filter}, "conv2dDerInput");
                    util.assert(xShape.length === dy.rank, "Length of inShape " + ("(" + xShape.length + ") and rank of dy (" + dy.rank + ") must match"));
                    var xShape4D = xShape;
                    var dy4D = dy;
                    var reshapedTo4D = false;
                    if (dy.rank === 3) {
                        reshapedTo4D = true;
                        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
                        xShape4D = [1, xShape[0], xShape[1], xShape[2]]
                    }
                    var inDepth = xShape4D[3];
                    var outDepth = dy4D.shape[3];
                    util.assert(xShape4D.length === 4, "Error in conv2dDerInput: inShape must be length 4, but got length " + (xShape4D.length + "."));
                    util.assert(dy4D.rank === 4, "Error in conv2dDerInput: dy must be rank 4, but got " + ("rank " + dy4D.rank));
                    util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " + ("rank " + filter.rank));
                    util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " + ("match input depth for filter " + filter.shape[2] + "."));
                    util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must " + ("match output depth for filter " + filter.shape[3] + "."));
                    if (dimRoundingMode != null) {
                        util.assert(util.isInt(pad), "Error in conv2dDerInput: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."))
                    }
                    var dilations = 1;
                    var convInfo = conv_util.computeConv2DInfo(xShape4D, filter.shape, strides, dilations, pad, dimRoundingMode);
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.conv2dDerInput(dy4D, filter, convInfo)
                    }, {dy4D: dy4D});
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                ConvOps.conv2dDerFilter = function (x, dy, filterShape, strides, pad, dimRoundingMode) {
                    util.assertArgumentsAreTensors({x: x, dy: dy}, "conv2dDerFilter");
                    var x4D = x;
                    if (x.rank === 3) {
                        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                    }
                    var dy4D = dy;
                    if (dy4D.rank === 3) {
                        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2])
                    }
                    util.assert(x4D.rank === 4, "Error in conv2dDerFilter: input must be rank 4, but got shape " + (x4D.shape + "."));
                    util.assert(dy4D.rank === 4, "Error in conv2dDerFilter: dy must be rank 4, but got shape " + (dy4D.shape + "."));
                    util.assert(filterShape.length === 4, "Error in conv2dDerFilter: filterShape must be length 4, but got " + (filterShape + "."));
                    util.assert(x4D.shape[3] === filterShape[2], "Error in conv2dDerFilter: depth of input " + x4D.shape[3] + ") must " + ("match input depth in filter (" + filterShape[2] + "."));
                    util.assert(dy4D.shape[3] === filterShape[3], "Error in conv2dDerFilter: depth of dy (" + dy4D.shape[3] + ") must " + ("match output depth for filter (" + filterShape[3] + ")."));
                    if (dimRoundingMode != null) {
                        util.assert(util.isInt(pad), "Error in conv2dDerFilter: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."))
                    }
                    var dilations = 1;
                    var convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.conv2dDerFilter(x4D, dy4D, convInfo)
                    }, {x4D: x4D, dy4D: dy4D})
                };
                ConvOps.conv2dTranspose = function (x, filter, outputShape, strides, pad, dimRoundingMode) {
                    util.assertArgumentsAreTensors({x: x, filter: filter}, "conv2dTranspose");
                    return ConvOps.conv2dDerInput(outputShape, x, filter, strides, pad, dimRoundingMode)
                };
                ConvOps.depthwiseConv2d = function (x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
                    if (dataFormat === void 0) {
                        dataFormat = "NHWC"
                    }
                    if (dilations === void 0) {
                        dilations = [1, 1]
                    }
                    util.assertArgumentsAreTensors({x: x, filter: filter}, "depthwiseConv2d");
                    var x4D = x;
                    var reshapedTo4D = false;
                    if (x.rank === 3) {
                        reshapedTo4D = true;
                        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                    }
                    util.assert(x4D.rank === 4, "Error in depthwiseConv2D: input must be rank 4, but got " + ("rank " + x4D.rank + "."));
                    util.assert(filter.rank === 4, "Error in depthwiseConv2D: filter must be rank 4, but got rank " + (filter.rank + "."));
                    util.assert(x4D.shape[3] === filter.shape[2], "Error in depthwiseConv2D: number of input channels " + ("(" + x4D.shape[3] + ") must match the inChannels dimension in ") + ("filter " + filter.shape[2] + "."));
                    if (dilations == null) {
                        dilations = [1, 1]
                    }
                    util.assert(eitherStridesOrDilationsAreOne(strides, dilations), "Error in depthwiseConv2d: Either strides or dilations must be 1. " + ("Got strides " + strides + " and dilations '" + dilations + "'"));
                    if (dimRoundingMode != null) {
                        util.assert(util.isInt(pad), "Error in depthwiseConv2D: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."))
                    }
                    var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode, true);
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.depthwiseConv2D(x4D, filter, convInfo)
                    }, {x4D: x4D, filter: filter});
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                ConvOps.separableConv2d = function (x, depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat) {
                    if (dilation === void 0) {
                        dilation = [1, 1]
                    }
                    if (dataFormat === void 0) {
                        dataFormat = "NHWC"
                    }
                    util.assertArgumentsAreTensors({
                        x: x,
                        depthwiseFilter: depthwiseFilter,
                        pointwiseFilter: pointwiseFilter
                    }, "separableConv2d");
                    var x4D = x;
                    var reshapedTo4D = false;
                    if (x.rank === 3) {
                        reshapedTo4D = true;
                        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                    }
                    if (dataFormat === "NCHW") {
                        throw new Error("separableConv2d currently does not support dataFormat NCHW; only " + "NHWC is supported")
                    }
                    util.assert(x4D.rank === 4, "Error in separableConv2d: input must be rank 4, but got " + ("rank " + x4D.rank + "."));
                    util.assert(depthwiseFilter.rank === 4, "Error in separableConv2d: depthwise filter must be rank 4, but got " + ("rank " + depthwiseFilter.rank + "."));
                    util.assert(pointwiseFilter.rank === 4, "Error in separableConv2d: pointwise filter must be rank 4, but got " + ("rank " + depthwiseFilter.rank + "."));
                    util.assert(pointwiseFilter.shape[0] === 1, "Error in separableConv2d: the first dimension of pointwise filter " + (" must be 1, but got " + pointwiseFilter.shape[0] + "."));
                    util.assert(pointwiseFilter.shape[1] === 1, "Error in separableConv2d: the second dimension of pointwise filter " + (" must be 1, but got " + pointwiseFilter.shape[1] + "."));
                    var inChannels = depthwiseFilter.shape[2];
                    var channelMultiplier = depthwiseFilter.shape[3];
                    util.assert(pointwiseFilter.shape[2] === inChannels * channelMultiplier, "Error in separableConv2d: the third dimension of pointwise filter " + ("must be " + inChannels * channelMultiplier + ", ") + ("but got " + pointwiseFilter.shape[2] + "."));
                    var depthwise = ConvOps.depthwiseConv2d(x4D, depthwiseFilter, strides, pad, dataFormat, dilation);
                    var pointwiseStride = 1;
                    var res = ConvOps.conv2d(depthwise, pointwiseFilter, pointwiseStride, "valid", dataFormat);
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Convolution"
                }), operation_1.operation], ConvOps, "conv1d", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Convolution"
                }), operation_1.operation], ConvOps, "conv2d", null);
                __decorate([operation_1.operation], ConvOps, "conv2dDerInput", null);
                __decorate([operation_1.operation], ConvOps, "conv2dDerFilter", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Convolution"
                }), operation_1.operation], ConvOps, "conv2dTranspose", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Convolution"
                }), operation_1.operation], ConvOps, "depthwiseConv2d", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Convolution"
                }), operation_1.operation], ConvOps, "separableConv2d", null);
                return ConvOps
            }();
            exports.ConvOps = ConvOps;

            function parseTupleParam(param) {
                return typeof param === "number" ? [param, param] : param
            }

            function tupleValuesAreOne(param) {
                var _a = parseTupleParam(param), dimA = _a[0], dimB = _a[1];
                return dimA === 1 && dimB === 1
            }

            function eitherStridesOrDilationsAreOne(strides, dilations) {
                return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations)
            }
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./conv_util": 110, "./operation": 121}],
        110: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../util");

            function computePool2DInfo(inShape, filterSize, strides, pad, roundingMode, dataFormat) {
                if (dataFormat === void 0) {
                    dataFormat = "channelsLast"
                }
                var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
                var filterShape;
                if (dataFormat === "channelsLast") {
                    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]]
                } else if (dataFormat === "channelsFirst") {
                    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]]
                } else {
                    throw new Error("Unknown dataFormat " + dataFormat)
                }
                var dilations = 1;
                return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat)
            }

            exports.computePool2DInfo = computePool2DInfo;

            function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise, dataFormat) {
                if (depthwise === void 0) {
                    depthwise = false
                }
                if (dataFormat === void 0) {
                    dataFormat = "channelsLast"
                }
                var _a = [-1, -1, -1, -1], batchSize = _a[0], inHeight = _a[1], inWidth = _a[2], inChannels = _a[3];
                if (dataFormat === "channelsLast") {
                    batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3]
                } else if (dataFormat === "channelsFirst") {
                    batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3]
                } else {
                    throw new Error("Unknown dataFormat " + dataFormat)
                }
                var filterHeight = filterShape[0], filterWidth = filterShape[1], filterChannels = filterShape[3];
                var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
                var _c = parseTupleParam(dilations), dilationHeight = _c[0], dilationWidth = _c[1];
                var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
                var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
                var _d = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode),
                    padInfo = _d.padInfo, outHeight = _d.outHeight, outWidth = _d.outWidth;
                var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
                var outShape;
                if (dataFormat === "channelsFirst") {
                    outShape = [batchSize, outChannels, outHeight, outWidth]
                } else if (dataFormat === "channelsLast") {
                    outShape = [batchSize, outHeight, outWidth, outChannels]
                }
                return {
                    batchSize: batchSize,
                    dataFormat: dataFormat,
                    inHeight: inHeight,
                    inWidth: inWidth,
                    inChannels: inChannels,
                    outHeight: outHeight,
                    outWidth: outWidth,
                    outChannels: outChannels,
                    padInfo: padInfo,
                    strideHeight: strideHeight,
                    strideWidth: strideWidth,
                    filterHeight: filterHeight,
                    filterWidth: filterWidth,
                    dilationHeight: dilationHeight,
                    dilationWidth: dilationWidth,
                    inShape: inShape,
                    outShape: outShape,
                    filterShape: filterShape
                }
            }

            exports.computeConv2DInfo = computeConv2DInfo;

            function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad, roundingMode) {
                if (zeroPad == null) {
                    zeroPad = computeDefaultPad(inShape, fieldSize, stride)
                }
                var inputRows = inShape[0];
                var inputCols = inShape[1];
                var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
                util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " + "stride and/or zero pad parameters");
                var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
                util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " + "the stride and/or zero pad parameters");
                return [outputRows, outputCols, outDepth]
            }

            function computeDefaultPad(inputShape, fieldSize, stride, dilation) {
                if (dilation === void 0) {
                    dilation = 1
                }
                var effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
                return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2)
            }

            exports.computeDefaultPad = computeDefaultPad;

            function parseTupleParam(param) {
                return typeof param === "number" ? [param, param] : param
            }

            function getEffectiveFilterSize(filterSize, dilation) {
                if (dilation <= 1) {
                    return filterSize
                }
                return filterSize + (filterSize - 1) * (dilation - 1)
            }

            function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode) {
                var padInfo;
                var outHeight;
                var outWidth;
                if (typeof pad === "number") {
                    var padType = pad === 0 ? "VALID" : "NUMBER";
                    padInfo = {top: pad, bottom: pad, left: pad, right: pad, type: padType};
                    var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad, roundingMode);
                    outHeight = outShape[0];
                    outWidth = outShape[1]
                } else if (pad === "same") {
                    outHeight = Math.ceil(inHeight / strideHeight);
                    outWidth = Math.ceil(inWidth / strideWidth);
                    var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
                    var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
                    var top_1 = Math.floor(padAlongHeight / 2);
                    var bottom = padAlongHeight - top_1;
                    var left = Math.floor(padAlongWidth / 2);
                    var right = padAlongWidth - left;
                    padInfo = {top: top_1, bottom: bottom, left: left, right: right, type: "SAME"}
                } else if (pad === "valid") {
                    padInfo = {top: 0, bottom: 0, left: 0, right: 0, type: "VALID"};
                    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
                    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth)
                } else {
                    throw Error("Unknown padding parameter: " + pad)
                }
                return {padInfo: padInfo, outHeight: outHeight, outWidth: outWidth}
            }

            function conditionalRound(value, roundingMode) {
                if (!roundingMode) {
                    return value
                }
                switch (roundingMode) {
                    case"round":
                        return Math.round(value);
                    case"ceil":
                        return Math.ceil(value);
                    case"floor":
                        return Math.floor(value);
                    default:
                        throw new Error("Unknown roundingMode " + roundingMode)
                }
            }
        }, {"../util": 153}],
        111: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.ERF_P = .3275911;
            exports.ERF_A1 = .254829592;
            exports.ERF_A2 = -.284496736;
            exports.ERF_A3 = 1.421413741;
            exports.ERF_A4 = -1.453152027;
            exports.ERF_A5 = 1.061405429
        }, {}],
        112: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var operation_1 = require("./operation");
            var ImageOps = function () {
                function ImageOps() {
                }

                ImageOps.resizeBilinear = function (images, size, alignCorners) {
                    if (alignCorners === void 0) {
                        alignCorners = false
                    }
                    util.assertArgumentsAreTensors({images: images}, "resizeBilinear");
                    util.assert(images.rank === 3 || images.rank === 4, "Error in resizeBilinear: x must be rank 3 or 4, but got " + ("rank " + images.rank + "."));
                    util.assert(size.length === 2, "Error in resizeBilinear: new shape must 2D, but got shape " + (size + "."));
                    var batchImages = images;
                    var reshapedTo4D = false;
                    if (images.rank === 3) {
                        reshapedTo4D = true;
                        batchImages = images.as4D(1, images.shape[0], images.shape[1], images.shape[2])
                    }
                    var newHeight = size[0], newWidth = size[1];
                    var forward = function (backend, save) {
                        return backend.resizeBilinear(batchImages, newHeight, newWidth, alignCorners)
                    };
                    var backward = function (dy, saved) {
                        return {
                            batchImages: function () {
                                return environment_1.ENV.engine.runKernel(function (backend) {
                                    return backend.resizeBilinearBackprop(dy, batchImages, alignCorners)
                                }, {})
                            }
                        }
                    };
                    var res = environment_1.ENV.engine.runKernel(forward, {batchImages: batchImages}, backward);
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                ImageOps.resizeNearestNeighbor = function (images, size, alignCorners) {
                    if (alignCorners === void 0) {
                        alignCorners = false
                    }
                    util.assertArgumentsAreTensors({images: images}, "resizeNearestNeighbor");
                    util.assert(images.rank === 3 || images.rank === 4, "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got " + ("rank " + images.rank + "."));
                    util.assert(size.length === 2, "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + (size + "."));
                    util.assert(images.dtype === "float32" || images.dtype === "int32", "`images` must have `int32` or `float32` as dtype");
                    var batchImages = images;
                    var reshapedTo4D = false;
                    if (images.rank === 3) {
                        reshapedTo4D = true;
                        batchImages = images.as4D(1, images.shape[0], images.shape[1], images.shape[2])
                    }
                    var newHeight = size[0], newWidth = size[1];
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.resizeNearestNeighbor(batchImages, newHeight, newWidth, alignCorners)
                    }, {batchImages: batchImages});
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Images",
                    namespace: "image"
                }), operation_1.operation], ImageOps, "resizeBilinear", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Images",
                    namespace: "image"
                }), operation_1.operation], ImageOps, "resizeNearestNeighbor", null);
                return ImageOps
            }();
            exports.ImageOps = ImageOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./operation": 121}],
        113: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var tracking_1 = require("../tracking");
            var util_1 = require("../util");
            var operation_1 = require("./operation");
            var ops_1 = require("./ops");
            var LinalgOps = function () {
                function LinalgOps() {
                }

                LinalgOps.gramSchmidt = function (xs) {
                    var inputIsTensor2D;
                    if (Array.isArray(xs)) {
                        inputIsTensor2D = false;
                        util_1.assert(xs != null && xs.length > 0, "Gram-Schmidt process: input must not be null, undefined, or empty");
                        var dim = xs[0].shape[0];
                        for (var i = 1; i < xs.length; ++i) {
                            util_1.assert(xs[i].shape[0] === dim, "Gram-Schmidt: Non-unique lengths found in the input vectors: " + ("(" + xs[i].shape[0] + " vs. " + dim + ")"))
                        }
                    } else {
                        inputIsTensor2D = true;
                        xs = ops_1.split(xs, xs.shape[0], 0).map(function (x) {
                            return ops_1.squeeze(x, [0])
                        })
                    }
                    util_1.assert(xs.length <= xs[0].shape[0], "Gram-Schmidt: Number of vectors (" + xs.length + ") exceeds " + ("number of dimensions (" + xs[0].shape[0] + ")."));
                    var ys = [];
                    var xs1d = xs;
                    var _loop_1 = function (i) {
                        ys.push(tracking_1.Tracking.tidy(function () {
                            var x = xs1d[i];
                            if (i > 0) {
                                for (var j = 0; j < i; ++j) {
                                    var proj = ops_1.sum(ys[j].mulStrict(x)).mul(ys[j]);
                                    x = x.sub(proj)
                                }
                            }
                            return x.div(ops_1.norm(x, "euclidean"))
                        }))
                    };
                    for (var i = 0; i < xs.length; ++i) {
                        _loop_1(i)
                    }
                    if (inputIsTensor2D) {
                        return ops_1.stack(ys, 0)
                    } else {
                        return ys
                    }
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Linear Algebra"
                }), operation_1.operation], LinalgOps, "gramSchmidt", null);
                return LinalgOps
            }();
            exports.LinalgOps = LinalgOps
        }, {"../doc": 45, "../tracking": 150, "../util": 153, "./operation": 121, "./ops": 122}],
        114: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var types = require("../types");
            var util = require("../util");
            var broadcast_util = require("./broadcast_util");
            var operation_1 = require("./operation");
            var LogicalOps = function () {
                function LogicalOps() {
                }

                LogicalOps.logicalNot = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "logicalNot");
                    util.assert(x.dtype === "bool", "Error Array must be of type bool.");
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.logicalNot(x)
                    }, {x: x})
                };
                LogicalOps.logicalAnd = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "logicalAnd");
                    util.assert(a.dtype === "bool" && b.dtype === "bool", "Error Array must be of type bool.");
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.logicalAnd(a, b)
                    }, {a: a, b: b})
                };
                LogicalOps.logicalOr = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "logicalOr");
                    util.assert(a.dtype === "bool" && b.dtype === "bool", "Error Array must be of type bool.");
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.logicalOr(a, b)
                    }, {a: a, b: b})
                };
                LogicalOps.logicalXor = function (a, b) {
                    util.assertArgumentsAreTensors({a: a, b: b}, "logicalXor");
                    util.assert(a.dtype === "bool" && b.dtype === "bool", "Error Array must be of type bool.");
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return LogicalOps.logicalOr(a, b).logicalAnd(LogicalOps.logicalAnd(a, b).logicalNot())
                };
                LogicalOps.where = function (condition, a, b) {
                    util.assertArgumentsAreTensors({condition: condition, a: a, b: b}, "where");
                    util.assert(condition.dtype === "bool" || a.dtype === "bool" || b.dtype === "bool", "Error Array must be of type bool.");
                    util.assertShapesMatch(a.shape, b.shape, "Error in where: ");
                    if (condition.rank === 1) {
                        util.assert(condition.shape[0] === a.shape[0], "The first dimension of `a` must match the size of `condition`.")
                    } else {
                        util.assertShapesMatch(condition.shape, b.shape, "Error in where: ")
                    }
                    var dtype = types.upcastType(a.dtype, b.dtype);
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.where(condition, a, b, dtype)
                    }, {condition: condition, a: a, b: b})
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], LogicalOps, "logicalNot", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], LogicalOps, "logicalAnd", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], LogicalOps, "logicalOr", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], LogicalOps, "logicalXor", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Logical"
                }), operation_1.operation], LogicalOps, "where", null);
                return LogicalOps
            }();
            exports.LogicalOps = LogicalOps
        }, {
            "../doc": 45,
            "../environment": 47,
            "../types": 152,
            "../util": 153,
            "./broadcast_util": 105,
            "./operation": 121
        }],
        115: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var util = require("../util");
            var operation_1 = require("./operation");
            var ops = require("./ops");
            var Reduction;
            (function (Reduction) {
                Reduction[Reduction["NONE"] = 0] = "NONE";
                Reduction[Reduction["MEAN"] = 1] = "MEAN";
                Reduction[Reduction["SUM"] = 2] = "SUM";
                Reduction[Reduction["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS"
            })(Reduction = exports.Reduction || (exports.Reduction = {}));
            var LossOps = function () {
                function LossOps() {
                }

                LossOps.computeWeightedLoss = function (losses, weights, reduction) {
                    if (reduction === void 0) {
                        reduction = Reduction.SUM_BY_NONZERO_WEIGHTS
                    }
                    util.assertArgumentsAreTensors({losses: losses}, "computeWeightedLoss");
                    if (weights != null) {
                        util.assertArgumentsAreTensors({weights: weights}, "computeWeightedLoss")
                    }
                    var weightedLoss = weights == null ? losses : losses.mul(weights);
                    if (reduction === Reduction.NONE) {
                        return weightedLoss
                    }
                    if (reduction === Reduction.SUM) {
                        return weightedLoss.sum()
                    }
                    if (reduction === Reduction.MEAN) {
                        return weights == null ? weightedLoss.mean() : weightedLoss.sum().div(weights.sum())
                    }
                    if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {
                        if (weights == null) {
                            return weightedLoss.sum().div(ops.scalar(losses.size))
                        } else {
                            var numNonZeros = weights.notEqual(ops.scalar(0)).sum().toFloat();
                            return weightedLoss.sum().div(numNonZeros)
                        }
                    }
                    throw Error("Unknown reduction: " + reduction)
                };
                LossOps.absoluteDifference = function (labels, predictions, weights, reduction) {
                    if (reduction === void 0) {
                        reduction = Reduction.SUM_BY_NONZERO_WEIGHTS
                    }
                    util.assertArgumentsAreTensors({labels: labels, predictions: predictions}, "absoluteDifference");
                    if (weights != null) {
                        util.assertArgumentsAreTensors({weights: weights}, "absoluteDifference")
                    }
                    util.assertShapesMatch(labels.shape, predictions.shape, "Error in absoluteDifference: ");
                    var losses = labels.sub(predictions).abs();
                    return LossOps.computeWeightedLoss(losses, weights, reduction)
                };
                LossOps.meanSquaredError = function (labels, predictions, weights, reduction) {
                    if (reduction === void 0) {
                        reduction = Reduction.SUM_BY_NONZERO_WEIGHTS
                    }
                    util.assertArgumentsAreTensors({labels: labels, predictions: predictions}, "meanSquaredError");
                    if (weights != null) {
                        util.assertArgumentsAreTensors({weights: weights}, "meanSquaredError")
                    }
                    util.assertShapesMatch(labels.shape, predictions.shape, "Error in meanSquaredError: ");
                    var losses = labels.squaredDifference(predictions);
                    return LossOps.computeWeightedLoss(losses, weights, reduction)
                };
                LossOps.cosineDistance = function (labels, predictions, axis, weights, reduction) {
                    if (reduction === void 0) {
                        reduction = Reduction.SUM_BY_NONZERO_WEIGHTS
                    }
                    util.assertArgumentsAreTensors({labels: labels, predictions: predictions}, "cosineDistance");
                    if (weights != null) {
                        util.assertArgumentsAreTensors({weights: weights}, "cosineDistance")
                    }
                    util.assertShapesMatch(labels.shape, predictions.shape, "Error in cosineDistance: ");
                    var one = ops.scalar(1);
                    var losses = one.sub(labels.mul(predictions).sum(axis, true));
                    return LossOps.computeWeightedLoss(losses, weights, reduction)
                };
                LossOps.hingeLoss = function (labels, predictions, weights, reduction) {
                    if (reduction === void 0) {
                        reduction = Reduction.SUM_BY_NONZERO_WEIGHTS
                    }
                    util.assertArgumentsAreTensors({labels: labels, predictions: predictions}, "hingeLoss");
                    if (weights != null) {
                        util.assertArgumentsAreTensors({weights: weights}, "hingeLoss")
                    }
                    util.assertShapesMatch(labels.shape, predictions.shape, "Error in hingeLoss: ");
                    var one = ops.scalar(1);
                    labels = ops.scalar(2).mul(labels).sub(one);
                    var losses = one.sub(labels.mul(predictions)).relu();
                    return LossOps.computeWeightedLoss(losses, weights, reduction)
                };
                LossOps.logLoss = function (labels, predictions, weights, epsilon, reduction) {
                    if (epsilon === void 0) {
                        epsilon = 1e-7
                    }
                    if (reduction === void 0) {
                        reduction = Reduction.SUM_BY_NONZERO_WEIGHTS
                    }
                    util.assertArgumentsAreTensors({labels: labels, predictions: predictions}, "logLoss");
                    if (weights != null) {
                        util.assertArgumentsAreTensors({weights: weights}, "logLoss")
                    }
                    util.assertShapesMatch(labels.shape, predictions.shape, "Error in logLoss: ");
                    var one = ops.scalar(1);
                    var epsilonScalar = ops.scalar(epsilon);
                    var losses = labels.mul(predictions.add(epsilonScalar).log()).neg().sub(one.sub(labels).mul(one.sub(predictions).add(epsilonScalar).log()));
                    return LossOps.computeWeightedLoss(losses, weights, reduction)
                };
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Losses",
                    namespace: "losses"
                }), operation_1.operation], LossOps, "computeWeightedLoss", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Losses",
                    namespace: "losses"
                }), operation_1.operation], LossOps, "absoluteDifference", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Losses",
                    namespace: "losses"
                }), operation_1.operation], LossOps, "meanSquaredError", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Losses",
                    namespace: "losses"
                }), operation_1.operation], LossOps, "cosineDistance", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Losses",
                    namespace: "losses"
                }), operation_1.operation], LossOps, "hingeLoss", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Losses",
                    namespace: "losses"
                }), operation_1.operation], LossOps, "logLoss", null);
                return LossOps
            }();
            exports.LossOps = LossOps
        }, {"../doc": 45, "../util": 153, "./operation": 121, "./ops": 122}],
        116: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var operation_1 = require("./operation");
            var LRNOps = function () {
                function LRNOps() {
                }

                LRNOps.localResponseNormalization = function (x, radius, bias, alpha, beta) {
                    if (radius === void 0) {
                        radius = 5
                    }
                    if (bias === void 0) {
                        bias = 1
                    }
                    if (alpha === void 0) {
                        alpha = 1
                    }
                    if (beta === void 0) {
                        beta = .5
                    }
                    util.assertArgumentsAreTensors({x: x}, "localResponseNormalization");
                    util.assert(x.rank === 4 || x.rank === 3, "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + x.rank + ".");
                    util.assert(util.isInt(radius), "Error in localResponseNormalization3D: radius must be an integer\n                     but got radius " + radius + ".");
                    var x4D = x;
                    var reshapedTo4D = false;
                    if (x.rank === 3) {
                        reshapedTo4D = true;
                        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                    }
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.localResponseNormalization4D(x4D, radius, bias, alpha, beta)
                    }, {x4D: x4D});
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    } else {
                        return res
                    }
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Normalization"
                }), operation_1.operation], LRNOps, "localResponseNormalization", null);
                return LRNOps
            }();
            exports.LRNOps = LRNOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./operation": 121}],
        117: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var util = require("../util");
            var operation_1 = require("./operation");
            var LSTMOps = function () {
                function LSTMOps() {
                }

                LSTMOps.multiRNNCell = function (lstmCells, data, c, h) {
                    util.assertArgumentsAreTensors({data: data, c: c, h: h}, "multiRNNCell");
                    var input = data;
                    var newStates = [];
                    for (var i = 0; i < lstmCells.length; i++) {
                        var output = lstmCells[i](input, c[i], h[i]);
                        newStates.push(output[0]);
                        newStates.push(output[1]);
                        input = output[1]
                    }
                    var newC = [];
                    var newH = [];
                    for (var i = 0; i < newStates.length; i += 2) {
                        newC.push(newStates[i]);
                        newH.push(newStates[i + 1])
                    }
                    return [newC, newH]
                };
                LSTMOps.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
                    util.assertArgumentsAreTensors({
                        forgetBias: forgetBias,
                        lstmKernel: lstmKernel,
                        lstmBias: lstmBias,
                        data: data,
                        c: c,
                        h: h
                    }, "basicLSTMCell");
                    var combined = data.concat(h, 1);
                    var weighted = combined.matMul(lstmKernel);
                    var res = weighted.add(lstmBias);
                    var batchSize = res.shape[0];
                    var sliceCols = res.shape[1] / 4;
                    var sliceSize = [batchSize, sliceCols];
                    var i = res.slice([0, 0], sliceSize);
                    var j = res.slice([0, sliceCols], sliceSize);
                    var f = res.slice([0, sliceCols * 2], sliceSize);
                    var o = res.slice([0, sliceCols * 3], sliceSize);
                    var newC = i.sigmoid().mulStrict(j.tanh()).addStrict(c.mulStrict(forgetBias.add(f).sigmoid()));
                    var newH = newC.tanh().mulStrict(o.sigmoid());
                    return [newC, newH]
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "RNN"
                }), operation_1.operation], LSTMOps, "multiRNNCell", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "RNN"
                }), operation_1.operation], LSTMOps, "basicLSTMCell", null);
                return LSTMOps
            }();
            exports.LSTMOps = LSTMOps
        }, {"../doc": 45, "../util": 153, "./operation": 121}],
        118: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var operation_1 = require("./operation");
            var MatmulOps = function () {
                function MatmulOps() {
                }

                MatmulOps.matMul = function (a, b, transposeA, transposeB) {
                    if (transposeA === void 0) {
                        transposeA = false
                    }
                    if (transposeB === void 0) {
                        transposeB = false
                    }
                    util.assertArgumentsAreTensors({a: a, b: b}, "matMul");
                    var innerShapeA = transposeA ? a.shape[0] : a.shape[1];
                    var innerShapeB = transposeB ? b.shape[1] : b.shape[0];
                    util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank + (" and " + b.rank + "."));
                    util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" + (innerShapeB + ") of Tensors with shapes " + a.shape + " and ") + (b.shape + " and transposeA=" + transposeA) + (" and transposeB=" + transposeB + " must match."));
                    var grad = function (dy) {
                        if (!transposeA && !transposeB) {
                            return {
                                a: function () {
                                    return dy.matMul(b.toFloat(), false, true)
                                }, b: function () {
                                    return a.toFloat().matMul(dy, true, false)
                                }
                            }
                        } else if (!transposeA && transposeB) {
                            return {
                                a: function () {
                                    return dy.matMul(b.toFloat(), false, false)
                                }, b: function () {
                                    return dy.matMul(a.toFloat(), true, false)
                                }
                            }
                        } else if (transposeA && !transposeB) {
                            return {
                                a: function () {
                                    return b.toFloat().matMul(dy, false, true)
                                }, b: function () {
                                    return a.toFloat().matMul(dy, false, false)
                                }
                            }
                        } else {
                            return {
                                a: function () {
                                    return b.toFloat().matMul(dy, true, true)
                                }, b: function () {
                                    return dy.matMul(a.toFloat(), true, true)
                                }
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.matMul(a, b, transposeA, transposeB)
                    }, {a: a, b: b}, grad)
                };
                MatmulOps.vectorTimesMatrix = function (v, matrix) {
                    util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " + ("rank " + v.rank + "."));
                    util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " + ("rank " + matrix.rank + "."));
                    util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " + ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
                    return v.as2D(1, -1).matMul(matrix).as1D()
                };
                MatmulOps.matrixTimesVector = function (matrix, v) {
                    util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " + ("rank " + v.rank + "."));
                    util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " + ("rank " + matrix.rank + "."));
                    util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " + "must match inner dimension of second rank 2 input, but got " + ("shape " + matrix.shape + "."));
                    return matrix.matMul(v.as2D(-1, 1)).as1D()
                };
                MatmulOps.dotProduct = function (v1, v2) {
                    util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " + (v1.rank + " and " + v2.rank + "."));
                    util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" + (v2.size + ") must match."));
                    return v1.as2D(1, -1).matMul(v2.as2D(-1, 1)).asScalar()
                };
                MatmulOps.outerProduct = function (v1, v2) {
                    util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " + (v1.rank + " and " + v2.rank + "."));
                    return v1.as2D(-1, 1).matMul(v2.as2D(1, -1))
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Matrices"
                }), operation_1.operation], MatmulOps, "matMul", null);
                __decorate([operation_1.operation], MatmulOps, "vectorTimesMatrix", null);
                __decorate([operation_1.operation], MatmulOps, "matrixTimesVector", null);
                __decorate([operation_1.operation], MatmulOps, "dotProduct", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Matrices"
                }), operation_1.operation], MatmulOps, "outerProduct", null);
                return MatmulOps
            }();
            exports.MatmulOps = MatmulOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./operation": 121}],
        119: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var util = require("../util");
            var array_ops_1 = require("./array_ops");
            var binary_ops_1 = require("./binary_ops");
            var operation_1 = require("./operation");
            var MovingAverageOps = function () {
                function MovingAverageOps() {
                }

                MovingAverageOps.movingAverage = function (v, x, decay, step, zeroDebias) {
                    if (zeroDebias === void 0) {
                        zeroDebias = true
                    }
                    util.assertArgumentsAreTensors({v: v, x: x}, "movingAverage");
                    util.assertTypesMatch(v, x);
                    util.assert(util.arraysEqual(v.shape, x.shape), "Shape mismatch in v and x");
                    var one = array_ops_1.ArrayOps.scalar(1);
                    decay = typeof decay === "number" ? array_ops_1.ArrayOps.scalar(decay) : decay;
                    var oneMinusDecay = one.sub(decay);
                    var update = x.sub(v).mul(oneMinusDecay);
                    if (zeroDebias) {
                        util.assert(step != null, "When using zeroDebias: true, step is required.");
                        step = typeof step === "number" ? array_ops_1.ArrayOps.scalar(step) : step;
                        update = update.div(one.sub(binary_ops_1.BinaryOps.pow(decay, step)))
                    }
                    return v.add(update)
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Moving Average"
                }), operation_1.operation], MovingAverageOps, "movingAverage", null);
                return MovingAverageOps
            }();
            exports.MovingAverageOps = MovingAverageOps
        }, {"../doc": 45, "../util": 153, "./array_ops": 101, "./binary_ops": 104, "./operation": 121}],
        120: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var util = require("../util");
            var axis_util = require("./axis_util");
            var operation_1 = require("./operation");
            var ops = require("./ops");
            var NormOps = function () {
                function NormOps() {
                }

                NormOps.norm = function (x, ord, axis, keepDims) {
                    if (ord === void 0) {
                        ord = "euclidean"
                    }
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    util.assertArgumentsAreTensors({x: x}, "norm");
                    var norm = normImpl(x, ord, axis);
                    var keepDimsShape = norm.shape;
                    if (keepDims) {
                        var axes = axis_util.parseAxisParam(axis, x.shape);
                        keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes)
                    }
                    return norm.reshape(keepDimsShape)
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Matrices"
                }), operation_1.operation], NormOps, "norm", null);
                return NormOps
            }();
            exports.NormOps = NormOps;

            function normImpl(x, p, axis) {
                if (axis === void 0) {
                    axis = null
                }
                if (x.rank === 0) {
                    return x.abs()
                }
                if (x.rank !== 1 && axis === null) {
                    return normImpl(x.reshape([-1]), p, axis)
                }
                if (x.rank === 1 || typeof axis === "number" || axis instanceof Array && axis.length === 1) {
                    if (p === 1) {
                        return x.abs().sum(axis)
                    }
                    if (p === Infinity) {
                        return x.abs().max(axis)
                    }
                    if (p === -Infinity) {
                        return x.abs().min(axis)
                    }
                    if (p === "euclidean" || p === 2) {
                        return x.abs().pow(ops.scalar(2, "int32")).sum(axis).sqrt()
                    }
                    throw new Error("Error in norm: invalid ord value: " + p)
                }
                if (axis instanceof Array && axis.length === 2) {
                    if (p === 1) {
                        return x.abs().sum(axis[0]).max(axis[1] - 1)
                    }
                    if (p === Infinity) {
                        return x.abs().sum(axis[1]).max(axis[0])
                    }
                    if (p === -Infinity) {
                        return x.abs().sum(axis[1]).min(axis[0])
                    }
                    if (p === "fro" || p === "euclidean") {
                        return x.square().sum(axis).sqrt()
                    }
                    throw new Error("Error in norm: invalid ord value: " + p)
                }
                throw new Error("Error in norm: invalid axis: " + axis)
            }
        }, {"../doc": 45, "../util": 153, "./axis_util": 102, "./operation": 121, "./ops": 122}],
        121: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var globals_1 = require("../globals");

            function operation(target, name, descriptor) {
                var fn = descriptor.value;
                descriptor.value = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i]
                    }
                    return globals_1.tidy(name, function () {
                        return fn.apply(void 0, args)
                    })
                };
                return descriptor
            }

            exports.operation = operation
        }, {"../globals": 48}],
        122: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var array_ops_1 = require("./array_ops");
            var batchnorm_1 = require("./batchnorm");
            var binary_ops_1 = require("./binary_ops");
            var compare_1 = require("./compare");
            var concat_1 = require("./concat");
            var conv_1 = require("./conv");
            var image_ops_1 = require("./image_ops");
            var linalg_ops_1 = require("./linalg_ops");
            var logical_ops_1 = require("./logical_ops");
            var loss_ops_1 = require("./loss_ops");
            var lrn_1 = require("./lrn");
            var lstm_1 = require("./lstm");
            var matmul_1 = require("./matmul");
            var moving_average_1 = require("./moving_average");
            var norm_1 = require("./norm");
            var pool_1 = require("./pool");
            var reduction_ops_1 = require("./reduction_ops");
            var reverse_1 = require("./reverse");
            var slice_1 = require("./slice");
            var softmax_1 = require("./softmax");
            var strided_slice_1 = require("./strided_slice");
            var transpose_1 = require("./transpose");
            var unary_ops_1 = require("./unary_ops");
            exports.batchNormalization = batchnorm_1.BatchNormOps.batchNormalization;
            exports.batchNormalization2d = batchnorm_1.BatchNormOps.batchNormalization2d;
            exports.batchNormalization3d = batchnorm_1.BatchNormOps.batchNormalization3d;
            exports.batchNormalization4d = batchnorm_1.BatchNormOps.batchNormalization4d;
            exports.concat = concat_1.ConcatOps.concat;
            exports.concat1d = concat_1.ConcatOps.concat1d;
            exports.concat2d = concat_1.ConcatOps.concat2d;
            exports.concat3d = concat_1.ConcatOps.concat3d;
            exports.concat4d = concat_1.ConcatOps.concat4d;
            exports.conv1d = conv_1.ConvOps.conv1d;
            exports.conv2d = conv_1.ConvOps.conv2d;
            exports.conv2dTranspose = conv_1.ConvOps.conv2dTranspose;
            exports.depthwiseConv2d = conv_1.ConvOps.depthwiseConv2d;
            exports.separableConv2d = conv_1.ConvOps.separableConv2d;
            exports.matMul = matmul_1.MatmulOps.matMul;
            exports.matrixTimesVector = matmul_1.MatmulOps.matrixTimesVector;
            exports.outerProduct = matmul_1.MatmulOps.outerProduct;
            exports.vectorTimesMatrix = matmul_1.MatmulOps.vectorTimesMatrix;
            exports.avgPool = pool_1.PoolOps.avgPool;
            exports.maxPool = pool_1.PoolOps.maxPool;
            exports.transpose = transpose_1.TransposeOps.transpose;
            exports.reverse = reverse_1.ReverseOps.reverse;
            exports.reverse1d = reverse_1.ReverseOps.reverse1d;
            exports.reverse2d = reverse_1.ReverseOps.reverse2d;
            exports.reverse3d = reverse_1.ReverseOps.reverse3d;
            exports.reverse4d = reverse_1.ReverseOps.reverse4d;
            exports.slice = slice_1.SliceOps.slice;
            exports.slice1d = slice_1.SliceOps.slice1d;
            exports.slice2d = slice_1.SliceOps.slice2d;
            exports.slice3d = slice_1.SliceOps.slice3d;
            exports.slice4d = slice_1.SliceOps.slice4d;
            exports.stridedSlice = strided_slice_1.StridedSliceOps.stridedSlice;
            exports.argMax = reduction_ops_1.ReductionOps.argMax;
            exports.argMin = reduction_ops_1.ReductionOps.argMin;
            exports.logSumExp = reduction_ops_1.ReductionOps.logSumExp;
            exports.max = reduction_ops_1.ReductionOps.max;
            exports.mean = reduction_ops_1.ReductionOps.mean;
            exports.min = reduction_ops_1.ReductionOps.min;
            exports.moments = reduction_ops_1.ReductionOps.moments;
            exports.sum = reduction_ops_1.ReductionOps.sum;
            exports.unsortedSegmentSum = reduction_ops_1.ReductionOps.unsortedSegmentSum;
            exports.equal = compare_1.CompareOps.equal;
            exports.equalStrict = compare_1.CompareOps.equalStrict;
            exports.greater = compare_1.CompareOps.greater;
            exports.greaterStrict = compare_1.CompareOps.greaterStrict;
            exports.greaterEqual = compare_1.CompareOps.greaterEqual;
            exports.greaterEqualStrict = compare_1.CompareOps.greaterEqualStrict;
            exports.less = compare_1.CompareOps.less;
            exports.lessStrict = compare_1.CompareOps.lessStrict;
            exports.lessEqual = compare_1.CompareOps.lessEqual;
            exports.lessEqualStrict = compare_1.CompareOps.lessEqualStrict;
            exports.notEqual = compare_1.CompareOps.notEqual;
            exports.notEqualStrict = compare_1.CompareOps.notEqualStrict;
            exports.logicalNot = logical_ops_1.LogicalOps.logicalNot;
            exports.logicalAnd = logical_ops_1.LogicalOps.logicalAnd;
            exports.logicalOr = logical_ops_1.LogicalOps.logicalOr;
            exports.logicalXor = logical_ops_1.LogicalOps.logicalXor;
            exports.where = logical_ops_1.LogicalOps.where;
            exports.abs = unary_ops_1.UnaryOps.abs;
            exports.acos = unary_ops_1.UnaryOps.acos;
            exports.acosh = unary_ops_1.UnaryOps.acosh;
            exports.asin = unary_ops_1.UnaryOps.asin;
            exports.asinh = unary_ops_1.UnaryOps.asinh;
            exports.atan = unary_ops_1.UnaryOps.atan;
            exports.atanh = unary_ops_1.UnaryOps.atanh;
            exports.ceil = unary_ops_1.UnaryOps.ceil;
            exports.clipByValue = unary_ops_1.UnaryOps.clipByValue;
            exports.cos = unary_ops_1.UnaryOps.cos;
            exports.cosh = unary_ops_1.UnaryOps.cosh;
            exports.elu = unary_ops_1.UnaryOps.elu;
            exports.exp = unary_ops_1.UnaryOps.exp;
            exports.expm1 = unary_ops_1.UnaryOps.expm1;
            exports.floor = unary_ops_1.UnaryOps.floor;
            exports.sign = unary_ops_1.UnaryOps.sign;
            exports.leakyRelu = unary_ops_1.UnaryOps.leakyRelu;
            exports.log = unary_ops_1.UnaryOps.log;
            exports.log1p = unary_ops_1.UnaryOps.log1p;
            exports.logSigmoid = unary_ops_1.UnaryOps.logSigmoid;
            exports.neg = unary_ops_1.UnaryOps.neg;
            exports.prelu = unary_ops_1.UnaryOps.prelu;
            exports.relu = unary_ops_1.UnaryOps.relu;
            exports.reciprocal = unary_ops_1.UnaryOps.reciprocal;
            exports.round = unary_ops_1.UnaryOps.round;
            exports.selu = unary_ops_1.UnaryOps.selu;
            exports.sigmoid = unary_ops_1.UnaryOps.sigmoid;
            exports.sin = unary_ops_1.UnaryOps.sin;
            exports.sinh = unary_ops_1.UnaryOps.sinh;
            exports.softplus = unary_ops_1.UnaryOps.softplus;
            exports.sqrt = unary_ops_1.UnaryOps.sqrt;
            exports.rsqrt = unary_ops_1.UnaryOps.rsqrt;
            exports.square = unary_ops_1.UnaryOps.square;
            exports.step = unary_ops_1.UnaryOps.step;
            exports.tan = unary_ops_1.UnaryOps.tan;
            exports.tanh = unary_ops_1.UnaryOps.tanh;
            exports.erf = unary_ops_1.UnaryOps.erf;
            exports.add = binary_ops_1.BinaryOps.add;
            exports.addStrict = binary_ops_1.BinaryOps.addStrict;
            exports.atan2 = binary_ops_1.BinaryOps.atan2;
            exports.div = binary_ops_1.BinaryOps.div;
            exports.divStrict = binary_ops_1.BinaryOps.divStrict;
            exports.maximum = binary_ops_1.BinaryOps.maximum;
            exports.maximumStrict = binary_ops_1.BinaryOps.maximumStrict;
            exports.minimum = binary_ops_1.BinaryOps.minimum;
            exports.minimumStrict = binary_ops_1.BinaryOps.minimumStrict;
            exports.mod = binary_ops_1.BinaryOps.mod;
            exports.modStrict = binary_ops_1.BinaryOps.modStrict;
            exports.mul = binary_ops_1.BinaryOps.mul;
            exports.mulStrict = binary_ops_1.BinaryOps.mulStrict;
            exports.pow = binary_ops_1.BinaryOps.pow;
            exports.powStrict = binary_ops_1.BinaryOps.powStrict;
            exports.sub = binary_ops_1.BinaryOps.sub;
            exports.subStrict = binary_ops_1.BinaryOps.subStrict;
            exports.squaredDifference = binary_ops_1.BinaryOps.squaredDifference;
            exports.squaredDifferenceStrict = binary_ops_1.BinaryOps.squaredDifferenceStrict;
            exports.norm = norm_1.NormOps.norm;
            exports.cast = array_ops_1.ArrayOps.cast;
            exports.clone = array_ops_1.ArrayOps.clone;
            exports.fromPixels = array_ops_1.ArrayOps.fromPixels;
            exports.toPixels = array_ops_1.ArrayOps.toPixels;
            exports.ones = array_ops_1.ArrayOps.ones;
            exports.onesLike = array_ops_1.ArrayOps.onesLike;
            exports.zeros = array_ops_1.ArrayOps.zeros;
            exports.zerosLike = array_ops_1.ArrayOps.zerosLike;
            exports.eye = array_ops_1.ArrayOps.eye;
            exports.rand = array_ops_1.ArrayOps.rand;
            exports.randomNormal = array_ops_1.ArrayOps.randomNormal;
            exports.truncatedNormal = array_ops_1.ArrayOps.truncatedNormal;
            exports.randomUniform = array_ops_1.ArrayOps.randomUniform;
            exports.multinomial = array_ops_1.ArrayOps.multinomial;
            exports.reshape = array_ops_1.ArrayOps.reshape;
            exports.squeeze = array_ops_1.ArrayOps.squeeze;
            exports.tile = array_ops_1.ArrayOps.tile;
            exports.gather = array_ops_1.ArrayOps.gather;
            exports.oneHot = array_ops_1.ArrayOps.oneHot;
            exports.linspace = array_ops_1.ArrayOps.linspace;
            exports.range = array_ops_1.ArrayOps.range;
            exports.buffer = array_ops_1.ArrayOps.buffer;
            exports.fill = array_ops_1.ArrayOps.fill;
            exports.tensor = array_ops_1.ArrayOps.tensor;
            exports.scalar = array_ops_1.ArrayOps.scalar;
            exports.tensor1d = array_ops_1.ArrayOps.tensor1d;
            exports.tensor2d = array_ops_1.ArrayOps.tensor2d;
            exports.tensor3d = array_ops_1.ArrayOps.tensor3d;
            exports.tensor4d = array_ops_1.ArrayOps.tensor4d;
            exports.print = array_ops_1.ArrayOps.print;
            exports.expandDims = array_ops_1.ArrayOps.expandDims;
            exports.stack = array_ops_1.ArrayOps.stack;
            exports.unstack = array_ops_1.ArrayOps.unstack;
            exports.split = array_ops_1.ArrayOps.split;
            exports.cumsum = array_ops_1.ArrayOps.cumsum;
            exports.pad = array_ops_1.ArrayOps.pad;
            exports.pad1d = array_ops_1.ArrayOps.pad1d;
            exports.pad2d = array_ops_1.ArrayOps.pad2d;
            exports.pad3d = array_ops_1.ArrayOps.pad3d;
            exports.pad4d = array_ops_1.ArrayOps.pad4d;
            exports.movingAverage = moving_average_1.MovingAverageOps.movingAverage;
            exports.basicLSTMCell = lstm_1.LSTMOps.basicLSTMCell;
            exports.multiRNNCell = lstm_1.LSTMOps.multiRNNCell;
            exports.softmax = softmax_1.SoftmaxOps.softmax;
            exports.localResponseNormalization = lrn_1.LRNOps.localResponseNormalization;
            exports.linalg = linalg_ops_1.LinalgOps;
            var operation_1 = require("./operation");
            exports.operation = operation_1.operation;
            var tensor_1 = require("../tensor");
            var types_1 = require("../types");
            [tensor_1.Tensor, types_1.Rank];
            [loss_ops_1.Reduction];
            exports.losses = {
                absoluteDifference: loss_ops_1.LossOps.absoluteDifference,
                computeWeightedLoss: loss_ops_1.LossOps.computeWeightedLoss,
                cosineDistance: loss_ops_1.LossOps.cosineDistance,
                hingeLoss: loss_ops_1.LossOps.hingeLoss,
                logLoss: loss_ops_1.LossOps.logLoss,
                meanSquaredError: loss_ops_1.LossOps.meanSquaredError,
                softmaxCrossEntropy: softmax_1.SoftmaxOps.softmaxCrossEntropy
            };
            exports.image = {
                resizeBilinear: image_ops_1.ImageOps.resizeBilinear,
                resizeNearestNeighbor: image_ops_1.ImageOps.resizeNearestNeighbor
            }
        }, {
            "../tensor": 147,
            "../types": 152,
            "./array_ops": 101,
            "./batchnorm": 103,
            "./binary_ops": 104,
            "./compare": 106,
            "./concat": 107,
            "./conv": 109,
            "./image_ops": 112,
            "./linalg_ops": 113,
            "./logical_ops": 114,
            "./loss_ops": 115,
            "./lrn": 116,
            "./lstm": 117,
            "./matmul": 118,
            "./moving_average": 119,
            "./norm": 120,
            "./operation": 121,
            "./pool": 123,
            "./reduction_ops": 126,
            "./reverse": 127,
            "./slice": 129,
            "./softmax": 131,
            "./strided_slice": 132,
            "./transpose": 133,
            "./unary_ops": 134
        }],
        123: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var conv_util = require("./conv_util");
            var operation_1 = require("./operation");
            var PoolOps = function () {
                function PoolOps() {
                }

                PoolOps.maxPool = function (x, filterSize, strides, pad, dimRoundingMode) {
                    util.assertArgumentsAreTensors({x: x}, "maxPool");
                    var x4D = x;
                    var reshapedTo4D = false;
                    if (x.rank === 3) {
                        reshapedTo4D = true;
                        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                    }
                    util.assert(x4D.rank === 4, "Error in maxPool: input must be rank 4 but got rank " + x4D.rank + ".");
                    if (dimRoundingMode != null) {
                        util.assert(util.isInt(pad), "Error in maxPool: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."))
                    }
                    var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad, dimRoundingMode);
                    var grad = function (dy, saved) {
                        var y4D = saved[0];
                        return {
                            x: function () {
                                return PoolOps.maxPoolBackprop(dy, x4D, y4D, filterSize, strides, pad)
                            }
                        }
                    };
                    var res = environment_1.ENV.engine.runKernel(function (backend, save) {
                        return save(backend.maxPool(x4D, convInfo))
                    }, {x: x4D}, grad);
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                PoolOps.maxPoolBackprop = function (dy, input, output, filterSize, strides, pad, dimRoundingMode) {
                    util.assertArgumentsAreTensors({dy: dy, input: input, output: output}, "maxPoolBackprop");
                    util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
                    util.assert(dy.rank === 4, "Error in maxPoolBackprop: dy must be rank 4 but got rank " + (dy.rank + "."));
                    util.assert(input.rank === 4, "Error in maxPoolBackprop: input must be rank 4 but got rank " + (input.rank + "."));
                    if (dimRoundingMode != null) {
                        util.assert(util.isInt(pad), "Error in maxPoolBackprop: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."))
                    }
                    var convInfo = conv_util.computePool2DInfo(input.shape, filterSize, strides, pad, dimRoundingMode);
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.maxPoolBackprop(dy, input, output, convInfo)
                    }, {dy: dy, input: input});
                    return res
                };
                PoolOps.avgPool = function (x, filterSize, strides, pad, dimRoundingMode) {
                    util.assertArgumentsAreTensors({x: x}, "avgPool");
                    util.assert(x.dtype === "float32", "The input dtype to avgPool must be float32");
                    var x4D = x;
                    var reshapedTo4D = false;
                    if (x.rank === 3) {
                        reshapedTo4D = true;
                        x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2])
                    }
                    util.assert(x4D.rank === 4, "Error in avgPool: x must be rank 4 but got rank " + x4D.rank + ".");
                    if (dimRoundingMode != null) {
                        util.assert(util.isInt(pad), "Error in avgPool: pad must be an integer when using, " + ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."))
                    }
                    var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad);
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return PoolOps.avgPoolBackprop(dy, x4D, filterSize, strides, pad)
                            }
                        }
                    };
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.avgPool(x4D, convInfo)
                    }, {x: x4D}, grad);
                    res = res.cast(x.dtype);
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                PoolOps.avgPoolBackprop = function (dy, input, filterSize, strides, pad) {
                    util.assertArgumentsAreTensors({dy: dy, input: input}, "avgPoolBackprop");
                    util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
                    var input4D = input;
                    var dy4D = dy;
                    var reshapedTo4D = false;
                    if (input.rank === 3) {
                        reshapedTo4D = true;
                        input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
                        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2])
                    }
                    util.assert(dy4D.rank === 4, "Error in avgPoolBackprop: dy must be rank 4 but got rank " + (dy4D.rank + "."));
                    util.assert(input4D.rank === 4, "Error in avgPoolBackprop: input must be rank 4 but got rank " + (input4D.rank + "."));
                    var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.avgPoolBackprop(dy4D, input4D, convInfo)
                    }, {dy4D: dy4D, input4D: input4D});
                    if (reshapedTo4D) {
                        return res.as3D(res.shape[1], res.shape[2], res.shape[3])
                    }
                    return res
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Convolution"
                }), operation_1.operation], PoolOps, "maxPool", null);
                __decorate([operation_1.operation], PoolOps, "maxPoolBackprop", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Convolution"
                }), operation_1.operation], PoolOps, "avgPool", null);
                __decorate([operation_1.operation], PoolOps, "avgPoolBackprop", null);
                return PoolOps
            }();
            exports.PoolOps = PoolOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./conv_util": 110, "./operation": 121}],
        124: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var seedrandom = require("seedrandom");
            var MPRandGauss = function () {
                function MPRandGauss(mean, stdDeviation, dtype, truncated, seed) {
                    this.mean = mean;
                    this.stdDev = stdDeviation;
                    this.dtype = dtype;
                    this.nextVal = NaN;
                    this.truncated = truncated;
                    if (this.truncated) {
                        this.upper = this.mean + this.stdDev * 2;
                        this.lower = this.mean - this.stdDev * 2
                    }
                    var seedValue = seed ? seed : Math.random();
                    this.random = seedrandom.alea(seedValue.toString())
                }

                MPRandGauss.prototype.nextValue = function () {
                    if (!isNaN(this.nextVal)) {
                        var value = this.nextVal;
                        this.nextVal = NaN;
                        return value
                    }
                    var resultX, resultY;
                    var isValid = false;
                    while (!isValid) {
                        var v1 = void 0, v2 = void 0, s = void 0;
                        do {
                            v1 = 2 * this.random() - 1;
                            v2 = 2 * this.random() - 1;
                            s = v1 * v1 + v2 * v2
                        } while (s >= 1 || s === 0);
                        var mul = Math.sqrt(-2 * Math.log(s) / s);
                        resultX = this.mean + this.stdDev * v1 * mul;
                        resultY = this.mean + this.stdDev * v2 * mul;
                        if (!this.truncated || this.isValidTruncated(resultX)) {
                            isValid = true
                        }
                    }
                    if (!this.truncated || this.isValidTruncated(resultY)) {
                        this.nextVal = this.convertValue(resultY)
                    }
                    return this.convertValue(resultX)
                };
                MPRandGauss.prototype.convertValue = function (value) {
                    if (this.dtype == null || this.dtype === "float32") {
                        return value
                    }
                    return Math.round(value)
                };
                MPRandGauss.prototype.isValidTruncated = function (value) {
                    return value <= this.upper && value >= this.lower
                };
                return MPRandGauss
            }();
            exports.MPRandGauss = MPRandGauss
        }, {seedrandom: 212}],
        125: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.PARALLELIZE_THRESHOLD = 30;

            function computeOptimalWindowSize(inSize) {
                if (inSize <= exports.PARALLELIZE_THRESHOLD) {
                    return inSize
                }
                return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)))
            }

            exports.computeOptimalWindowSize = computeOptimalWindowSize;

            function nearestDivisor(size, start) {
                for (var i = start; i < size; ++i) {
                    if (size % i === 0) {
                        return i
                    }
                }
                return size
            }
        }, {}],
        126: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var globals_1 = require("../globals");
            var util = require("../util");
            var axis_util = require("./axis_util");
            var operation_1 = require("./operation");
            var ops = require("./ops");
            var ReductionOps = function () {
                function ReductionOps() {
                }

                ReductionOps.logSumExp = function (x, axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    util.assertArgumentsAreTensors({x: x}, "logSumExp");
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var xMax = x.max(axes, true);
                    var a = x.sub(xMax);
                    var b = a.exp();
                    var c = b.sum(axes);
                    var d = c.log();
                    var res = xMax.reshape(d.shape).add(d);
                    if (keepDims) {
                        var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
                        return res.reshape(newShape)
                    }
                    return res
                };
                ReductionOps.sum = function (x, axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    util.assertArgumentsAreTensors({x: x}, "sum");
                    if (x.dtype === "bool") {
                        x = x.toInt()
                    }
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var customOp = globals_1.customGrad(function (x) {
                        var permutation = axis_util.getAxesPermutation(axes, x.rank);
                        var reductionAxes = axes;
                        var permutedX = x;
                        if (permutation != null) {
                            permutedX = x.transpose(permutation);
                            reductionAxes = axis_util.getInnerMostAxes(reductionAxes.length, x.rank)
                        }
                        var value = environment_1.ENV.engine.runKernel(function (backend) {
                            return backend.sum(permutedX, reductionAxes)
                        }, {permutedX: permutedX});
                        if (keepDims) {
                            var newShape = axis_util.expandShapeToKeepDim(value.shape, axes);
                            value = value.reshape(newShape)
                        }
                        var gradFunc = function (dy) {
                            var expandedDyShape = x.shape.slice();
                            axes.forEach(function (axis) {
                                expandedDyShape[axis] = 1
                            });
                            var expandedDy = dy.reshape(expandedDyShape);
                            var derX = expandedDy.mul(ops.ones(x.shape, "float32"));
                            return derX
                        };
                        return {value: value, gradFunc: gradFunc}
                    });
                    return customOp(x)
                };
                ReductionOps.mean = function (x, axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    util.assertArgumentsAreTensors({x: x}, "mean");
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
                    var reduceShape = shapes[1];
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var customOp = globals_1.customGrad(function (x) {
                        var reduceSizeScalar = ops.scalar(reduceSize);
                        var xReduce = reduceSizeScalar.dtype === x.dtype ? x : x.cast(reduceSizeScalar.dtype);
                        var res = xReduce.div(reduceSizeScalar);
                        var value = res.sum(axis, keepDims);
                        var gradFunc = function (dy) {
                            var expandedDyShape = x.shape.slice();
                            axes.forEach(function (axis) {
                                expandedDyShape[axis] = 1
                            });
                            var expandedDy = dy.reshape(expandedDyShape);
                            var derX = expandedDy.mul(ops.ones(x.shape, "float32")).div(reduceSizeScalar);
                            return derX
                        };
                        return {value: value, gradFunc: gradFunc}
                    });
                    return customOp(x)
                };
                ReductionOps.min = function (x, axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    util.assertArgumentsAreTensors({x: x}, "min");
                    var origAxes = axis_util.parseAxisParam(axis, x.shape);
                    var axes = origAxes;
                    var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
                    if (permutedAxes != null) {
                        x = x.transpose(permutedAxes);
                        axes = axis_util.getInnerMostAxes(axes.length, x.rank)
                    }
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.min(x, axes)
                    }, {x: x});
                    if (keepDims) {
                        var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                        return res.reshape(newShape)
                    }
                    return res
                };
                ReductionOps.max = function (x, axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    util.assertArgumentsAreTensors({x: x}, "max");
                    var origAxes = axis_util.parseAxisParam(axis, x.shape);
                    var axes = origAxes;
                    var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
                    if (permutedAxes != null) {
                        x = x.transpose(permutedAxes);
                        axes = axis_util.getInnerMostAxes(axes.length, x.rank)
                    }
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.max(x, axes)
                    }, {x: x});
                    if (keepDims) {
                        var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                        return res.reshape(newShape)
                    }
                    return res
                };
                ReductionOps.argMin = function (x, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    util.assertArgumentsAreTensors({x: x}, "argMin");
                    if (axis == null) {
                        axis = 0
                    }
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
                    if (permutedAxes != null) {
                        x = x.transpose(permutedAxes);
                        axes = axis_util.getInnerMostAxes(axes.length, x.rank)
                    }
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.argMin(x, axes[0])
                    }, {x: x})
                };
                ReductionOps.argMax = function (x, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    util.assertArgumentsAreTensors({x: x}, "argMax");
                    if (axis == null) {
                        axis = 0
                    }
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
                    if (permutedAxes != null) {
                        x = x.transpose(permutedAxes);
                        axes = axis_util.getInnerMostAxes(axes.length, x.rank)
                    }
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.argMax(x, axes[0])
                    }, {x: x})
                };
                ReductionOps.moments = function (x, axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    util.assertArgumentsAreTensors({x: x}, "moments");
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var mean = x.mean(axes, keepDims);
                    var keepDimsShape = mean.shape;
                    if (!keepDims) {
                        keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes)
                    }
                    var devSquared = x.toFloat().sub(mean.reshape(keepDimsShape)).square();
                    var variance = devSquared.mean(axes, keepDims);
                    return {mean: mean, variance: variance}
                };
                ReductionOps.unsortedSegmentSum = function (x, segmentIds, numSegments, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    util.assertArgumentsAreTensors({x: x, segmentIds: segmentIds}, "unsortedSegmentSum");
                    util.assert(segmentIds.dtype === "int32", "Segment Ids must be of dtype `int32`");
                    axis = axis_util.parseAxisParam(axis, x.shape)[0];
                    var res = [];
                    var dim = segmentIds.shape[0];
                    var newShape = [];
                    for (var i = 0; i < x.shape.length; i++) {
                        if (i === axis) {
                            newShape.push(dim)
                        } else {
                            newShape.push(1)
                        }
                    }
                    var reshapedSegmentIds = ops.reshape(segmentIds, newShape);
                    for (var i = 0; i < numSegments; i++) {
                        var segmentId = ops.scalar(i, "int32");
                        var mask = ops.equal(segmentId, reshapedSegmentIds).asType("float32");
                        var sum = mask.mul(x).sum(axis);
                        res.push(sum)
                    }
                    return ops.stack(res, axis)
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Reduction"
                }), operation_1.operation], ReductionOps, "logSumExp", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Reduction"
                }), operation_1.operation], ReductionOps, "sum", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Reduction"
                }), operation_1.operation], ReductionOps, "mean", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Reduction"
                }), operation_1.operation], ReductionOps, "min", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Reduction"
                }), operation_1.operation], ReductionOps, "max", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Reduction"
                }), operation_1.operation], ReductionOps, "argMin", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Reduction"
                }), operation_1.operation], ReductionOps, "argMax", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Normalization"
                }), operation_1.operation], ReductionOps, "moments", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Reduction"
                }), operation_1.operation], ReductionOps, "unsortedSegmentSum", null);
                return ReductionOps
            }();
            exports.ReductionOps = ReductionOps
        }, {
            "../doc": 45,
            "../environment": 47,
            "../globals": 48,
            "../util": 153,
            "./axis_util": 102,
            "./operation": 121,
            "./ops": 122
        }],
        127: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var axis_util_1 = require("./axis_util");
            var operation_1 = require("./operation");
            var ReverseOps = function () {
                function ReverseOps() {
                }

                ReverseOps.reverse1d = function (x) {
                    util.assert(x.rank === 1, "Error in reverse1D: x must be rank 1 but got\n             rank " + x.rank + ".");
                    return ReverseOps.reverse(x, 0)
                };
                ReverseOps.reverse2d = function (x, axis) {
                    util.assert(x.rank === 2, "Error in reverse2D: x must be rank 2 but got\n             rank " + x.rank + ".");
                    return ReverseOps.reverse(x, axis)
                };
                ReverseOps.reverse3d = function (x, axis) {
                    util.assert(x.rank === 3, "Error in reverse3D: x must be rank 3 but got\n             rank " + x.rank + ".");
                    return ReverseOps.reverse(x, axis)
                };
                ReverseOps.reverse4d = function (x, axis) {
                    util.assert(x.rank === 4, "Error in reverse4D: x must be rank 4 but got\n             rank " + x.rank + ".");
                    return ReverseOps.reverse(x, axis)
                };
                ReverseOps.reverse = function (x, axis) {
                    util.assertArgumentsAreTensors({x: x}, "reverse");
                    if (x.rank === 0) {
                        return x.clone()
                    }
                    var axes = axis_util_1.parseAxisParam(axis, x.shape);
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.reverse(axes)
                            }
                        }
                    };
                    var res = environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.reverse(x, axes)
                    }, {x: x}, grad);
                    return res.reshapeAs(x)
                };
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], ReverseOps, "reverse", null);
                return ReverseOps
            }();
            exports.ReverseOps = ReverseOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./axis_util": 102, "./operation": 121}],
        128: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.SELU_SCALEALPHA = 1.7580993408473768;
            exports.SELU_SCALE = 1.0507009873554805
        }, {}],
        129: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var operation_1 = require("./operation");
            var slice_util = require("./slice_util");
            var SliceOps = function () {
                function SliceOps() {
                }

                SliceOps.slice1d = function (x, begin, size) {
                    util.assert(x.rank === 1, "slice1d expects a rank-1 tensor, but got a rank-" + x.rank + " tensor");
                    return SliceOps.slice(x, [begin], [size])
                };
                SliceOps.slice2d = function (x, begin, size) {
                    util.assert(x.rank === 2, "slice1d expects a rank-2 tensor, but got a rank-" + x.rank + " tensor");
                    return SliceOps.slice(x, begin, size)
                };
                SliceOps.slice3d = function (x, begin, size) {
                    util.assert(x.rank === 3, "slice1d expects a rank-3 tensor, but got a rank-" + x.rank + " tensor");
                    return SliceOps.slice(x, begin, size)
                };
                SliceOps.slice4d = function (x, begin, size) {
                    util.assert(x.rank === 4, "slice1d expects a rank-4 tensor, but got a rank-" + x.rank + " tensor");
                    return SliceOps.slice(x, begin, size)
                };
                SliceOps.slice = function (x, begin, size) {
                    util.assertArgumentsAreTensors({x: x}, "slice");
                    if (x.rank === 0) {
                        throw new Error("Slicing scalar is not possible")
                    }
                    var begin_;
                    if (typeof begin === "number") {
                        begin_ = [begin].concat(new Array(x.rank - 1).fill(0))
                    } else if (begin.length < x.rank) {
                        begin_ = begin.concat(new Array(x.rank - begin.length).fill(0))
                    } else {
                        begin_ = begin
                    }
                    var size_;
                    if (size == null) {
                        size_ = new Array(x.rank).fill(-1)
                    } else if (typeof size === "number") {
                        size_ = [size].concat(new Array(x.rank - 1).fill(-1))
                    } else if (size.length < x.rank) {
                        size_ = size.concat(new Array(x.rank - size.length).fill(-1))
                    } else {
                        size_ = size
                    }
                    size_ = size_.map(function (d, i) {
                        if (d >= 0) {
                            return d
                        } else {
                            util.assert(d === -1, "Bad value in size");
                            return x.shape[i] - begin_[i]
                        }
                    });
                    slice_util.assertParamsValid(x, begin_, size_);
                    var inputShape = x.shape;
                    var grad = function (dy) {
                        var paddings = [];
                        for (var i = 0; i < dy.rank; i++) {
                            paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]])
                        }
                        return {
                            x: function () {
                                return dy.pad(paddings)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.slice(x, begin_, size_)
                    }, {x: x}, grad)
                };
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], SliceOps, "slice", null);
                return SliceOps
            }();
            exports.SliceOps = SliceOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./operation": 121, "./slice_util": 130}],
        130: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../util");

            function assertParamsValid(input, begin, size) {
                util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " + ("match the rank of the array (" + input.rank + ")."));
                util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " + ("match the rank of the array (" + input.rank + ")."));
                for (var i = 0; i < input.rank; ++i) {
                    util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " + ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"))
                }
            }

            exports.assertParamsValid = assertParamsValid;

            function getStridedSlicedInfo(shape, begin, end, strides, beginMask, endMask) {
                if (beginMask === void 0) {
                    beginMask = 0
                }
                if (endMask === void 0) {
                    endMask = 0
                }
                var startIndex = [];
                var endIndex = [];
                for (var i = 0; i < shape.length; i++) {
                    startIndex[i] = startForAxis(beginMask, begin, strides, shape, i);
                    endIndex[i] = stopForAxis(endMask, end, strides, shape, i)
                }
                var size = new Array(shape.length).fill(0);
                size = size.map(function (d, i) {
                    var count = 0;
                    for (var start = startIndex[i]; !(strides[i] > 0 ? start >= endIndex[i] : start <= endIndex[i]); start += strides[i]) {
                        count += 1
                    }
                    return count
                });
                return [startIndex, size]
            }

            exports.getStridedSlicedInfo = getStridedSlicedInfo;

            function startForAxis(beginMask, startIndices, strides, inputShape, axis) {
                var start = startIndices[axis];
                if (beginMask & 1 << axis) {
                    if (strides[axis] > 0) {
                        start = Number.MIN_SAFE_INTEGER
                    } else {
                        start = Number.MAX_SAFE_INTEGER
                    }
                }
                var axisSize = inputShape[axis];
                if (start < 0) {
                    start += axisSize
                }
                start = util.clamp(0, start, axisSize - 1);
                return start
            }

            exports.startForAxis = startForAxis;

            function stopForAxis(endMask, stopIndices, strides, inputShape, axis) {
                var stop = stopIndices[axis];
                if (endMask & 1 << axis) {
                    if (strides[axis] > 0) {
                        stop = Number.MAX_SAFE_INTEGER
                    } else {
                        stop = Number.MIN_SAFE_INTEGER
                    }
                }
                var axisSize = inputShape[axis];
                if (stop < 0) {
                    stop += axisSize
                }
                if (strides[axis] > 0) {
                    stop = util.clamp(0, stop, axisSize)
                } else {
                    stop = util.clamp(-1, stop, axisSize - 1)
                }
                return stop
            }

            exports.stopForAxis = stopForAxis
        }, {"../util": 153}],
        131: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var globals_1 = require("../globals");
            var util = require("../util");
            var axis_util = require("./axis_util");
            var operation_1 = require("./operation");
            var ops = require("./ops");
            var SoftmaxOps = function () {
                function SoftmaxOps() {
                }

                SoftmaxOps.softmax = function (logits, dim) {
                    if (dim === void 0) {
                        dim = -1
                    }
                    util.assertArgumentsAreTensors({logits: logits}, "softmax");
                    if (dim === -1) {
                        dim = logits.rank - 1
                    }
                    if (dim !== logits.rank - 1) {
                        throw Error("Softmax along a non-last dimension is not yet supported. " + ("Logits was rank " + logits.rank + " and dim was " + dim))
                    }
                    var customOp = globals_1.customGrad(function (logits) {
                        var keepDims = true;
                        var lse = logits.logSumExp([dim], keepDims);
                        var logResult = logits.toFloat().sub(lse);
                        var y = logResult.exp();
                        var gradFunc = function (dy) {
                            var dyTimesY = dy.mul(y);
                            var keepDims = true;
                            return dyTimesY.sub(dyTimesY.sum([dim], keepDims).mul(y))
                        };
                        return {value: y, gradFunc: gradFunc}
                    });
                    return customOp(logits)
                };
                SoftmaxOps.softmaxCrossEntropy = function (labels, logits, dim) {
                    if (dim === void 0) {
                        dim = -1
                    }
                    util.assertArgumentsAreTensors({labels: labels, logits: logits}, "softmaxCrossEntropy");
                    util.assertShapesMatch(labels.shape, logits.shape, "Error in softmaxCrossEntropy: ");
                    if (dim === -1) {
                        dim = logits.rank - 1
                    }
                    if (dim !== logits.rank - 1) {
                        throw Error("Softmax cross entropy along a non-last dimension is not yet " + ("supported. Labels / logits was rank " + logits.rank + " ") + ("and dim was " + dim))
                    }
                    var customOp = globals_1.customGrad(function (labels, logits) {
                        var predictedProbs = logits.softmax(dim);
                        var costVector = ops.scalar(1e-5).add(predictedProbs).log().mul(labels).neg();
                        var value = costVector.sum([dim]);
                        var gradFunc = function (dy) {
                            var dyShape = axis_util.expandShapeToKeepDim(dy.shape, [dim]);
                            return [dy.reshape(dyShape).mul(labels.toFloat().sub(predictedProbs)), dy.reshape(dyShape).mul(predictedProbs.sub(labels.toFloat()))]
                        };
                        return {value: value, gradFunc: gradFunc}
                    });
                    return customOp(labels, logits)
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Normalization"
                }), operation_1.operation], SoftmaxOps, "softmax", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Losses",
                    namespace: "losses"
                }), operation_1.operation], SoftmaxOps, "softmaxCrossEntropy", null);
                return SoftmaxOps
            }();
            exports.SoftmaxOps = SoftmaxOps
        }, {"../doc": 45, "../globals": 48, "../util": 153, "./axis_util": 102, "./operation": 121, "./ops": 122}],
        132: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var operation_1 = require("./operation");
            var StridedSliceOps = function () {
                function StridedSliceOps() {
                }

                StridedSliceOps.stridedSlice = function (x, begin, end, strides, beginMask, endMask) {
                    if (beginMask === void 0) {
                        beginMask = 0
                    }
                    if (endMask === void 0) {
                        endMask = 0
                    }
                    util.assertArgumentsAreTensors({x: x}, "stridedSlice");
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.stridedSlice(x, begin, end, strides, beginMask, endMask)
                    }, {x: x})
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Slicing and Joining"
                }), operation_1.operation], StridedSliceOps, "stridedSlice", null);
                return StridedSliceOps
            }();
            exports.StridedSliceOps = StridedSliceOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./operation": 121}],
        133: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var axis_util = require("./axis_util");
            var operation_1 = require("./operation");
            var TransposeOps = function () {
                function TransposeOps() {
                }

                TransposeOps.transpose = function (x, perm) {
                    util.assertArgumentsAreTensors({x: x}, "transpose");
                    if (perm == null) {
                        perm = x.shape.map(function (s, i) {
                            return i
                        }).reverse()
                    }
                    util.assert(x.rank === perm.length, "Error in transpose: rank of input " + x.rank + " " + ("must match length of perm " + perm + "."));
                    perm.forEach(function (axis) {
                        util.assert(axis >= 0 && axis < x.rank, "All entries in 'perm' must be between 0 and " + (x.rank - 1) + (" but got " + perm))
                    });
                    if (x.rank <= 1) {
                        return x.clone()
                    }
                    var der = function (dy) {
                        var undoPerm = axis_util.getUndoAxesPermutation(perm);
                        return {
                            x: function () {
                                return dy.transpose(undoPerm)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.transpose(x, perm)
                    }, {x: x}, der)
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Matrices"
                }), operation_1.operation], TransposeOps, "transpose", null);
                return TransposeOps
            }();
            exports.TransposeOps = TransposeOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./axis_util": 102, "./operation": 121}],
        134: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var environment_1 = require("../environment");
            var util = require("../util");
            var operation_1 = require("./operation");
            var ops = require("./ops");
            var ops_1 = require("./ops");
            var selu_util = require("./selu_util");
            var UnaryOps = function () {
                function UnaryOps() {
                }

                UnaryOps.neg = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "neg");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.neg()
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.neg(x)
                    }, {x: x}, grad)
                };
                UnaryOps.ceil = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "ceil");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return ops.zerosLike(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.ceil(x)
                    }, {x: x}, grad)
                };
                UnaryOps.floor = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "floor");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return ops.zerosLike(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.floor(x)
                    }, {x: x}, grad)
                };
                UnaryOps.sign = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "sign");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return ops.zerosLike(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.sign(x)
                    }, {x: x}, grad)
                };
                UnaryOps.round = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "round");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return ops.zerosLike(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.round(x)
                    }, {x: x}, grad)
                };
                UnaryOps.exp = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "exp");
                    var bck = function (dy, saved) {
                        var y = saved[0];
                        return {
                            x: function () {
                                return dy.mulStrict(y)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend, save) {
                        return save(backend.exp(x))
                    }, {x: x}, bck)
                };
                UnaryOps.expm1 = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "expm1");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.mulStrict(x.exp())
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.expm1(x)
                    }, {x: x}, grad)
                };
                UnaryOps.log = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "log");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(x.toFloat())
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.log(x)
                    }, {x: x}, grad)
                };
                UnaryOps.log1p = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "log1p");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(x.add(ops.scalar(1)))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.log1p(x)
                    }, {x: x}, grad)
                };
                UnaryOps.sqrt = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "sqrt");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(x.toFloat().sqrt().mul(ops.scalar(2)))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.sqrt(x)
                    }, {x: x}, grad)
                };
                UnaryOps.rsqrt = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "rsqrt");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(x.pow(ops.scalar(1.5)).mul(ops.scalar(2))).neg()
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.rsqrt(x)
                    }, {x: x}, grad)
                };
                UnaryOps.square = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "square");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.mulStrict(x.toFloat().mul(ops.scalar(2)))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.square(x)
                    }, {x: x}, grad)
                };
                UnaryOps.reciprocal = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "reciprocal");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(x.square().neg())
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.reciprocal(x)
                    }, {x: x}, grad)
                };
                UnaryOps.abs = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "abs");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.mulStrict(x.toFloat().step(-1))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.abs(x)
                    }, {x: x}, grad)
                };
                UnaryOps.clipByValue = function (x, clipValueMin, clipValueMax) {
                    util.assertArgumentsAreTensors({x: x}, "clipByValue");
                    util.assert(clipValueMin <= clipValueMax, "Error in clip: min (" + clipValueMin + ") must be " + ("less than or equal to max (" + clipValueMax + ")."));
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.where(x.greater(ops.scalar(clipValueMin)).logicalAnd(x.less(ops.scalar(clipValueMax))), ops_1.zerosLike(dy))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.clip(x, clipValueMin, clipValueMax)
                    }, {x: x}, grad)
                };
                UnaryOps.relu = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "relu");
                    if (x.dtype === "bool") {
                        return x.toInt()
                    }
                    var grad = function (dy) {
                        var stepRes = x.step();
                        return {
                            x: function () {
                                return dy.mulStrict(stepRes.toFloat())
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.relu(x)
                    }, {x: x}, grad)
                };
                UnaryOps.elu = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "elu");
                    var grad = function (dy, saved) {
                        var y = saved[0];
                        return {
                            x: function () {
                                return environment_1.ENV.engine.runKernel(function (backend) {
                                    return backend.eluDer(dy, y)
                                }, {dy: dy, y: y})
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend, save) {
                        return save(backend.elu(x))
                    }, {x: x}, grad)
                };
                UnaryOps.selu = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "selu");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                var mask = x.greater(ops.scalar(0));
                                var scaleAlpha = ops.scalar(selu_util.SELU_SCALEALPHA);
                                var scale = ops.scalar(selu_util.SELU_SCALE);
                                var greaterThanZeroDer = dy.mul(scale);
                                var lessEqualZeroDer = dy.mul(scaleAlpha).mul(x.toFloat().exp());
                                return ops.where(mask, greaterThanZeroDer, lessEqualZeroDer)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.selu(x)
                    }, {x: x}, grad)
                };
                UnaryOps.leakyRelu = function (x, alpha) {
                    if (alpha === void 0) {
                        alpha = .2
                    }
                    util.assertArgumentsAreTensors({x: x}, "leakyRelu");
                    return ops.maximum(ops.scalar(alpha).mul(x), x)
                };
                UnaryOps.prelu = function (x, alpha) {
                    util.assertArgumentsAreTensors({x: x, alpha: alpha}, "prelu");
                    var zero = ops.scalar(0);
                    return ops.maximum(zero, x).add(alpha.mul(ops.minimum(zero, x)))
                };
                UnaryOps.sigmoid = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "sigmoid");
                    var grad = function (dy, saved) {
                        var y = saved[0];
                        return {
                            x: function () {
                                return dy.mulStrict(y.mul(ops.scalar(1).sub(y)))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend, save) {
                        return save(backend.sigmoid(x))
                    }, {x: x}, grad)
                };
                UnaryOps.logSigmoid = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "logSigmoid");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.mulStrict(x.neg().sigmoid())
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.softplus(x.neg()).neg()
                    }, {x: x}, grad)
                };
                UnaryOps.softplus = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "softplus");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.mulStrict(x.sigmoid())
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.softplus(x)
                    }, {x: x}, grad)
                };
                UnaryOps.sin = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "sin");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return x.toFloat().cos().mulStrict(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.sin(x)
                    }, {x: x}, grad)
                };
                UnaryOps.cos = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "cos");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return x.toFloat().sin().neg().mulStrict(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.cos(x)
                    }, {x: x}, grad)
                };
                UnaryOps.tan = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "tan");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(x.cos().square())
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.tan(x)
                    }, {x: x}, grad)
                };
                UnaryOps.asin = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "asin");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(x.toFloat().square())))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.asin(x)
                    }, {x: x}, grad)
                };
                UnaryOps.acos = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "acos");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(x.toFloat().square()))).neg()
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.acos(x)
                    }, {x: x}, grad)
                };
                UnaryOps.atan = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "atan");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(ops.scalar(1).add(x.toFloat().square()))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.atan(x)
                    }, {x: x}, grad)
                };
                UnaryOps.sinh = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "sinh");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return x.toFloat().cosh().mulStrict(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.sinh(x)
                    }, {x: x}, grad)
                };
                UnaryOps.cosh = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "cosh");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return x.toFloat().sinh().mulStrict(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.cosh(x)
                    }, {x: x}, grad)
                };
                UnaryOps.tanh = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "tanh");
                    var grad = function (dy, saved) {
                        var y = saved[0];
                        return {
                            x: function () {
                                return ops.scalar(1).sub(y.square()).mulStrict(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend, save) {
                        return save(backend.tanh(x))
                    }, {x: x}, grad)
                };
                UnaryOps.asinh = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "asinh");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).add(x.toFloat().square())))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.asinh(x)
                    }, {x: x}, grad)
                };
                UnaryOps.acosh = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "acosh");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(UnaryOps.sqrt(x.toFloat().square().sub(ops.scalar(1))))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.acosh(x)
                    }, {x: x}, grad)
                };
                UnaryOps.atanh = function (x) {
                    util.assertArgumentsAreTensors({x: x}, "atanh");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.divStrict(ops.scalar(1).sub(x.toFloat().square()))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.atanh(x)
                    }, {x: x}, grad)
                };
                UnaryOps.erf = function (x) {
                    util.assert(x.dtype === "int32" || x.dtype === "float32", "Input dtype must be `int32` or `float32`.");
                    if (x.dtype === "int32") {
                        x = x.toFloat()
                    }
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return dy.mulStrict(ops.scalar(2 / Math.sqrt(Math.PI)).mul(x.square().neg().exp()))
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.erf(x)
                    }, {x: x}, grad)
                };
                UnaryOps.step = function (x, alpha) {
                    if (alpha === void 0) {
                        alpha = 0
                    }
                    util.assertArgumentsAreTensors({x: x}, "step");
                    var grad = function (dy) {
                        return {
                            x: function () {
                                return ops.zerosLike(dy)
                            }
                        }
                    };
                    return environment_1.ENV.engine.runKernel(function (backend) {
                        return backend.step(x, alpha)
                    }, {x: x}, grad)
                };
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "neg", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "ceil", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "floor", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "sign", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "round", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "exp", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "expm1", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "log", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "log1p", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "sqrt", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "rsqrt", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "square", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "reciprocal", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "abs", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "clipByValue", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "relu", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "elu", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "selu", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "leakyRelu", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "prelu", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "sigmoid", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "logSigmoid", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "softplus", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "sin", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "cos", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "tan", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "asin", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "acos", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "atan", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "sinh", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "cosh", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "tanh", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "asinh", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "acosh", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "atanh", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "erf", null);
                __decorate([doc_1.doc({
                    heading: "Operations",
                    subheading: "Basic math"
                }), operation_1.operation], UnaryOps, "step", null);
                return UnaryOps
            }();
            exports.UnaryOps = UnaryOps
        }, {"../doc": 45, "../environment": 47, "../util": 153, "./operation": 121, "./ops": 122, "./selu_util": 128}],
        135: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var globals_1 = require("../globals");
            var ops_1 = require("../ops/ops");
            var serialization_1 = require("../serialization");
            var optimizer_1 = require("./optimizer");
            var AdadeltaOptimizer = function (_super) {
                __extends(AdadeltaOptimizer, _super);

                function AdadeltaOptimizer(learningRate, rho, epsilon) {
                    if (epsilon === void 0) {
                        epsilon = 1e-8
                    }
                    var _this = _super.call(this) || this;
                    _this.learningRate = learningRate;
                    _this.rho = rho;
                    _this.epsilon = epsilon;
                    _this.accumulatedGrads = {};
                    _this.accumulatedUpdates = {};
                    _this.c = globals_1.keep(ops_1.scalar(-learningRate));
                    _this.epsilonScalar = globals_1.keep(ops_1.scalar(epsilon));
                    _this.rhoScalar = globals_1.keep(ops_1.scalar(rho));
                    _this.oneMinusRho = globals_1.keep(ops_1.scalar(1 - rho));
                    return _this
                }

                AdadeltaOptimizer.prototype.applyGradients = function (variableGradients) {
                    var _this = this;
                    var _loop_1 = function (variableName) {
                        var value = environment_1.ENV.engine.registeredVariables[variableName];
                        if (this_1.accumulatedGrads[variableName] == null) {
                            var trainable_1 = false;
                            globals_1.tidy(function () {
                                _this.accumulatedGrads[variableName] = ops_1.zerosLike(value).variable(trainable_1)
                            })
                        }
                        if (this_1.accumulatedUpdates[variableName] == null) {
                            var trainable_2 = false;
                            globals_1.tidy(function () {
                                _this.accumulatedUpdates[variableName] = ops_1.zerosLike(value).variable(trainable_2)
                            })
                        }
                        var gradient = variableGradients[variableName];
                        var accumulatedGrad = this_1.accumulatedGrads[variableName];
                        var accumulatedUpdate = this_1.accumulatedUpdates[variableName];
                        globals_1.tidy(function () {
                            var newAccumulatedGrad = _this.rhoScalar.mul(accumulatedGrad).add(_this.oneMinusRho.mul(gradient.square()));
                            var updates = accumulatedUpdate.add(_this.epsilonScalar).sqrt().div(accumulatedGrad.add(_this.epsilonScalar).sqrt()).mul(gradient);
                            var newAccumulatedUpdate = _this.rhoScalar.mul(accumulatedUpdate).add(_this.oneMinusRho.mul(updates.square()));
                            _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                            _this.accumulatedUpdates[variableName].assign(newAccumulatedUpdate);
                            var newValue = _this.c.mul(updates).add(value);
                            value.assign(newValue)
                        })
                    };
                    var this_1 = this;
                    for (var variableName in variableGradients) {
                        _loop_1(variableName)
                    }
                };
                AdadeltaOptimizer.prototype.dispose = function () {
                    var _this = this;
                    this.c.dispose();
                    this.epsilonScalar.dispose();
                    this.rhoScalar.dispose();
                    this.oneMinusRho.dispose();
                    if (this.accumulatedUpdates != null) {
                        Object.keys(this.accumulatedUpdates).forEach(function (name) {
                            return _this.accumulatedUpdates[name].dispose()
                        });
                        Object.keys(this.accumulatedGrads).forEach(function (name) {
                            return _this.accumulatedGrads[name].dispose()
                        })
                    }
                };
                AdadeltaOptimizer.prototype.getConfig = function () {
                    return {learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon}
                };
                AdadeltaOptimizer.fromConfig = function (cls, config) {
                    return new cls(config.learningRate, config.rho, config.epsilon)
                };
                AdadeltaOptimizer.className = "AdadeltaOptimizer";
                return AdadeltaOptimizer
            }(optimizer_1.Optimizer);
            exports.AdadeltaOptimizer = AdadeltaOptimizer;
            serialization_1.SerializationMap.register(AdadeltaOptimizer)
        }, {"../environment": 47, "../globals": 48, "../ops/ops": 122, "../serialization": 145, "./optimizer": 140}],
        136: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var globals_1 = require("../globals");
            var ops_1 = require("../ops/ops");
            var serialization_1 = require("../serialization");
            var optimizer_1 = require("./optimizer");
            var AdagradOptimizer = function (_super) {
                __extends(AdagradOptimizer, _super);

                function AdagradOptimizer(learningRate, initialAccumulatorValue) {
                    if (initialAccumulatorValue === void 0) {
                        initialAccumulatorValue = .1
                    }
                    var _this = _super.call(this) || this;
                    _this.learningRate = learningRate;
                    _this.initialAccumulatorValue = initialAccumulatorValue;
                    _this.accumulatedGrads = {};
                    _this.c = globals_1.keep(ops_1.scalar(-learningRate));
                    _this.epsilon = globals_1.keep(ops_1.scalar(1e-8));
                    return _this
                }

                AdagradOptimizer.prototype.applyGradients = function (variableGradients) {
                    var _this = this;
                    var _loop_1 = function (variableName) {
                        var value = environment_1.ENV.engine.registeredVariables[variableName];
                        if (this_1.accumulatedGrads[variableName] == null) {
                            var trainable_1 = false;
                            globals_1.tidy(function () {
                                _this.accumulatedGrads[variableName] = ops_1.fill(value.shape, _this.initialAccumulatorValue).variable(trainable_1)
                            })
                        }
                        var gradient = variableGradients[variableName];
                        var accumulatedGrad = this_1.accumulatedGrads[variableName];
                        globals_1.tidy(function () {
                            var newAccumulatedGrad = accumulatedGrad.add(gradient.square());
                            _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                            var newValue = _this.c.mul(gradient.div(newAccumulatedGrad.add(_this.epsilon).sqrt())).add(value);
                            value.assign(newValue)
                        })
                    };
                    var this_1 = this;
                    for (var variableName in variableGradients) {
                        _loop_1(variableName)
                    }
                };
                AdagradOptimizer.prototype.dispose = function () {
                    var _this = this;
                    this.epsilon.dispose();
                    this.c.dispose();
                    if (this.accumulatedGrads != null) {
                        Object.keys(this.accumulatedGrads).forEach(function (name) {
                            return _this.accumulatedGrads[name].dispose()
                        })
                    }
                };
                AdagradOptimizer.prototype.getConfig = function () {
                    return {learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue}
                };
                AdagradOptimizer.fromConfig = function (cls, config) {
                    return new cls(config.learningRate, config.initialAccumulatorValue)
                };
                AdagradOptimizer.className = "AdagradOptimizer";
                return AdagradOptimizer
            }(optimizer_1.Optimizer);
            exports.AdagradOptimizer = AdagradOptimizer;
            serialization_1.SerializationMap.register(AdagradOptimizer)
        }, {"../environment": 47, "../globals": 48, "../ops/ops": 122, "../serialization": 145, "./optimizer": 140}],
        137: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var globals_1 = require("../globals");
            var ops_1 = require("../ops/ops");
            var serialization_1 = require("../serialization");
            var optimizer_1 = require("./optimizer");
            var AdamOptimizer = function (_super) {
                __extends(AdamOptimizer, _super);

                function AdamOptimizer(learningRate, beta1, beta2, epsilon) {
                    if (epsilon === void 0) {
                        epsilon = 1e-8
                    }
                    var _this = _super.call(this) || this;
                    _this.learningRate = learningRate;
                    _this.beta1 = beta1;
                    _this.beta2 = beta2;
                    _this.epsilon = epsilon;
                    _this.accumulatedFirstMoment = {};
                    _this.accumulatedSecondMoment = {};
                    _this.c = globals_1.keep(ops_1.scalar(-learningRate));
                    _this.epsScalar = globals_1.keep(ops_1.scalar(epsilon));
                    _this.beta1Scalar = globals_1.keep(ops_1.scalar(beta1));
                    _this.beta2Scalar = globals_1.keep(ops_1.scalar(beta2));
                    globals_1.tidy(function () {
                        _this.accBeta1 = ops_1.scalar(beta1).variable();
                        _this.accBeta2 = ops_1.scalar(beta2).variable()
                    });
                    _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
                    _this.oneMinusBeta2 = globals_1.keep(ops_1.scalar(1 - beta2));
                    _this.one = globals_1.keep(ops_1.scalar(1));
                    return _this
                }

                AdamOptimizer.prototype.applyGradients = function (variableGradients) {
                    var _this = this;
                    globals_1.tidy(function () {
                        var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
                        var oneMinusAccBeta2 = _this.one.sub(_this.accBeta2);
                        for (var variableName in variableGradients) {
                            var value = environment_1.ENV.engine.registeredVariables[variableName];
                            if (_this.accumulatedFirstMoment[variableName] == null) {
                                var trainable = false;
                                _this.accumulatedFirstMoment[variableName] = ops_1.zerosLike(value).variable(trainable)
                            }
                            if (_this.accumulatedSecondMoment[variableName] == null) {
                                var trainable = false;
                                _this.accumulatedSecondMoment[variableName] = ops_1.zerosLike(value).variable(trainable)
                            }
                            var gradient = variableGradients[variableName];
                            var firstMoment = _this.accumulatedFirstMoment[variableName];
                            var secondMoment = _this.accumulatedSecondMoment[variableName];
                            var newFirstMoment = _this.beta1Scalar.mul(firstMoment).add(_this.oneMinusBeta1.mul(gradient));
                            var newSecondMoment = _this.beta2Scalar.mul(secondMoment).add(_this.oneMinusBeta2.mul(gradient.square()));
                            var biasCorrectedFirstMoment = newFirstMoment.div(oneMinusAccBeta1);
                            var biasCorrectedSecondMoment = newSecondMoment.div(oneMinusAccBeta2);
                            _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                            _this.accumulatedSecondMoment[variableName].assign(newSecondMoment);
                            var newValue = _this.c.mul(biasCorrectedFirstMoment.div(_this.epsScalar.add(biasCorrectedSecondMoment.sqrt()))).add(value);
                            value.assign(newValue)
                        }
                        _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar));
                        _this.accBeta2.assign(_this.accBeta2.mul(_this.beta2Scalar))
                    })
                };
                AdamOptimizer.prototype.dispose = function () {
                    var _this = this;
                    this.c.dispose();
                    this.epsScalar.dispose();
                    this.beta1Scalar.dispose();
                    this.beta2Scalar.dispose();
                    this.accBeta1.dispose();
                    this.accBeta2.dispose();
                    this.oneMinusBeta1.dispose();
                    this.oneMinusBeta2.dispose();
                    this.one.dispose();
                    if (this.accumulatedFirstMoment != null) {
                        Object.keys(this.accumulatedFirstMoment).forEach(function (name) {
                            return _this.accumulatedFirstMoment[name].dispose()
                        })
                    }
                    if (this.accumulatedSecondMoment != null) {
                        Object.keys(this.accumulatedSecondMoment).forEach(function (name) {
                            return _this.accumulatedSecondMoment[name].dispose()
                        })
                    }
                };
                AdamOptimizer.prototype.getConfig = function () {
                    return {
                        learningRate: this.learningRate,
                        beta1: this.beta1,
                        beta2: this.beta2,
                        epsilon: this.epsilon
                    }
                };
                AdamOptimizer.fromConfig = function (cls, config) {
                    return new cls(config.learningRate, config.beta1, config.beta2, config.epsilon)
                };
                AdamOptimizer.className = "AdamOptimizer";
                return AdamOptimizer
            }(optimizer_1.Optimizer);
            exports.AdamOptimizer = AdamOptimizer;
            serialization_1.SerializationMap.register(AdamOptimizer)
        }, {"../environment": 47, "../globals": 48, "../ops/ops": 122, "../serialization": 145, "./optimizer": 140}],
        138: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var globals_1 = require("../globals");
            var ops_1 = require("../ops/ops");
            var serialization_1 = require("../serialization");
            var optimizer_1 = require("./optimizer");
            var AdamaxOptimizer = function (_super) {
                __extends(AdamaxOptimizer, _super);

                function AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay) {
                    if (epsilon === void 0) {
                        epsilon = 1e-8
                    }
                    if (decay === void 0) {
                        decay = 0
                    }
                    var _this = _super.call(this) || this;
                    _this.learningRate = learningRate;
                    _this.beta1 = beta1;
                    _this.beta2 = beta2;
                    _this.epsilon = epsilon;
                    _this.decay = decay;
                    _this.accumulatedFirstMoment = {};
                    _this.accumulatedWeightedInfNorm = {};
                    _this.c = globals_1.keep(ops_1.scalar(-learningRate));
                    _this.epsScalar = globals_1.keep(ops_1.scalar(epsilon));
                    _this.beta1Scalar = globals_1.keep(ops_1.scalar(beta1));
                    _this.beta2Scalar = globals_1.keep(ops_1.scalar(beta2));
                    _this.decayScalar = globals_1.keep(ops_1.scalar(decay));
                    globals_1.tidy(function () {
                        _this.iteration = ops_1.scalar(0).variable();
                        _this.accBeta1 = ops_1.scalar(beta1).variable()
                    });
                    _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
                    _this.one = globals_1.keep(ops_1.scalar(1));
                    return _this
                }

                AdamaxOptimizer.prototype.applyGradients = function (variableGradients) {
                    var _this = this;
                    globals_1.tidy(function () {
                        var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
                        var lr = _this.c.div(_this.one.add(_this.decayScalar.mul(_this.iteration)));
                        for (var variableName in variableGradients) {
                            var value = environment_1.ENV.engine.registeredVariables[variableName];
                            if (_this.accumulatedFirstMoment[variableName] == null) {
                                var trainable = false;
                                _this.accumulatedFirstMoment[variableName] = ops_1.zerosLike(value).variable(trainable)
                            }
                            if (_this.accumulatedWeightedInfNorm[variableName] == null) {
                                var trainable = false;
                                _this.accumulatedWeightedInfNorm[variableName] = ops_1.zerosLike(value).variable(trainable)
                            }
                            var gradient = variableGradients[variableName];
                            var firstMoment = _this.accumulatedFirstMoment[variableName];
                            var weightedInfNorm = _this.accumulatedWeightedInfNorm[variableName];
                            var newFirstMoment = _this.beta1Scalar.mul(firstMoment).add(_this.oneMinusBeta1.mul(gradient));
                            var ut0 = _this.beta2Scalar.mul(weightedInfNorm);
                            var ut1 = gradient.abs();
                            var newWeightedInfNorm = ut0.maximum(ut1);
                            _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                            _this.accumulatedWeightedInfNorm[variableName].assign(newWeightedInfNorm);
                            var newValue = lr.div(oneMinusAccBeta1).mul(newFirstMoment.div(_this.epsScalar.add(newWeightedInfNorm))).add(value);
                            value.assign(newValue)
                        }
                        _this.iteration.assign(_this.iteration.add(_this.one));
                        _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1Scalar))
                    })
                };
                AdamaxOptimizer.prototype.dispose = function () {
                    var _this = this;
                    this.c.dispose();
                    this.epsScalar.dispose();
                    this.accBeta1.dispose();
                    this.beta1Scalar.dispose();
                    this.beta2Scalar.dispose();
                    this.oneMinusBeta1.dispose();
                    this.decayScalar.dispose();
                    this.iteration.dispose();
                    this.one.dispose();
                    if (this.accumulatedFirstMoment != null) {
                        Object.keys(this.accumulatedFirstMoment).forEach(function (name) {
                            return _this.accumulatedFirstMoment[name].dispose()
                        })
                    }
                    if (this.accumulatedWeightedInfNorm != null) {
                        Object.keys(this.accumulatedWeightedInfNorm).forEach(function (name) {
                            return _this.accumulatedWeightedInfNorm[name].dispose()
                        })
                    }
                };
                AdamaxOptimizer.prototype.getConfig = function () {
                    return {
                        learningRate: this.learningRate,
                        beta1: this.beta1,
                        beta2: this.beta2,
                        epsilon: this.epsilon,
                        decay: this.decay
                    }
                };
                AdamaxOptimizer.fromConfig = function (cls, config) {
                    return new cls(config.learningRate, config.beta1, config.beta2, config.epsilon, config.decay)
                };
                AdamaxOptimizer.className = "AdamaxOptimizer";
                return AdamaxOptimizer
            }(optimizer_1.Optimizer);
            exports.AdamaxOptimizer = AdamaxOptimizer;
            serialization_1.SerializationMap.register(AdamaxOptimizer)
        }, {"../environment": 47, "../globals": 48, "../ops/ops": 122, "../serialization": 145, "./optimizer": 140}],
        139: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var globals_1 = require("../globals");
            var ops_1 = require("../ops/ops");
            var serialization_1 = require("../serialization");
            var sgd_optimizer_1 = require("./sgd_optimizer");
            var MomentumOptimizer = function (_super) {
                __extends(MomentumOptimizer, _super);

                function MomentumOptimizer(learningRate, momentum, useNesterov) {
                    if (useNesterov === void 0) {
                        useNesterov = false
                    }
                    var _this = _super.call(this, learningRate) || this;
                    _this.learningRate = learningRate;
                    _this.momentum = momentum;
                    _this.useNesterov = useNesterov;
                    _this.m = ops_1.scalar(_this.momentum);
                    _this.accumulations = {};
                    return _this
                }

                MomentumOptimizer.prototype.applyGradients = function (variableGradients) {
                    var _this = this;
                    var _loop_1 = function (variableName) {
                        var value = environment_1.ENV.engine.registeredVariables[variableName];
                        if (this_1.accumulations[variableName] == null) {
                            var trainable_1 = false;
                            globals_1.tidy(function () {
                                _this.accumulations[variableName] = ops_1.zerosLike(value).variable(trainable_1)
                            })
                        }
                        var accumulation = this_1.accumulations[variableName];
                        var gradient = variableGradients[variableName];
                        globals_1.tidy(function () {
                            var newValue;
                            var newAccumulation = _this.m.mul(accumulation).add(gradient);
                            if (_this.useNesterov) {
                                newValue = _this.c.mul(gradient.add(newAccumulation.mul(_this.m))).add(value)
                            } else {
                                newValue = _this.c.mul(newAccumulation).add(value)
                            }
                            _this.accumulations[variableName].assign(newAccumulation);
                            value.assign(newValue)
                        })
                    };
                    var this_1 = this;
                    for (var variableName in variableGradients) {
                        _loop_1(variableName)
                    }
                };
                MomentumOptimizer.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    this.m.dispose();
                    if (this.accumulations != null) {
                        for (var variableName in this.accumulations) {
                            this.accumulations[variableName].dispose()
                        }
                    }
                };
                MomentumOptimizer.prototype.setMomentum = function (momentum) {
                    this.momentum = momentum
                };
                MomentumOptimizer.prototype.getConfig = function () {
                    return {learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov}
                };
                MomentumOptimizer.fromConfig = function (cls, config) {
                    return new cls(config.learningRate, config.momentum, config.useNesterov)
                };
                MomentumOptimizer.className = "MomentumOptimizer";
                return MomentumOptimizer
            }(sgd_optimizer_1.SGDOptimizer);
            exports.MomentumOptimizer = MomentumOptimizer;
            serialization_1.SerializationMap.register(MomentumOptimizer)
        }, {
            "../environment": 47,
            "../globals": 48,
            "../ops/ops": 122,
            "../serialization": 145,
            "./sgd_optimizer": 143
        }],
        140: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var globals_1 = require("../globals");
            var serialization_1 = require("../serialization");
            var Optimizer = function (_super) {
                __extends(Optimizer, _super);

                function Optimizer() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Optimizer.prototype.minimize = function (f, returnCost, varList) {
                    if (returnCost === void 0) {
                        returnCost = false
                    }
                    var _a = this.computeGradients(f, varList), value = _a.value, grads = _a.grads;
                    this.applyGradients(grads);
                    var varNames = Object.keys(grads);
                    varNames.forEach(function (varName) {
                        return grads[varName].dispose()
                    });
                    if (returnCost) {
                        return value
                    } else {
                        value.dispose();
                        return null
                    }
                };
                Optimizer.prototype.computeGradients = function (f, varList) {
                    return globals_1.variableGrads(f, varList)
                };
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Optimizers"
                })], Optimizer.prototype, "minimize", null);
                Optimizer = __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Classes",
                    namespace: "train"
                })], Optimizer);
                return Optimizer
            }(serialization_1.Serializable);
            exports.Optimizer = Optimizer
        }, {"../doc": 45, "../globals": 48, "../serialization": 145}],
        141: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("../doc");
            var adadelta_optimizer_1 = require("./adadelta_optimizer");
            var adagrad_optimizer_1 = require("./adagrad_optimizer");
            var adam_optimizer_1 = require("./adam_optimizer");
            var adamax_optimizer_1 = require("./adamax_optimizer");
            var momentum_optimizer_1 = require("./momentum_optimizer");
            var rmsprop_optimizer_1 = require("./rmsprop_optimizer");
            var sgd_optimizer_1 = require("./sgd_optimizer");
            var OptimizerConstructors = function () {
                function OptimizerConstructors() {
                }

                OptimizerConstructors.sgd = function (learningRate) {
                    return new sgd_optimizer_1.SGDOptimizer(learningRate)
                };
                OptimizerConstructors.momentum = function (learningRate, momentum, useNesterov) {
                    if (useNesterov === void 0) {
                        useNesterov = false
                    }
                    return new momentum_optimizer_1.MomentumOptimizer(learningRate, momentum, useNesterov)
                };
                OptimizerConstructors.rmsprop = function (learningRate, decay, momentum, epsilon, centered) {
                    if (decay === void 0) {
                        decay = .9
                    }
                    if (momentum === void 0) {
                        momentum = 0
                    }
                    if (epsilon === void 0) {
                        epsilon = 1e-8
                    }
                    if (centered === void 0) {
                        centered = false
                    }
                    return new rmsprop_optimizer_1.RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered)
                };
                OptimizerConstructors.adam = function (learningRate, beta1, beta2, epsilon) {
                    if (learningRate === void 0) {
                        learningRate = .001
                    }
                    if (beta1 === void 0) {
                        beta1 = .9
                    }
                    if (beta2 === void 0) {
                        beta2 = .999
                    }
                    if (epsilon === void 0) {
                        epsilon = 1e-8
                    }
                    return new adam_optimizer_1.AdamOptimizer(learningRate, beta1, beta2, epsilon)
                };
                OptimizerConstructors.adadelta = function (learningRate, rho, epsilon) {
                    if (learningRate === void 0) {
                        learningRate = .001
                    }
                    if (rho === void 0) {
                        rho = .95
                    }
                    if (epsilon === void 0) {
                        epsilon = 1e-8
                    }
                    return new adadelta_optimizer_1.AdadeltaOptimizer(learningRate, rho, epsilon)
                };
                OptimizerConstructors.adamax = function (learningRate, beta1, beta2, epsilon, decay) {
                    if (learningRate === void 0) {
                        learningRate = .002
                    }
                    if (beta1 === void 0) {
                        beta1 = .9
                    }
                    if (beta2 === void 0) {
                        beta2 = .999
                    }
                    if (epsilon === void 0) {
                        epsilon = 1e-8
                    }
                    if (decay === void 0) {
                        decay = 0
                    }
                    return new adamax_optimizer_1.AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay)
                };
                OptimizerConstructors.adagrad = function (learningRate, initialAccumulatorValue) {
                    if (initialAccumulatorValue === void 0) {
                        initialAccumulatorValue = .1
                    }
                    return new adagrad_optimizer_1.AdagradOptimizer(learningRate, initialAccumulatorValue)
                };
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Optimizers",
                    namespace: "train"
                })], OptimizerConstructors, "sgd", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Optimizers",
                    namespace: "train"
                })], OptimizerConstructors, "momentum", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Optimizers",
                    namespace: "train"
                })], OptimizerConstructors, "rmsprop", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Optimizers",
                    namespace: "train"
                })], OptimizerConstructors, "adam", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Optimizers",
                    namespace: "train"
                })], OptimizerConstructors, "adadelta", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Optimizers",
                    namespace: "train"
                })], OptimizerConstructors, "adamax", null);
                __decorate([doc_1.doc({
                    heading: "Training",
                    subheading: "Optimizers",
                    namespace: "train"
                })], OptimizerConstructors, "adagrad", null);
                return OptimizerConstructors
            }();
            exports.OptimizerConstructors = OptimizerConstructors
        }, {
            "../doc": 45,
            "./adadelta_optimizer": 135,
            "./adagrad_optimizer": 136,
            "./adam_optimizer": 137,
            "./adamax_optimizer": 138,
            "./momentum_optimizer": 139,
            "./rmsprop_optimizer": 142,
            "./sgd_optimizer": 143
        }],
        142: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var globals_1 = require("../globals");
            var ops_1 = require("../ops/ops");
            var serialization_1 = require("../serialization");
            var optimizer_1 = require("./optimizer");
            var RMSPropOptimizer = function (_super) {
                __extends(RMSPropOptimizer, _super);

                function RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered) {
                    if (decay === void 0) {
                        decay = .9
                    }
                    if (momentum === void 0) {
                        momentum = 0
                    }
                    if (epsilon === void 0) {
                        epsilon = 1e-8
                    }
                    if (centered === void 0) {
                        centered = false
                    }
                    var _this = _super.call(this) || this;
                    _this.learningRate = learningRate;
                    _this.decay = decay;
                    _this.momentum = momentum;
                    _this.epsilon = epsilon;
                    _this.accumulatedMeanSquares = {};
                    _this.accumulatedMeanGrads = {};
                    _this.accumulatedMoments = {};
                    _this.c = globals_1.keep(ops_1.scalar(learningRate));
                    _this.epsilonScalar = globals_1.keep(ops_1.scalar(epsilon));
                    _this.decayScalar = globals_1.keep(ops_1.scalar(decay));
                    _this.momentumScalar = globals_1.keep(ops_1.scalar(momentum));
                    _this.oneMinusDecay = globals_1.keep(ops_1.scalar(1 - decay));
                    _this.centered = centered;
                    return _this
                }

                RMSPropOptimizer.prototype.applyGradients = function (variableGradients) {
                    var _this = this;
                    var _loop_1 = function (variableName) {
                        var value = environment_1.ENV.engine.registeredVariables[variableName];
                        if (this_1.accumulatedMeanSquares[variableName] == null) {
                            var trainable_1 = false;
                            globals_1.tidy(function () {
                                _this.accumulatedMeanSquares[variableName] = ops_1.zerosLike(value).variable(trainable_1)
                            })
                        }
                        if (this_1.accumulatedMeanGrads[variableName] == null && this_1.centered) {
                            var trainable_2 = false;
                            globals_1.tidy(function () {
                                _this.accumulatedMeanGrads[variableName] = ops_1.zerosLike(value).variable(trainable_2)
                            })
                        }
                        if (this_1.accumulatedMoments[variableName] == null) {
                            var trainable_3 = false;
                            globals_1.tidy(function () {
                                _this.accumulatedMoments[variableName] = ops_1.zerosLike(value).variable(trainable_3)
                            })
                        }
                        var accumulatedMeanSquare = this_1.accumulatedMeanSquares[variableName];
                        var accumulatedMeanGrad = this_1.accumulatedMeanGrads[variableName];
                        var accumulatedMoments = this_1.accumulatedMoments[variableName];
                        var gradient = variableGradients[variableName];
                        globals_1.tidy(function () {
                            var newAccumulatedMeanSquare = _this.decayScalar.mul(accumulatedMeanSquare).add(_this.oneMinusDecay.mul(gradient.square()));
                            if (_this.centered) {
                                var newAccumulatedMeanGrad = _this.decayScalar.mul(accumulatedMeanGrad).add(_this.oneMinusDecay.mul(gradient));
                                var newAccumulatedMoments = _this.momentumScalar.mul(accumulatedMoments).add(_this.c.mul(gradient).div(newAccumulatedMeanSquare.sub(newAccumulatedMeanGrad.square().add(_this.epsilonScalar)).sqrt()));
                                _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare);
                                _this.accumulatedMeanGrads[variableName].assign(newAccumulatedMeanGrad);
                                _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                                var newValue = value.sub(newAccumulatedMoments);
                                value.assign(newValue)
                            } else {
                                var newAccumulatedMeanSquare_1 = _this.decayScalar.mul(accumulatedMeanSquare).add(_this.oneMinusDecay.mul(gradient.square()));
                                var newAccumulatedMoments = _this.momentumScalar.mul(accumulatedMoments).add(_this.c.mul(gradient).div(newAccumulatedMeanSquare_1.add(_this.epsilonScalar).sqrt()));
                                _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare_1);
                                _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                                var newValue = value.sub(newAccumulatedMoments);
                                value.assign(newValue)
                            }
                        })
                    };
                    var this_1 = this;
                    for (var variableName in variableGradients) {
                        _loop_1(variableName)
                    }
                };
                RMSPropOptimizer.prototype.dispose = function () {
                    var _this = this;
                    this.c.dispose();
                    this.epsilonScalar.dispose();
                    this.decayScalar.dispose();
                    this.momentumScalar.dispose();
                    this.oneMinusDecay.dispose();
                    if (this.accumulatedMeanSquares != null) {
                        Object.keys(this.accumulatedMeanSquares).forEach(function (name) {
                            return _this.accumulatedMeanSquares[name].dispose()
                        })
                    }
                    if (this.accumulatedMeanGrads != null && this.centered) {
                        Object.keys(this.accumulatedMeanGrads).forEach(function (name) {
                            return _this.accumulatedMeanGrads[name].dispose()
                        })
                    }
                    if (this.accumulatedMoments != null) {
                        Object.keys(this.accumulatedMoments).forEach(function (name) {
                            return _this.accumulatedMoments[name].dispose()
                        })
                    }
                };
                RMSPropOptimizer.prototype.getConfig = function () {
                    return {
                        learningRate: this.learningRate,
                        decay: this.decay,
                        momentum: this.momentum,
                        epsilon: this.epsilon,
                        centered: this.centered
                    }
                };
                RMSPropOptimizer.fromConfig = function (cls, config) {
                    return new cls(config.learningRate, config.decay, config.momentum, config.epsilon, config.centered)
                };
                RMSPropOptimizer.className = "RMSPropOptimizer";
                return RMSPropOptimizer
            }(optimizer_1.Optimizer);
            exports.RMSPropOptimizer = RMSPropOptimizer;
            serialization_1.SerializationMap.register(RMSPropOptimizer)
        }, {"../environment": 47, "../globals": 48, "../ops/ops": 122, "../serialization": 145, "./optimizer": 140}],
        143: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var globals_1 = require("../globals");
            var ops_1 = require("../ops/ops");
            var serialization_1 = require("../serialization");
            var optimizer_1 = require("./optimizer");
            var SGDOptimizer = function (_super) {
                __extends(SGDOptimizer, _super);

                function SGDOptimizer(learningRate) {
                    var _this = _super.call(this) || this;
                    _this.learningRate = learningRate;
                    _this.setLearningRate(learningRate);
                    return _this
                }

                SGDOptimizer.prototype.applyGradients = function (variableGradients) {
                    var _this = this;
                    var varNames = Object.keys(variableGradients);
                    varNames.forEach(function (varName) {
                        var gradient = variableGradients[varName];
                        var value = environment_1.ENV.engine.registeredVariables[varName];
                        globals_1.tidy(function () {
                            var newValue = _this.c.mul(gradient).add(value);
                            value.assign(newValue)
                        })
                    })
                };
                SGDOptimizer.prototype.setLearningRate = function (learningRate) {
                    this.learningRate = learningRate;
                    if (this.c != null) {
                        this.c.dispose()
                    }
                    this.c = globals_1.keep(ops_1.scalar(-learningRate))
                };
                SGDOptimizer.prototype.dispose = function () {
                    this.c.dispose()
                };
                SGDOptimizer.prototype.getConfig = function () {
                    return {learningRate: this.learningRate}
                };
                SGDOptimizer.fromConfig = function (cls, config) {
                    return new cls(config.learningRate)
                };
                SGDOptimizer.className = "SGDOptimizer";
                return SGDOptimizer
            }(optimizer_1.Optimizer);
            exports.SGDOptimizer = SGDOptimizer;
            serialization_1.SerializationMap.register(SGDOptimizer)
        }, {"../environment": 47, "../globals": 48, "../ops/ops": 122, "../serialization": 145, "./optimizer": 140}],
        144: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("./util");
            var Profiler = function () {
                function Profiler(backendTimer, logger) {
                    this.backendTimer = backendTimer;
                    this.logger = logger;
                    if (logger == null) {
                        this.logger = new Logger
                    }
                }

                Profiler.prototype.profileKernel = function (name, f) {
                    var _this = this;
                    var result;
                    var holdResultWrapperFn = function () {
                        result = f()
                    };
                    var timer = this.backendTimer.time(holdResultWrapperFn);
                    var vals = result.dataSync();
                    util.checkForNaN(vals, result.dtype, name);
                    timer.then(function (timing) {
                        _this.logger.logKernelProfile(name, result, vals, timing.kernelMs)
                    });
                    return result
                };
                return Profiler
            }();
            exports.Profiler = Profiler;
            var Logger = function () {
                function Logger() {
                }

                Logger.prototype.logKernelProfile = function (name, result, vals, timeMs) {
                    var time = util.rightPad(timeMs + "ms", 9);
                    var paddedName = util.rightPad(name, 25);
                    var rank = result.rank;
                    var size = result.size;
                    var shape = util.rightPad(result.shape.toString(), 14);
                    console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, "font-weight:bold", "color:red", "color:blue", "color: orange")
                };
                return Logger
            }();
            exports.Logger = Logger
        }, {"./util": 153}],
        145: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Serializable = function () {
                function Serializable() {
                }

                Serializable.prototype.getClassName = function () {
                    return this.constructor.className
                };
                Serializable.fromConfig = function (cls, config) {
                    return new cls(config)
                };
                return Serializable
            }();
            exports.Serializable = Serializable;
            var SerializationMap = function () {
                function SerializationMap() {
                    this.classNameMap = {}
                }

                SerializationMap.getMap = function () {
                    if (SerializationMap.instance == null) {
                        SerializationMap.instance = new SerializationMap
                    }
                    return SerializationMap.instance
                };
                SerializationMap.register = function (cls) {
                    this.getMap().classNameMap[cls.className] = [cls, cls.fromConfig]
                };
                return SerializationMap
            }();
            exports.SerializationMap = SerializationMap
        }, {}],
        146: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("./util");

            function getFilteredNodesXToY(tape, xs, y) {
                var tensorsFromX = {};
                var nodesFromX = {};
                for (var i = 0; i < xs.length; i++) {
                    tensorsFromX[xs[i].id] = true
                }
                for (var i = 0; i < tape.length; i++) {
                    var node = tape[i];
                    var nodeInputs = node.inputs;
                    for (var inputName in nodeInputs) {
                        var input = nodeInputs[inputName];
                        var anyInputFromX = false;
                        for (var j = 0; j < xs.length; j++) {
                            if (tensorsFromX[input.id]) {
                                tensorsFromX[node.output.id] = true;
                                anyInputFromX = true;
                                nodesFromX[node.id] = true;
                                break
                            }
                        }
                        if (anyInputFromX) {
                            break
                        }
                    }
                }
                var tensorsLeadToY = {};
                tensorsLeadToY[y.id] = true;
                var nodesToY = {};
                for (var i = tape.length - 1; i >= 0; i--) {
                    var node = tape[i];
                    var nodeInputs = node.inputs;
                    var outputs = [];
                    outputs.push(node.output);
                    for (var j = 0; j < outputs.length; j++) {
                        if (tensorsLeadToY[outputs[j].id]) {
                            for (var inputName in nodeInputs) {
                                tensorsLeadToY[nodeInputs[inputName].id] = true;
                                nodesToY[node.id] = true
                            }
                            break
                        }
                    }
                }
                var filteredTape = [];
                for (var i = 0; i < tape.length; i++) {
                    var node = tape[i];
                    if (nodesFromX[node.id] && nodesToY[node.id]) {
                        var prunedInputs = {};
                        for (var inputName in node.inputs) {
                            var nodeInput = node.inputs[inputName];
                            if (tensorsFromX[nodeInput.id]) {
                                prunedInputs[inputName] = nodeInput
                            }
                        }
                        var prunedNode = Object.assign({}, node);
                        prunedNode.inputs = prunedInputs;
                        prunedNode.output = node.output;
                        filteredTape.push(prunedNode)
                    }
                }
                return filteredTape
            }

            exports.getFilteredNodesXToY = getFilteredNodesXToY;

            function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape) {
                for (var i = filteredTape.length - 1; i >= 0; i--) {
                    var node = filteredTape[i];
                    var dy = tensorAccumulatedGradientMap[node.output.id];
                    if (node.gradient == null) {
                        throw new Error("Cannot compute gradient: gradient function not found " + ("for " + node.name + "."))
                    }
                    var inputGradients = node.gradient(dy);
                    for (var inputName in node.inputs) {
                        if (!(inputName in inputGradients)) {
                            throw new Error("Cannot backprop through input " + inputName + ". " + ("Available gradients found: " + Object.keys(inputGradients) + "."))
                        }
                        var dx = inputGradients[inputName]();
                        var x = node.inputs[inputName];
                        if (!util.arraysEqual(dx.shape, x.shape)) {
                            throw new Error("Error in gradient for op " + node.name + ". The gradient of input " + ("'" + inputName + "' has shape '" + dx.shape + "', which does not match ") + ("the shape of the input '" + x.shape + "'"))
                        }
                        if (tensorAccumulatedGradientMap[x.id] == null) {
                            tensorAccumulatedGradientMap[x.id] = dx
                        } else {
                            var curGradient = tensorAccumulatedGradientMap[x.id];
                            tensorAccumulatedGradientMap[x.id] = curGradient.add(dx);
                            curGradient.dispose()
                        }
                    }
                }
            }

            exports.backpropagateGradients = backpropagateGradients
        }, {"./util": 153}],
        147: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("./doc");
            var environment_1 = require("./environment");
            var ops = require("./ops/ops");
            var tensor_util = require("./tensor_util");
            var util = require("./util");
            var TensorBuffer = function () {
                function TensorBuffer(shape, dtype, values) {
                    this.dtype = dtype;
                    if (values != null) {
                        var n = values.length;
                        var size = util.sizeFromShape(shape);
                        util.assert(n === size, "Length of values '" + n + "' does not match the size " + ("inferred by the shape '" + size + "'"))
                    }
                    this.shape = shape.slice();
                    this.values = values || util.getTypedArrayFromDType(dtype, util.sizeFromShape(shape));
                    this.strides = computeStrides(shape);
                    this.size = util.sizeFromShape(shape)
                }

                TensorBuffer.prototype.set = function (value) {
                    var locs = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        locs[_i - 1] = arguments[_i]
                    }
                    if (locs.length === 0) {
                        locs = [0]
                    }
                    util.assert(locs.length === this.rank, "The number of provided coordinates (" + locs.length + ") must " + ("match the rank (" + this.rank + ")"));
                    var index = this.locToIndex(locs);
                    this.values[index] = value
                };
                TensorBuffer.prototype.get = function () {
                    var locs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        locs[_i] = arguments[_i]
                    }
                    if (locs.length === 0) {
                        locs = [0]
                    }
                    var index = locs[locs.length - 1];
                    for (var i = 0; i < locs.length - 1; ++i) {
                        index += this.strides[i] * locs[i]
                    }
                    return this.values[index]
                };
                TensorBuffer.prototype.locToIndex = function (locs) {
                    if (this.rank === 0) {
                        return 0
                    } else if (this.rank === 1) {
                        return locs[0]
                    }
                    var index = locs[locs.length - 1];
                    for (var i = 0; i < locs.length - 1; ++i) {
                        index += this.strides[i] * locs[i]
                    }
                    return index
                };
                TensorBuffer.prototype.indexToLoc = function (index) {
                    if (this.rank === 0) {
                        return []
                    } else if (this.rank === 1) {
                        return [index]
                    }
                    var locs = new Array(this.shape.length);
                    for (var i = 0; i < locs.length - 1; ++i) {
                        locs[i] = Math.floor(index / this.strides[i]);
                        index -= locs[i] * this.strides[i]
                    }
                    locs[locs.length - 1] = index;
                    return locs
                };
                Object.defineProperty(TensorBuffer.prototype, "rank", {
                    get: function () {
                        return this.shape.length
                    }, enumerable: true, configurable: true
                });
                TensorBuffer.prototype.toTensor = function () {
                    return Tensor.make(this.shape, {values: this.values}, this.dtype)
                };
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                })], TensorBuffer.prototype, "set", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                })], TensorBuffer.prototype, "get", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Creation"
                })], TensorBuffer.prototype, "toTensor", null);
                TensorBuffer = __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], TensorBuffer);
                return TensorBuffer
            }();
            exports.TensorBuffer = TensorBuffer;
            var Tensor = function () {
                function Tensor(shape, dtype, values, dataId) {
                    this.isDisposed = false;
                    this.size = util.sizeFromShape(shape);
                    if (values != null) {
                        util.assert(this.size === values.length, "Constructing tensor of shape (" + this.size + ") should match the " + ("length of values (" + values.length + ")"))
                    }
                    this.shape = shape.slice();
                    this.dtype = dtype || "float32";
                    this.strides = computeStrides(shape);
                    this.dataId = dataId != null ? dataId : {};
                    this.id = Tensor_1.nextId++;
                    this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
                    environment_1.ENV.engine.registerTensor(this);
                    if (values != null) {
                        environment_1.ENV.engine.write(this.dataId, values)
                    }
                }

                Tensor_1 = Tensor;
                Tensor.make = function (shape, data, dtype) {
                    return new Tensor_1(shape, dtype, data.values, data.dataId)
                };
                Tensor.prototype.flatten = function () {
                    this.throwIfDisposed();
                    return this.as1D()
                };
                Tensor.prototype.asScalar = function () {
                    this.throwIfDisposed();
                    util.assert(this.size === 1, "The array must have only 1 element.");
                    return this.reshape([])
                };
                Tensor.prototype.as1D = function () {
                    this.throwIfDisposed();
                    return this.reshape([this.size])
                };
                Tensor.prototype.as2D = function (rows, columns) {
                    this.throwIfDisposed();
                    return this.reshape([rows, columns])
                };
                Tensor.prototype.as3D = function (rows, columns, depth) {
                    this.throwIfDisposed();
                    return this.reshape([rows, columns, depth])
                };
                Tensor.prototype.as4D = function (rows, columns, depth, depth2) {
                    this.throwIfDisposed();
                    return this.reshape([rows, columns, depth, depth2])
                };
                Tensor.prototype.asType = function (dtype) {
                    this.throwIfDisposed();
                    return ops.cast(this, dtype)
                };
                Object.defineProperty(Tensor.prototype, "rank", {
                    get: function () {
                        return this.shape.length
                    }, enumerable: true, configurable: true
                });
                Tensor.prototype.get = function () {
                    var locs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        locs[_i] = arguments[_i]
                    }
                    util.assert(locs.length === this.rank, "Number of coordinates in get() must match the rank of the tensor");
                    this.throwIfDisposed();
                    if (locs.length === 0) {
                        locs = [0]
                    }
                    var index = locs[locs.length - 1];
                    for (var i = 0; i < locs.length - 1; ++i) {
                        index += this.strides[i] * locs[i]
                    }
                    return this.dataSync()[index]
                };
                Tensor.prototype.buffer = function () {
                    return ops.buffer(this.shape, this.dtype, this.dataSync())
                };
                Tensor.prototype.data = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            this.throwIfDisposed();
                            return [2, environment_1.ENV.engine.read(this.dataId)]
                        })
                    })
                };
                Tensor.prototype.dataSync = function () {
                    this.throwIfDisposed();
                    return environment_1.ENV.engine.readSync(this.dataId)
                };
                Tensor.prototype.dispose = function () {
                    if (this.isDisposed) {
                        return
                    }
                    this.isDisposed = true;
                    environment_1.ENV.engine.disposeTensor(this)
                };
                Tensor.prototype.throwIfDisposed = function () {
                    if (this.isDisposed) {
                        throw new Error("Tensor is disposed.")
                    }
                };
                Tensor.prototype.toFloat = function () {
                    return this.asType("float32")
                };
                Tensor.prototype.toInt = function () {
                    return this.asType("int32")
                };
                Tensor.prototype.toBool = function () {
                    return this.asType("bool")
                };
                Tensor.prototype.print = function (verbose) {
                    if (verbose === void 0) {
                        verbose = false
                    }
                    return ops.print(this, verbose)
                };
                Tensor.prototype.reshape = function (newShape) {
                    this.throwIfDisposed();
                    return ops.reshape(this, newShape)
                };
                Tensor.prototype.reshapeAs = function (x) {
                    this.throwIfDisposed();
                    return this.reshape(x.shape)
                };
                Tensor.prototype.expandDims = function (axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    return ops.expandDims(this, axis)
                };
                Tensor.prototype.cumsum = function (axis, exclusive, reverse) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    if (exclusive === void 0) {
                        exclusive = false
                    }
                    if (reverse === void 0) {
                        reverse = false
                    }
                    return ops.cumsum(this, axis, exclusive, reverse)
                };
                Tensor.prototype.squeeze = function (axis) {
                    this.throwIfDisposed();
                    return ops.squeeze(this, axis)
                };
                Tensor.prototype.clone = function () {
                    this.throwIfDisposed();
                    return ops.clone(this)
                };
                Tensor.prototype.toString = function (verbose) {
                    if (verbose === void 0) {
                        verbose = false
                    }
                    return tensor_util.tensorToString(this, verbose)
                };
                Tensor.prototype.tile = function (reps) {
                    this.throwIfDisposed();
                    return ops.tile(this, reps)
                };
                Tensor.prototype.gather = function (indices, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    this.throwIfDisposed();
                    return ops.gather(this, indices, axis)
                };
                Tensor.prototype.matMul = function (b, transposeA, transposeB) {
                    if (transposeA === void 0) {
                        transposeA = false
                    }
                    if (transposeB === void 0) {
                        transposeB = false
                    }
                    this.throwIfDisposed();
                    return ops.matMul(this, b, transposeA, transposeB)
                };
                Tensor.prototype.norm = function (ord, axis, keepDims) {
                    if (ord === void 0) {
                        ord = "euclidean"
                    }
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    this.throwIfDisposed();
                    return ops.norm(this, ord, axis, keepDims)
                };
                Tensor.prototype.slice = function (begin, size) {
                    this.throwIfDisposed();
                    return ops.slice(this, begin, size)
                };
                Tensor.prototype.reverse = function (axis) {
                    this.throwIfDisposed();
                    return ops.reverse(this, axis)
                };
                Tensor.prototype.concat = function (x, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    this.throwIfDisposed();
                    return ops.concat([this, x], axis)
                };
                Tensor.prototype.stack = function (x, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    return ops.stack([this, x], axis)
                };
                Tensor.prototype.unstack = function (x, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    return ops.unstack(this, axis)
                };
                Tensor.prototype.pad = function (paddings, constantValue) {
                    if (constantValue === void 0) {
                        constantValue = 0
                    }
                    return ops.pad(this, paddings, constantValue)
                };
                Tensor.prototype.batchNormalization = function (mean, variance, varianceEpsilon, scale, offset) {
                    if (varianceEpsilon === void 0) {
                        varianceEpsilon = .001
                    }
                    this.throwIfDisposed();
                    return ops.batchNormalization(this, mean, variance, varianceEpsilon, scale, offset)
                };
                Tensor.prototype.logSumExp = function (axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    this.throwIfDisposed();
                    return ops.logSumExp(this, axis, keepDims)
                };
                Tensor.prototype.sum = function (axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    this.throwIfDisposed();
                    return ops.sum(this, axis, keepDims)
                };
                Tensor.prototype.mean = function (axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    this.throwIfDisposed();
                    return ops.mean(this, axis, keepDims)
                };
                Tensor.prototype.min = function (axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    this.throwIfDisposed();
                    return ops.min(this, axis, keepDims)
                };
                Tensor.prototype.max = function (axis, keepDims) {
                    if (axis === void 0) {
                        axis = null
                    }
                    if (keepDims === void 0) {
                        keepDims = false
                    }
                    this.throwIfDisposed();
                    return ops.max(this, axis, keepDims)
                };
                Tensor.prototype.argMin = function (axis) {
                    if (axis === void 0) {
                        axis = null
                    }
                    this.throwIfDisposed();
                    return ops.argMin(this, axis)
                };
                Tensor.prototype.argMax = function (axis) {
                    if (axis === void 0) {
                        axis = null
                    }
                    this.throwIfDisposed();
                    return ops.argMax(this, axis)
                };
                Tensor.prototype.cast = function (dtype) {
                    this.throwIfDisposed();
                    return ops.cast(this, dtype)
                };
                Tensor.prototype.add = function (x) {
                    this.throwIfDisposed();
                    return ops.add(this, x)
                };
                Tensor.prototype.addStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.addStrict(this, x)
                };
                Tensor.prototype.sub = function (x) {
                    this.throwIfDisposed();
                    return ops.sub(this, x)
                };
                Tensor.prototype.subStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.subStrict(this, x)
                };
                Tensor.prototype.pow = function (exp) {
                    this.throwIfDisposed();
                    return ops.pow(this, exp)
                };
                Tensor.prototype.powStrict = function (exp) {
                    this.throwIfDisposed();
                    return ops.powStrict(this, exp)
                };
                Tensor.prototype.mul = function (x) {
                    this.throwIfDisposed();
                    return ops.mul(this, x)
                };
                Tensor.prototype.mulStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.mulStrict(this, x)
                };
                Tensor.prototype.div = function (x) {
                    this.throwIfDisposed();
                    return ops.div(this, x)
                };
                Tensor.prototype.divStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.divStrict(this, x)
                };
                Tensor.prototype.minimum = function (x) {
                    this.throwIfDisposed();
                    return ops.minimum(this, x)
                };
                Tensor.prototype.minimumStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.minimumStrict(this, x)
                };
                Tensor.prototype.maximum = function (x) {
                    this.throwIfDisposed();
                    return ops.maximum(this, x)
                };
                Tensor.prototype.maximumStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.maximumStrict(this, x)
                };
                Tensor.prototype.mod = function (x) {
                    this.throwIfDisposed();
                    return ops.mod(this, x)
                };
                Tensor.prototype.modStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.modStrict(this, x)
                };
                Tensor.prototype.squaredDifference = function (x) {
                    this.throwIfDisposed();
                    return ops.squaredDifference(this, x)
                };
                Tensor.prototype.squaredDifferenceStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.squaredDifferenceStrict(this, x)
                };
                Tensor.prototype.transpose = function (perm) {
                    this.throwIfDisposed();
                    return ops.transpose(this, perm)
                };
                Tensor.prototype.notEqual = function (x) {
                    this.throwIfDisposed();
                    return ops.notEqual(this, x)
                };
                Tensor.prototype.notEqualStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.notEqualStrict(this, x)
                };
                Tensor.prototype.less = function (x) {
                    this.throwIfDisposed();
                    return ops.less(this, x)
                };
                Tensor.prototype.lessStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.lessStrict(this, x)
                };
                Tensor.prototype.equal = function (x) {
                    this.throwIfDisposed();
                    return ops.equal(this, x)
                };
                Tensor.prototype.equalStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.equalStrict(this, x)
                };
                Tensor.prototype.lessEqual = function (x) {
                    this.throwIfDisposed();
                    return ops.lessEqual(this, x)
                };
                Tensor.prototype.lessEqualStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.lessEqualStrict(this, x)
                };
                Tensor.prototype.greater = function (x) {
                    this.throwIfDisposed();
                    return ops.greater(this, x)
                };
                Tensor.prototype.greaterStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.greaterStrict(this, x)
                };
                Tensor.prototype.greaterEqual = function (x) {
                    this.throwIfDisposed();
                    return ops.greaterEqual(this, x)
                };
                Tensor.prototype.greaterEqualStrict = function (x) {
                    this.throwIfDisposed();
                    return ops.greaterEqualStrict(this, x)
                };
                Tensor.prototype.logicalAnd = function (x) {
                    this.throwIfDisposed();
                    return ops.logicalAnd(this, x)
                };
                Tensor.prototype.logicalOr = function (x) {
                    this.throwIfDisposed();
                    return ops.logicalOr(this, x)
                };
                Tensor.prototype.logicalNot = function () {
                    this.throwIfDisposed();
                    return ops.logicalNot(this)
                };
                Tensor.prototype.logicalXor = function (x) {
                    this.throwIfDisposed();
                    return ops.logicalXor(this, x)
                };
                Tensor.prototype.where = function (condition, x) {
                    this.throwIfDisposed();
                    return ops.where(condition, this, x)
                };
                Tensor.prototype.neg = function () {
                    this.throwIfDisposed();
                    return ops.neg(this)
                };
                Tensor.prototype.ceil = function () {
                    this.throwIfDisposed();
                    return ops.ceil(this)
                };
                Tensor.prototype.floor = function () {
                    this.throwIfDisposed();
                    return ops.floor(this)
                };
                Tensor.prototype.sign = function () {
                    this.throwIfDisposed();
                    return ops.sign(this)
                };
                Tensor.prototype.exp = function () {
                    this.throwIfDisposed();
                    return ops.exp(this)
                };
                Tensor.prototype.expm1 = function () {
                    this.throwIfDisposed();
                    return ops.expm1(this)
                };
                Tensor.prototype.log = function () {
                    this.throwIfDisposed();
                    return ops.log(this)
                };
                Tensor.prototype.log1p = function () {
                    this.throwIfDisposed();
                    return ops.log1p(this)
                };
                Tensor.prototype.sqrt = function () {
                    this.throwIfDisposed();
                    return ops.sqrt(this)
                };
                Tensor.prototype.rsqrt = function () {
                    this.throwIfDisposed();
                    return ops.rsqrt(this)
                };
                Tensor.prototype.square = function () {
                    this.throwIfDisposed();
                    return ops.square(this)
                };
                Tensor.prototype.reciprocal = function () {
                    this.throwIfDisposed();
                    return ops.reciprocal(this)
                };
                Tensor.prototype.abs = function () {
                    this.throwIfDisposed();
                    return ops.abs(this)
                };
                Tensor.prototype.clipByValue = function (min, max) {
                    this.throwIfDisposed();
                    return ops.clipByValue(this, min, max)
                };
                Tensor.prototype.relu = function () {
                    this.throwIfDisposed();
                    return ops.relu(this)
                };
                Tensor.prototype.elu = function () {
                    this.throwIfDisposed();
                    return ops.elu(this)
                };
                Tensor.prototype.selu = function () {
                    this.throwIfDisposed();
                    return ops.selu(this)
                };
                Tensor.prototype.leakyRelu = function (alpha) {
                    if (alpha === void 0) {
                        alpha = .2
                    }
                    this.throwIfDisposed();
                    return ops.leakyRelu(this, alpha)
                };
                Tensor.prototype.prelu = function (alpha) {
                    this.throwIfDisposed();
                    return ops.prelu(this, alpha)
                };
                Tensor.prototype.sigmoid = function () {
                    this.throwIfDisposed();
                    return ops.sigmoid(this)
                };
                Tensor.prototype.logSigmoid = function () {
                    this.throwIfDisposed();
                    return ops.logSigmoid(this)
                };
                Tensor.prototype.softplus = function () {
                    this.throwIfDisposed();
                    return ops.softplus(this)
                };
                Tensor.prototype.sin = function () {
                    this.throwIfDisposed();
                    return ops.sin(this)
                };
                Tensor.prototype.cos = function () {
                    this.throwIfDisposed();
                    return ops.cos(this)
                };
                Tensor.prototype.tan = function () {
                    this.throwIfDisposed();
                    return ops.tan(this)
                };
                Tensor.prototype.asin = function () {
                    this.throwIfDisposed();
                    return ops.asin(this)
                };
                Tensor.prototype.acos = function () {
                    this.throwIfDisposed();
                    return ops.acos(this)
                };
                Tensor.prototype.atan = function () {
                    this.throwIfDisposed();
                    return ops.atan(this)
                };
                Tensor.prototype.sinh = function () {
                    this.throwIfDisposed();
                    return ops.sinh(this)
                };
                Tensor.prototype.cosh = function () {
                    this.throwIfDisposed();
                    return ops.cosh(this)
                };
                Tensor.prototype.tanh = function () {
                    this.throwIfDisposed();
                    return ops.tanh(this)
                };
                Tensor.prototype.asinh = function () {
                    this.throwIfDisposed();
                    return ops.asinh(this)
                };
                Tensor.prototype.acosh = function () {
                    this.throwIfDisposed();
                    return ops.acosh(this)
                };
                Tensor.prototype.atanh = function () {
                    this.throwIfDisposed();
                    return ops.atanh(this)
                };
                Tensor.prototype.erf = function () {
                    this.throwIfDisposed();
                    return ops.erf(this)
                };
                Tensor.prototype.round = function () {
                    this.throwIfDisposed();
                    return ops.round(this)
                };
                Tensor.prototype.step = function (alpha) {
                    if (alpha === void 0) {
                        alpha = 0
                    }
                    this.throwIfDisposed();
                    return ops.step(this, alpha)
                };
                Tensor.prototype.softmax = function (dim) {
                    if (dim === void 0) {
                        dim = -1
                    }
                    this.throwIfDisposed();
                    return ops.softmax(this, dim)
                };
                Tensor.prototype.resizeBilinear = function (newShape2D, alignCorners) {
                    if (alignCorners === void 0) {
                        alignCorners = false
                    }
                    this.throwIfDisposed();
                    return ops.image.resizeBilinear(this, newShape2D, alignCorners)
                };
                Tensor.prototype.resizeNearestNeighbor = function (newShape2D, alignCorners) {
                    if (alignCorners === void 0) {
                        alignCorners = false
                    }
                    this.throwIfDisposed();
                    return ops.image.resizeNearestNeighbor(this, newShape2D, alignCorners)
                };
                Tensor.prototype.conv1d = function (filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
                    if (dataFormat === void 0) {
                        dataFormat = "NWC"
                    }
                    if (dilation === void 0) {
                        dilation = 1
                    }
                    this.throwIfDisposed();
                    return ops.conv1d(this, filter, stride, pad, dataFormat, dilation, dimRoundingMode)
                };
                Tensor.prototype.conv2d = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
                    if (dataFormat === void 0) {
                        dataFormat = "NHWC"
                    }
                    if (dilations === void 0) {
                        dilations = [1, 1]
                    }
                    this.throwIfDisposed();
                    return ops.conv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode)
                };
                Tensor.prototype.conv2dTranspose = function (filter, outputShape, strides, pad, dimRoundingMode) {
                    this.throwIfDisposed();
                    return ops.conv2dTranspose(this, filter, outputShape, strides, pad, dimRoundingMode)
                };
                Tensor.prototype.depthwiseConv2D = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
                    if (dataFormat === void 0) {
                        dataFormat = "NHWC"
                    }
                    if (dilations === void 0) {
                        dilations = [1, 1]
                    }
                    this.throwIfDisposed();
                    return ops.depthwiseConv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode)
                };
                Tensor.prototype.avgPool = function (filterSize, strides, pad, dimRoundingMode) {
                    this.throwIfDisposed();
                    return ops.avgPool(this, filterSize, strides, pad, dimRoundingMode)
                };
                Tensor.prototype.maxPool = function (filterSize, strides, pad, dimRoundingMode) {
                    this.throwIfDisposed();
                    return ops.maxPool(this, filterSize, strides, pad, dimRoundingMode)
                };
                Tensor.prototype.localResponseNormalization = function (radius, bias, alpha, beta) {
                    if (radius === void 0) {
                        radius = 5
                    }
                    if (bias === void 0) {
                        bias = 1
                    }
                    if (alpha === void 0) {
                        alpha = 1
                    }
                    if (beta === void 0) {
                        beta = .5
                    }
                    return ops.localResponseNormalization(this, radius, bias, alpha, beta)
                };
                Tensor.prototype.variable = function (trainable, name, dtype) {
                    if (trainable === void 0) {
                        trainable = true
                    }
                    this.throwIfDisposed();
                    return Variable.variable(this, trainable, name, dtype)
                };
                Tensor.prototype.unsortedSegmentSum = function (segmentIds, numSegments, axis) {
                    if (axis === void 0) {
                        axis = 0
                    }
                    this.throwIfDisposed();
                    return ops.unsortedSegmentSum(this, segmentIds, numSegments, axis)
                };
                Tensor.nextId = 0;
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "flatten", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Classes"
                })], Tensor.prototype, "asScalar", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "as1D", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "as2D", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "as3D", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "as4D", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "asType", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "buffer", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "data", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Classes"
                })], Tensor.prototype, "dataSync", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "dispose", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "toFloat", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "toInt", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "toBool", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "print", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "reshape", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Classes"
                })], Tensor.prototype, "reshapeAs", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Classes"
                })], Tensor.prototype, "expandDims", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "cumsum", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "squeeze", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor.prototype, "clone", null);
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Classes"
                })], Tensor.prototype, "toString", null);
                Tensor = Tensor_1 = __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Tensor);
                return Tensor;
                var Tensor_1
            }();
            exports.Tensor = Tensor;
            var Variable = function (_super) {
                __extends(Variable, _super);

                function Variable(initialValue, trainable, name) {
                    if (trainable === void 0) {
                        trainable = true
                    }
                    var _this = _super.call(this, initialValue.shape, initialValue.dtype, null, initialValue.dataId) || this;
                    _this.trainable = trainable;
                    _this.name = name;
                    if (_this.name == null) {
                        _this.name = Variable_1.nextVarId.toString();
                        Variable_1.nextVarId++
                    }
                    environment_1.ENV.engine.registerVariable(_this);
                    return _this
                }

                Variable_1 = Variable;
                Variable.variable = function (initialValue, trainable, name, dtype) {
                    if (trainable === void 0) {
                        trainable = true
                    }
                    if (dtype != null && dtype !== initialValue.dtype) {
                        initialValue = initialValue.asType(dtype)
                    }
                    return new Variable_1(initialValue, trainable, name)
                };
                Variable.prototype.assign = function (newValue) {
                    if (newValue.dtype !== this.dtype) {
                        throw new Error("dtype of the new value (" + newValue.dtype + ") and " + ("previous value (" + this.dtype + ") must match"))
                    }
                    if (!util.arraysEqual(newValue.shape, this.shape)) {
                        throw new Error("shape of the new value (" + newValue.shape + ") and " + ("previous value (" + this.shape + ") must match"))
                    }
                    environment_1.ENV.engine.disposeTensor(this);
                    this.dataId = newValue.dataId;
                    environment_1.ENV.engine.registerTensor(this)
                };
                Variable.nextVarId = 0;
                __decorate([doc_1.doc({
                    heading: "Tensors",
                    subheading: "Classes"
                })], Variable.prototype, "assign", null);
                __decorate([doc_1.doc({heading: "Tensors", subheading: "Creation"})], Variable, "variable", null);
                Variable = Variable_1 = __decorate([doc_1.doc({heading: "Tensors", subheading: "Classes"})], Variable);
                return Variable;
                var Variable_1
            }(Tensor);
            exports.Variable = Variable;
            var variable = Variable.variable;
            exports.variable = variable;

            function computeStrides(shape) {
                var rank = shape.length;
                if (rank < 2) {
                    return []
                }
                var strides = new Array(rank - 1);
                strides[rank - 2] = shape[rank - 1];
                for (var i = rank - 3; i >= 0; --i) {
                    strides[i] = strides[i + 1] * shape[i + 1]
                }
                return strides
            }
        }, {"./doc": 45, "./environment": 47, "./ops/ops": 122, "./tensor_util": 148, "./util": 153}],
        148: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("./util");
            var FORMAT_LIMIT_NUM_VALS = 20;
            var FORMAT_NUM_FIRST_LAST_VALS = 3;
            var FORMAT_NUM_SIG_DIGITS = 7;

            function tensorToString(t, verbose) {
                var vals = t.dataSync();
                var padPerCol = computeMaxSizePerColumn(t);
                var valsLines = subTensorToString(vals, t.shape, t.strides, padPerCol);
                var lines = ["Tensor"];
                if (verbose) {
                    lines.push("  dtype: " + t.dtype);
                    lines.push("  rank: " + t.rank);
                    lines.push("  shape: [" + t.shape + "]");
                    lines.push("  values:")
                }
                lines.push(valsLines.map(function (l) {
                    return "    " + l
                }).join("\n"));
                return lines.join("\n")
            }

            exports.tensorToString = tensorToString;

            function computeMaxSizePerColumn(t) {
                var vals = t.dataSync();
                var n = t.size;
                var numCols = t.strides[t.strides.length - 1];
                var padPerCol = new Array(numCols).fill(0);
                if (t.rank > 1) {
                    for (var row = 0; row < n / numCols; row++) {
                        var offset = row * numCols;
                        for (var j = 0; j < numCols; j++) {
                            padPerCol[j] = Math.max(padPerCol[j], valToString(vals[offset + j], 0).length)
                        }
                    }
                }
                return padPerCol
            }

            function valToString(val, pad) {
                return util.rightPad(parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(), pad)
            }

            function subTensorToString(vals, shape, strides, padPerCol, isLast) {
                if (isLast === void 0) {
                    isLast = true
                }
                var size = shape[0];
                var rank = shape.length;
                if (rank === 0) {
                    return [vals[0].toString()]
                }
                if (rank === 1) {
                    if (size > FORMAT_LIMIT_NUM_VALS) {
                        var firstVals = Array.from(vals.subarray(0, FORMAT_NUM_FIRST_LAST_VALS));
                        var lastVals = Array.from(vals.subarray(size - FORMAT_NUM_FIRST_LAST_VALS, size));
                        return ["[" + firstVals.map(function (x, i) {
                            return valToString(x, padPerCol[i])
                        }).join(", ") + ", ..., " + lastVals.map(function (x, i) {
                            return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i])
                        }).join(", ") + "]"]
                    }
                    return ["[" + Array.from(vals).map(function (x, i) {
                        return valToString(x, padPerCol[i])
                    }).join(", ") + "]"]
                }
                var subshape = shape.slice(1);
                var substrides = strides.slice(1);
                var stride = strides[0];
                var lines = [];
                if (size > FORMAT_LIMIT_NUM_VALS) {
                    for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
                        var start = i * stride;
                        var end = start + stride;
                        lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, false))
                    }
                    lines.push("...");
                    for (var i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
                        var start = i * stride;
                        var end = start + stride;
                        lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1))
                    }
                } else {
                    for (var i = 0; i < size; i++) {
                        var start = i * stride;
                        var end = start + stride;
                        lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1))
                    }
                }
                var sep = rank === 2 ? "," : "";
                lines[0] = "[" + lines[0] + sep;
                for (var i = 1; i < lines.length - 1; i++) {
                    lines[i] = " " + lines[i] + sep
                }
                var newLineSep = ",\n";
                for (var i = 2; i < rank; i++) {
                    newLineSep += "\n"
                }
                lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
                return lines
            }
        }, {"./util": 153}],
        149: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tensor_1 = require("./tensor");
            var util = require("./util");
            exports.WEBGL_ENVS = {BACKEND: "test-webgl"};
            exports.CPU_ENVS = {BACKEND: "test-cpu"};
            exports.ALL_ENVS = {};
            exports.TEST_EPSILON = .001;

            function expectArraysClose(actual, expected, epsilon) {
                if (epsilon === void 0) {
                    epsilon = exports.TEST_EPSILON
                }
                if (!(actual instanceof tensor_1.Tensor) && !(expected instanceof tensor_1.Tensor)) {
                    var aType = actual.constructor.name;
                    var bType = expected.constructor.name;
                    if (aType !== bType) {
                        throw new Error("Arrays are of different type actual: " + aType + " " + ("vs expected: " + bType))
                    }
                } else if (actual instanceof tensor_1.Tensor && expected instanceof tensor_1.Tensor) {
                    if (actual.dtype !== expected.dtype) {
                        throw new Error("Arrays are of different type actual: " + actual.dtype + " " + ("vs expected: " + expected.dtype + "."))
                    }
                    if (!util.arraysEqual(actual.shape, expected.shape)) {
                        throw new Error("Arrays are of different shape actual: " + actual.shape + " " + ("vs expected: " + expected.shape + "."))
                    }
                }
                var actualValues;
                var expectedValues;
                if (actual instanceof tensor_1.Tensor) {
                    actualValues = actual.dataSync()
                } else {
                    actualValues = actual
                }
                if (expected instanceof tensor_1.Tensor) {
                    expectedValues = expected.dataSync()
                } else {
                    expectedValues = expected
                }
                if (actualValues.length !== expectedValues.length) {
                    throw new Error("Arrays have different lengths actual: " + actualValues.length + " vs " + ("expected: " + expectedValues.length + ".\n") + ("Actual:   " + actualValues + ".\n") + ("Expected: " + expectedValues + "."))
                }
                for (var i = 0; i < expectedValues.length; ++i) {
                    var a = actualValues[i];
                    var e = expectedValues[i];
                    if (!areClose(a, Number(e), epsilon)) {
                        throw new Error("Arrays differ: actual[" + i + "] = " + a + ", expected[" + i + "] = " + e + ".\n" + ("Actual:   " + actualValues + ".\n") + ("Expected: " + expectedValues + "."))
                    }
                }
            }

            exports.expectArraysClose = expectArraysClose;

            function expectPromiseToFail(fn, done) {
                fn().then(function () {
                    return done.fail()
                }, function () {
                    return done()
                })
            }

            exports.expectPromiseToFail = expectPromiseToFail;

            function expectArraysEqual(actual, expected) {
                return expectArraysClose(actual, expected, 0)
            }

            exports.expectArraysEqual = expectArraysEqual;

            function expectNumbersClose(a, e, epsilon) {
                if (epsilon === void 0) {
                    epsilon = exports.TEST_EPSILON
                }
                if (!areClose(a, e, epsilon)) {
                    throw new Error("Numbers differ: actual === " + a + ", expected === " + e)
                }
            }

            exports.expectNumbersClose = expectNumbersClose;

            function areClose(a, e, epsilon) {
                if (isNaN(a) && isNaN(e)) {
                    return true
                }
                if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
                    return false
                }
                return true
            }

            function expectValuesInRange(actual, low, high) {
                var actualVals;
                if (actual instanceof tensor_1.Tensor) {
                    actualVals = actual.dataSync()
                } else {
                    actualVals = actual
                }
                for (var i = 0; i < actualVals.length; i++) {
                    if (actualVals[i] < low || actualVals[i] > high) {
                        throw new Error("Value out of range:" + actualVals[i] + " low: " + low + ", high: " + high)
                    }
                }
            }

            exports.expectValuesInRange = expectValuesInRange
        }, {"./tensor": 147, "./util": 153}],
        150: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var doc_1 = require("./doc");
            var environment_1 = require("./environment");
            var util_1 = require("./util");
            var Tracking = function () {
                function Tracking() {
                }

                Tracking.tidy = function (nameOrFn, fn, gradMode) {
                    if (gradMode === void 0) {
                        gradMode = false
                    }
                    var name = null;
                    if (fn == null) {
                        if (typeof nameOrFn !== "function") {
                            throw new Error("Please provide a function to tidy()")
                        }
                        fn = nameOrFn
                    } else {
                        if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
                            throw new Error("When calling with two arguments, the first argument " + "to tidy() must be a string")
                        }
                        if (typeof fn !== "function") {
                            throw new Error("When calling with two arguments, the 2nd argument " + "to tidy() must be a function")
                        }
                        name = nameOrFn
                    }
                    environment_1.ENV.engine.startScope(name, gradMode);
                    var result = fn();
                    if (result instanceof Promise) {
                        console.error("Cannot return a Promise inside of tidy.")
                    }
                    environment_1.ENV.engine.endScope(result, gradMode);
                    return result
                };
                Tracking.dispose = function (container) {
                    var tensors = util_1.extractTensorsFromAny(container);
                    tensors.forEach(function (tensor) {
                        return tensor.dispose()
                    })
                };
                Tracking.keep = function (result) {
                    return environment_1.ENV.engine.keep(result)
                };
                Tracking.time = function (f) {
                    return environment_1.ENV.engine.time(f)
                };
                __decorate([doc_1.doc({heading: "Performance", subheading: "Memory"})], Tracking, "tidy", null);
                __decorate([doc_1.doc({heading: "Performance", subheading: "Memory"})], Tracking, "keep", null);
                __decorate([doc_1.doc({heading: "Performance", subheading: "Timing"})], Tracking, "time", null);
                return Tracking
            }();
            exports.Tracking = Tracking
        }, {"./doc": 45, "./environment": 47, "./util": 153}],
        151: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
            var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
            var adam_optimizer_1 = require("./optimizers/adam_optimizer");
            var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
            var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
            var optimizer_constructors_1 = require("./optimizers/optimizer_constructors");
            var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
            var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
            [momentum_optimizer_1.MomentumOptimizer, sgd_optimizer_1.SGDOptimizer, adadelta_optimizer_1.AdadeltaOptimizer, adagrad_optimizer_1.AdagradOptimizer, rmsprop_optimizer_1.RMSPropOptimizer, adamax_optimizer_1.AdamaxOptimizer, adam_optimizer_1.AdamOptimizer];
            exports.train = {
                sgd: optimizer_constructors_1.OptimizerConstructors.sgd,
                momentum: optimizer_constructors_1.OptimizerConstructors.momentum,
                adadelta: optimizer_constructors_1.OptimizerConstructors.adadelta,
                adagrad: optimizer_constructors_1.OptimizerConstructors.adagrad,
                rmsprop: optimizer_constructors_1.OptimizerConstructors.rmsprop,
                adamax: optimizer_constructors_1.OptimizerConstructors.adamax,
                adam: optimizer_constructors_1.OptimizerConstructors.adam
            }
        }, {
            "./optimizers/adadelta_optimizer": 135,
            "./optimizers/adagrad_optimizer": 136,
            "./optimizers/adam_optimizer": 137,
            "./optimizers/adamax_optimizer": 138,
            "./optimizers/momentum_optimizer": 139,
            "./optimizers/optimizer_constructors": 141,
            "./optimizers/rmsprop_optimizer": 142,
            "./optimizers/sgd_optimizer": 143
        }],
        152: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var DType;
            (function (DType) {
                DType["float32"] = "float32";
                DType["int32"] = "int32";
                DType["bool"] = "bool"
            })(DType = exports.DType || (exports.DType = {}));
            var Rank;
            (function (Rank) {
                Rank["R0"] = "R0";
                Rank["R1"] = "R1";
                Rank["R2"] = "R2";
                Rank["R3"] = "R3";
                Rank["R4"] = "R4"
            })(Rank = exports.Rank || (exports.Rank = {}));
            var UpcastInt32AndMap;
            (function (UpcastInt32AndMap) {
                UpcastInt32AndMap["float32"] = "float32";
                UpcastInt32AndMap["int32"] = "int32";
                UpcastInt32AndMap["bool"] = "int32"
            })(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
            var UpcastBoolAndMap;
            (function (UpcastBoolAndMap) {
                UpcastBoolAndMap["float32"] = "float32";
                UpcastBoolAndMap["int32"] = "int32";
                UpcastBoolAndMap["bool"] = "bool"
            })(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
            var UpcastFloat32AndMap;
            (function (UpcastFloat32AndMap) {
                UpcastFloat32AndMap["float32"] = "float32";
                UpcastFloat32AndMap["int32"] = "float32";
                UpcastFloat32AndMap["bool"] = "float32"
            })(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
            var upcastTypeMap = {float32: UpcastFloat32AndMap, int32: UpcastInt32AndMap, bool: UpcastBoolAndMap};

            function upcastType(typeA, typeB) {
                return upcastTypeMap[typeA][typeB]
            }

            exports.upcastType = upcastType;

            function sumOutType(type) {
                return upcastType(type, "int32")
            }

            exports.sumOutType = sumOutType
        }, {}],
        153: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tensor_1 = require("./tensor");

            function assertArgumentIsTensor(x, argName, functionName) {
                assert(x instanceof tensor_1.Tensor, "Argument '" + argName + "' passed to '" + functionName + "' must be a Tensor, " + ("but got " + typeof x + "."))
            }

            function assertArgumentsAreTensors(args, functionName) {
                var _loop_1 = function (argName) {
                    var arg = args[argName];
                    if (Array.isArray(arg)) {
                        arg.forEach(function (t, i) {
                            assertArgumentIsTensor(t, argName + "[" + i + "]", functionName)
                        })
                    } else {
                        assertArgumentIsTensor(arg, argName, functionName)
                    }
                };
                for (var argName in args) {
                    _loop_1(argName)
                }
            }

            exports.assertArgumentsAreTensors = assertArgumentsAreTensors;

            function shuffle(array) {
                var counter = array.length;
                var temp = 0;
                var index = 0;
                while (counter > 0) {
                    index = Math.random() * counter | 0;
                    counter--;
                    temp = array[counter];
                    array[counter] = array[index];
                    array[index] = temp
                }
            }

            exports.shuffle = shuffle;

            function clamp(min, x, max) {
                return Math.max(min, Math.min(x, max))
            }

            exports.clamp = clamp;

            function randUniform(a, b) {
                return Math.random() * (b - a) + a
            }

            exports.randUniform = randUniform;

            function distSquared(a, b) {
                var result = 0;
                for (var i = 0; i < a.length; i++) {
                    var diff = Number(a[i]) - Number(b[i]);
                    result += diff * diff
                }
                return result
            }

            exports.distSquared = distSquared;

            function assert(expr, msg) {
                if (!expr) {
                    throw new Error(msg)
                }
            }

            exports.assert = assert;

            function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
                if (errorMessagePrefix === void 0) {
                    errorMessagePrefix = ""
                }
                assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match"))
            }

            exports.assertShapesMatch = assertShapesMatch;

            function assertTypesMatch(a, b) {
                assert(a.dtype === b.dtype, " The dtypes of the first(" + a.dtype + ") and" + (" second(" + b.dtype + ") input must match"))
            }

            exports.assertTypesMatch = assertTypesMatch;

            function flatten(arr, ret) {
                if (ret === void 0) {
                    ret = []
                }
                if (Array.isArray(arr)) {
                    for (var i = 0; i < arr.length; ++i) {
                        flatten(arr[i], ret)
                    }
                } else {
                    ret.push(arr)
                }
                return ret
            }

            exports.flatten = flatten;

            function inferShape(val) {
                if (isTypedArray(val)) {
                    return [val.length]
                }
                if (!Array.isArray(val)) {
                    return []
                }
                var shape = [];
                while (val instanceof Array) {
                    shape.push(val.length);
                    val = val[0]
                }
                return shape
            }

            exports.inferShape = inferShape;

            function sizeFromShape(shape) {
                if (shape.length === 0) {
                    return 1
                }
                var size = shape[0];
                for (var i = 1; i < shape.length; i++) {
                    size *= shape[i]
                }
                return size
            }

            exports.sizeFromShape = sizeFromShape;

            function isScalarShape(shape) {
                return shape.length === 0
            }

            exports.isScalarShape = isScalarShape;

            function arraysEqual(n1, n2) {
                if (n1.length !== n2.length) {
                    return false
                }
                for (var i = 0; i < n1.length; i++) {
                    if (n1[i] !== n2[i]) {
                        return false
                    }
                }
                return true
            }

            exports.arraysEqual = arraysEqual;

            function isInt(a) {
                return a % 1 === 0
            }

            exports.isInt = isInt;

            function tanh(x) {
                if (Math.tanh != null) {
                    return Math.tanh(x)
                }
                if (x === Infinity) {
                    return 1
                } else if (x === -Infinity) {
                    return -1
                } else {
                    var e2x = Math.exp(2 * x);
                    return (e2x - 1) / (e2x + 1)
                }
            }

            exports.tanh = tanh;

            function sizeToSquarishShape(size) {
                for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
                    if (size % a === 0) {
                        return [a, size / a]
                    }
                }
                return [1, size]
            }

            exports.sizeToSquarishShape = sizeToSquarishShape;

            function createShuffledIndices(n) {
                var shuffledIndices = new Uint32Array(n);
                for (var i = 0; i < n; ++i) {
                    shuffledIndices[i] = i
                }
                shuffle(shuffledIndices);
                return shuffledIndices
            }

            exports.createShuffledIndices = createShuffledIndices;

            function rightPad(a, size) {
                if (size <= a.length) {
                    return a
                }
                return a + " ".repeat(size - a.length)
            }

            exports.rightPad = rightPad;

            function repeatedTry(checkFn, delayFn, maxCounter) {
                if (delayFn === void 0) {
                    delayFn = function (counter) {
                        return 0
                    }
                }
                return new Promise(function (resolve, reject) {
                    var tryCount = 0;
                    var tryFn = function () {
                        if (checkFn()) {
                            resolve();
                            return
                        }
                        tryCount++;
                        var nextBackoff = delayFn(tryCount);
                        if (maxCounter != null && tryCount >= maxCounter) {
                            reject();
                            return
                        }
                        setTimeout(tryFn, nextBackoff)
                    };
                    setTimeout(tryFn, 0)
                })
            }

            exports.repeatedTry = repeatedTry;

            function getQueryParams(queryString) {
                var params = {};
                queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
                    var t = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        t[_i - 1] = arguments[_i]
                    }
                    decodeParam(params, t[0], t[1]);
                    return t.join("=")
                });
                return params
            }

            exports.getQueryParams = getQueryParams;

            function decodeParam(params, name, value) {
                params[decodeURIComponent(name)] = decodeURIComponent(value || "")
            }

            function inferFromImplicitShape(shape, size) {
                var shapeProd = 1;
                var implicitIdx = -1;
                for (var i = 0; i < shape.length; ++i) {
                    if (shape[i] > 0) {
                        shapeProd *= shape[i]
                    } else if (shape[i] === -1) {
                        if (implicitIdx !== -1) {
                            throw Error("Shapes can only have 1 implicit size. " + ("Found - 1 at dim " + implicitIdx + " and dim " + i))
                        }
                        implicitIdx = i
                    } else if (shape[i] <= 0) {
                        throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i)
                    }
                }
                if (implicitIdx === -1) {
                    if (size > 0 && size !== shapeProd) {
                        throw Error("Size(" + size + ") must match the product of shape " + shape)
                    }
                    return shape
                }
                if (size % shapeProd !== 0) {
                    throw Error("The implicit shape can't be a fractional number. " + ("Got " + size + " / " + shapeProd))
                }
                var newShape = shape.slice();
                newShape[implicitIdx] = size / shapeProd;
                return newShape
            }

            exports.inferFromImplicitShape = inferFromImplicitShape;

            function squeezeShape(shape, axis) {
                var newShape = [];
                var keptDims = [];
                var j = 0;
                for (var i = 0; i < shape.length; ++i) {
                    if (axis != null) {
                        if (axis[j] === i && shape[i] > 1) {
                            throw new Error("Can't squeeze axis " + i + " since its dim '" + shape[i] + "' is not 1")
                        }
                        if ((axis[j] == null || axis[j] > i) && shape[i] === 1) {
                            newShape.push(shape[i]);
                            keptDims.push(i)
                        }
                        if (axis[j] <= i) {
                            j++
                        }
                    }
                    if (shape[i] > 1) {
                        newShape.push(shape[i]);
                        keptDims.push(i)
                    }
                }
                return {newShape: newShape, keptDims: keptDims}
            }

            exports.squeezeShape = squeezeShape;

            function getTypedArrayFromDType(dtype, size) {
                var values = null;
                if (dtype == null || dtype === "float32") {
                    values = new Float32Array(size)
                } else if (dtype === "int32") {
                    values = new Int32Array(size)
                } else if (dtype === "bool") {
                    values = new Uint8Array(size)
                } else {
                    throw new Error("Unknown data type " + dtype)
                }
                return values
            }

            exports.getTypedArrayFromDType = getTypedArrayFromDType;

            function isTensorInList(tensor, tensorList) {
                for (var i = 0; i < tensorList.length; i++) {
                    if (tensorList[i].id === tensor.id) {
                        return true
                    }
                }
                return false
            }

            exports.isTensorInList = isTensorInList;

            function checkForNaN(vals, dtype, name) {
                if (dtype !== "float32") {
                    return
                }
                for (var i = 0; i < vals.length; i++) {
                    if (isNaN(vals[i])) {
                        throw Error("The result of the '" + name + "' has NaNs.")
                    }
                }
            }

            exports.checkForNaN = checkForNaN;

            function flattenNameArrayMap(nameArrayMap, keys) {
                var xs = [];
                if (nameArrayMap instanceof tensor_1.Tensor) {
                    xs.push(nameArrayMap)
                } else {
                    var xMap = nameArrayMap;
                    for (var i = 0; i < keys.length; i++) {
                        xs.push(xMap[keys[i]])
                    }
                }
                return xs
            }

            exports.flattenNameArrayMap = flattenNameArrayMap;

            function unflattenToNameArrayMap(keys, flatArrays) {
                if (keys.length !== flatArrays.length) {
                    throw new Error("Cannot unflatten Tensor[], keys and arrays are not of same length.")
                }
                var result = {};
                for (var i = 0; i < keys.length; i++) {
                    result[keys[i]] = flatArrays[i]
                }
                return result
            }

            exports.unflattenToNameArrayMap = unflattenToNameArrayMap;

            function hasEncodingLoss(oldType, newType) {
                if (newType === "float32") {
                    return false
                }
                if (newType === "int32" && oldType !== "float32") {
                    return false
                }
                if (newType === "bool" && oldType === "bool") {
                    return false
                }
                return true
            }

            exports.hasEncodingLoss = hasEncodingLoss;

            function copyTypedArray(array, dtype) {
                if (dtype == null || dtype === "float32") {
                    return new Float32Array(array)
                } else if (dtype === "int32") {
                    return new Int32Array(array)
                } else if (dtype === "bool") {
                    var bool = new Uint8Array(array.length);
                    for (var i = 0; i < bool.length; ++i) {
                        if (Math.round(array[i]) !== 0) {
                            bool[i] = 1
                        }
                    }
                    return bool
                } else {
                    throw new Error("Unknown data type " + dtype)
                }
            }

            exports.copyTypedArray = copyTypedArray;

            function isTypedArray(a) {
                return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array
            }

            exports.isTypedArray = isTypedArray;

            function bytesPerElement(dtype) {
                if (dtype === "float32" || dtype === "int32") {
                    return 4
                } else if (dtype === "bool") {
                    return 1
                } else {
                    throw new Error("Unknown dtype " + dtype)
                }
            }

            exports.bytesPerElement = bytesPerElement;

            function isFunction(f) {
                return !!(f && f.constructor && f.call && f.apply)
            }

            exports.isFunction = isFunction;

            function extractTensorsFromContainer(result) {
                return extractTensorsFromAny(result)
            }

            exports.extractTensorsFromContainer = extractTensorsFromContainer;

            function extractTensorsFromAny(result) {
                if (result == null) {
                    return []
                }
                if (result instanceof tensor_1.Tensor) {
                    return [result]
                }
                var list = [];
                var resultObj = result;
                if (!isIterable(resultObj)) {
                    return []
                }
                for (var k in resultObj) {
                    var sublist = flatten(resultObj[k]).filter(function (x) {
                        return x instanceof tensor_1.Tensor
                    });
                    list.push.apply(list, sublist)
                }
                return list
            }

            exports.extractTensorsFromAny = extractTensorsFromAny;

            function isIterable(obj) {
                return Array.isArray(obj) || typeof obj === "object"
            }
        }, {"./tensor": 147}],
        154: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var version = "0.11.1";
            exports.version = version
        }, {}],
        155: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var webgl_util = require("./kernels/webgl/webgl_util");
            exports.webgl_util = webgl_util;
            var gpgpu_util = require("./kernels/webgl/gpgpu_util");
            exports.gpgpu_util = gpgpu_util;
            var backend_webgl_1 = require("./kernels/backend_webgl");
            exports.MathBackendWebGL = backend_webgl_1.MathBackendWebGL;
            var gpgpu_context_1 = require("./kernels/webgl/gpgpu_context");
            exports.GPGPUContext = gpgpu_context_1.GPGPUContext
        }, {
            "./kernels/backend_webgl": 63,
            "./kernels/webgl/gpgpu_context": 76,
            "./kernels/webgl/gpgpu_util": 78,
            "./kernels/webgl/webgl_util": 100
        }],
        156: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var generic_utils_1 = require("./utils/generic_utils");
            var Activation = function (_super) {
                __extends(Activation, _super);

                function Activation() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Activation.prototype.getConfig = function () {
                    return {}
                };
                return Activation
            }(tfjs_core_1.serialization.Serializable);
            exports.Activation = Activation;
            var Elu = function (_super) {
                __extends(Elu, _super);

                function Elu() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Elu.prototype.apply = function (x, alpha) {
                    if (alpha === void 0) {
                        alpha = 1
                    }
                    return K.elu(x, alpha)
                };
                Elu.className = "elu";
                return Elu
            }(Activation);
            exports.Elu = Elu;
            tfjs_core_1.serialization.SerializationMap.register(Elu);
            var Selu = function (_super) {
                __extends(Selu, _super);

                function Selu() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Selu.prototype.apply = function (x) {
                    return tfc.selu(x)
                };
                Selu.className = "selu";
                return Selu
            }(Activation);
            exports.Selu = Selu;
            tfjs_core_1.serialization.SerializationMap.register(Selu);
            var Relu = function (_super) {
                __extends(Relu, _super);

                function Relu() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Relu.prototype.apply = function (x) {
                    return tfc.relu(x)
                };
                Relu.className = "relu";
                return Relu
            }(Activation);
            exports.Relu = Relu;
            tfjs_core_1.serialization.SerializationMap.register(Relu);
            var Relu6 = function (_super) {
                __extends(Relu6, _super);

                function Relu6() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Relu6.prototype.apply = function (x) {
                    return tfjs_core_1.tidy(function () {
                        return tfc.minimum(K.getScalar(6), tfc.relu(x))
                    })
                };
                Relu6.className = "relu6";
                return Relu6
            }(Activation);
            exports.Relu6 = Relu6;
            tfjs_core_1.serialization.SerializationMap.register(Relu6);
            var Linear = function (_super) {
                __extends(Linear, _super);

                function Linear() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Linear.prototype.apply = function (x) {
                    return x
                };
                Linear.className = "linear";
                return Linear
            }(Activation);
            exports.Linear = Linear;
            tfjs_core_1.serialization.SerializationMap.register(Linear);
            var Sigmoid = function (_super) {
                __extends(Sigmoid, _super);

                function Sigmoid() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Sigmoid.prototype.apply = function (x) {
                    return tfc.sigmoid(x)
                };
                Sigmoid.className = "sigmoid";
                return Sigmoid
            }(Activation);
            exports.Sigmoid = Sigmoid;
            tfjs_core_1.serialization.SerializationMap.register(Sigmoid);
            var HardSigmoid = function (_super) {
                __extends(HardSigmoid, _super);

                function HardSigmoid() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                HardSigmoid.prototype.apply = function (x) {
                    return K.hardSigmoid(x)
                };
                HardSigmoid.className = "hardSigmoid";
                return HardSigmoid
            }(Activation);
            exports.HardSigmoid = HardSigmoid;
            tfjs_core_1.serialization.SerializationMap.register(HardSigmoid);
            var Softplus = function (_super) {
                __extends(Softplus, _super);

                function Softplus() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Softplus.prototype.apply = function (x) {
                    return tfc.softplus(x)
                };
                Softplus.className = "softplus";
                return Softplus
            }(Activation);
            exports.Softplus = Softplus;
            tfjs_core_1.serialization.SerializationMap.register(Softplus);
            var Softsign = function (_super) {
                __extends(Softsign, _super);

                function Softsign() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Softsign.prototype.apply = function (x) {
                    return K.softsign(x)
                };
                Softsign.className = "softsign";
                return Softsign
            }(Activation);
            exports.Softsign = Softsign;
            tfjs_core_1.serialization.SerializationMap.register(Softsign);
            var Tanh = function (_super) {
                __extends(Tanh, _super);

                function Tanh() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Tanh.prototype.apply = function (x) {
                    return tfc.tanh(x)
                };
                Tanh.className = "tanh";
                return Tanh
            }(Activation);
            exports.Tanh = Tanh;
            tfjs_core_1.serialization.SerializationMap.register(Tanh);
            var Softmax = function (_super) {
                __extends(Softmax, _super);

                function Softmax() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Softmax.prototype.apply = function (x, axis) {
                    if (axis === void 0) {
                        axis = -1
                    }
                    return tfc.softmax(x, axis)
                };
                Softmax.className = "softmax";
                return Softmax
            }(Activation);
            exports.Softmax = Softmax;
            tfjs_core_1.serialization.SerializationMap.register(Softmax);

            function serializeActivation(activation) {
                return activation.getClassName()
            }

            exports.serializeActivation = serializeActivation;

            function deserializeActivation(config, customObjects) {
                if (customObjects === void 0) {
                    customObjects = {}
                }
                return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, "activation")
            }

            exports.deserializeActivation = deserializeActivation;

            function getActivation(identifier) {
                if (identifier == null) {
                    var config = {className: "linear", config: {}};
                    return deserializeActivation(config)
                }
                if (typeof identifier === "string") {
                    var config = {className: identifier, config: {}};
                    return deserializeActivation(config)
                } else if (identifier instanceof Activation) {
                    return identifier
                } else {
                    return deserializeActivation(identifier)
                }
            }

            exports.getActivation = getActivation
        }, {"./backend/tfjs_backend": 158, "./utils/generic_utils": 188, "@tensorflow/tfjs-core": 50}],
        157: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var _epsilon = 1e-7;

            function epsilon() {
                return _epsilon
            }

            exports.epsilon = epsilon;

            function setEpsilon(e) {
                _epsilon = e
            }

            exports.setEpsilon = setEpsilon;

            function imageDataFormat() {
                return "channelsLast"
            }

            exports.imageDataFormat = imageDataFormat
        }, {}],
        158: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var common_1 = require("../common");
            var errors_1 = require("../errors");
            var math_utils = require("../utils/math_utils");
            var variables_1 = require("../variables");
            var common_2 = require("./common");
            var common_3 = require("./common");
            var backend = "webgl";
            var DEFAULT_DTYPE = "float32";

            function disposeScalarCache() {
                for (var typeKey in scalarCache) {
                    for (var key in scalarCache[typeKey]) {
                        scalarCache[typeKey][key].dispose();
                        delete scalarCache[typeKey][key]
                    }
                }
            }

            exports.disposeScalarCache = disposeScalarCache;

            function setBackend(requestedBackend) {
                tfc.setBackend(requestedBackend);
                backend = requestedBackend;
                disposeScalarCache()
            }

            exports.setBackend = setBackend;

            function getBackend() {
                return backend
            }

            exports.getBackend = getBackend;
            var scalarCache = {float32: {}, int32: {}};

            function getScalar(value, dtype) {
                if (dtype === undefined) {
                    dtype = DEFAULT_DTYPE
                }
                if (scalarCache[dtype][value] == null) {
                    scalarCache[dtype][value] = tfjs_core_1.scalar(value, dtype);
                    tfc.keep(scalarCache[dtype][value])
                }
                return scalarCache[dtype][value]
            }

            exports.getScalar = getScalar;
            exports.epsilon = common_2.epsilon;

            function isBackendSymbolic() {
                return false
            }

            exports.isBackendSymbolic = isBackendSymbolic;

            function shape(x) {
                return x.shape
            }

            exports.shape = shape;

            function intShape(x) {
                return x.shape
            }

            exports.intShape = intShape;

            function dtype(x) {
                return x instanceof tfjs_core_1.Tensor ? DEFAULT_DTYPE : x.dtype
            }

            exports.dtype = dtype;

            function countParams(x) {
                var shape = x.shape;
                if (shape.length > 0) {
                    return shape.reduce(function (a, b) {
                        return a * b
                    })
                } else {
                    return 1
                }
            }

            exports.countParams = countParams;

            function cast(x, dtype) {
                return x.asType(dtype)
            }

            exports.cast = cast;

            function expandDims(x, axis) {
                if (axis === void 0) {
                    axis = -1
                }
                var outShape = shape(x).slice();
                if (axis < 0) {
                    axis = outShape.length + axis + 1
                }
                outShape.splice(axis, 0, 1);
                return x.reshape(outShape)
            }

            exports.expandDims = expandDims;

            function repeat(x, n) {
                return tfjs_core_1.tidy(function () {
                    if (x.shape.length !== 2) {
                        throw new errors_1.ValueError("repeat() expects a rank-2 tensor, but received a " + ("rank-" + x.shape.length + " tensor."))
                    }
                    var y = expandDims(x, 1);
                    return tile(y, [1, n, 1])
                })
            }

            exports.repeat = repeat;

            function flatten(x) {
                var newShape = [math_utils.arrayProd(x.shape)];
                return x.reshape(newShape)
            }

            exports.flatten = flatten;

            function batchFlatten(x) {
                if (x.rank <= 1) {
                    throw new errors_1.ValueError("batchFlatten requires a minimum rank of 2. Got rank: " + x.rank + ".")
                }
                var newShape = [x.shape[0], math_utils.arrayProd(x.shape, 1)];
                return x.reshape(newShape)
            }

            exports.batchFlatten = batchFlatten;

            function sliceAlongFirstAxis(array, start, size) {
                return tfjs_core_1.tidy(function () {
                    switch (array.rank) {
                        case 1:
                            return tfc.slice1d(array, start, size);
                        case 2:
                            return tfc.slice2d(array, [start, 0], [size, array.shape[1]]);
                        case 3:
                            return tfc.slice3d(array, [start, 0, 0], [size, array.shape[1], array.shape[2]]);
                        case 4:
                            return tfc.slice4d(array, [start, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3]]);
                        default:
                            throw new errors_1.ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: " + ("" + array.rank))
                    }
                })
            }

            exports.sliceAlongFirstAxis = sliceAlongFirstAxis;

            function sliceAlongLastAxis(array, start, size) {
                return tfjs_core_1.tidy(function () {
                    switch (array.rank) {
                        case 1:
                            return tfc.slice1d(array, start, size);
                        case 2:
                            return tfc.slice2d(array, [0, start], [array.shape[0], size]);
                        case 3:
                            return tfc.slice3d(array, [0, 0, start], [array.shape[0], array.shape[1], size]);
                        case 4:
                            return tfc.slice4d(array, [0, 0, 0, start], [array.shape[0], array.shape[1], array.shape[2], size]);
                        default:
                            throw new errors_1.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + ("" + array.rank))
                    }
                })
            }

            exports.sliceAlongLastAxis = sliceAlongLastAxis;

            function sliceAlongAxis(array, start, size, axis) {
                return tfjs_core_1.tidy(function () {
                    switch (array.rank) {
                        case 1:
                            return tfc.slice1d(array, start, size);
                        case 2:
                            switch (axis) {
                                case 1:
                                    return sliceAlongFirstAxis(array, start, size);
                                case 2:
                                    return sliceAlongLastAxis(array, start, size);
                                default:
                                    throw new errors_1.ValueError("The axis is not within the rank of the tensor " + ("" + axis))
                            }
                        case 3:
                            switch (axis) {
                                case 1:
                                    return sliceAlongFirstAxis(array, start, size);
                                case 2:
                                    return tfc.slice3d(array, [0, start, 0], [array.shape[0], size, array.shape[2]]);
                                case 3:
                                    return sliceAlongLastAxis(array, start, size);
                                default:
                                    throw new errors_1.ValueError("The axis is not within the rank of the tensor " + ("" + axis))
                            }
                        case 4:
                            switch (axis) {
                                case 1:
                                    return sliceAlongFirstAxis(array, start, size);
                                case 2:
                                    return tfc.slice4d(array, [0, start, 0, 0], [array.shape[0], size, array.shape[2], array.shape[3]]);
                                case 3:
                                    return tfc.slice4d(array, [0, 0, start, 0], [array.shape[0], array.shape[1], size, array.shape[3]]);
                                case 4:
                                    return sliceAlongLastAxis(array, start, size);
                                default:
                                    throw new errors_1.ValueError("The axis is not within the rank of the tensor " + ("" + axis))
                            }
                        default:
                            throw new errors_1.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + ("" + array.rank))
                    }
                })
            }

            exports.sliceAlongAxis = sliceAlongAxis;

            function concatenate(tensors, axis) {
                if (axis === void 0) {
                    axis = -1
                }
                var rank;
                if (axis < 0) {
                    rank = tensors[0].rank;
                    if (rank !== 0) {
                        axis = rank
                    } else {
                        axis = 0
                    }
                }
                if (axis === tensors[0].rank) {
                    axis = -1
                }
                return tfc.concat(tensors, axis)
            }

            exports.concatenate = concatenate;

            function concatAlongFirstAxis(a, b) {
                switch (a.rank) {
                    case 1:
                        return tfc.concat1d([a, b]);
                    case 2:
                        return tfc.concat2d([a, b], 0);
                    case 3:
                        return tfc.concat3d([a, b], 0);
                    case 4:
                        return tfc.concat4d([a, b], 0);
                    default:
                        throw new errors_1.ValueError("concatAlongFirstAxis() received an unsupported tensor rank: " + a.rank)
                }
            }

            exports.concatAlongFirstAxis = concatAlongFirstAxis;

            function tile(x, n) {
                if (!Array.isArray(n)) {
                    n = [n]
                }
                if (x.rank !== n.length) {
                    throw new errors_1.ValueError("The length of input n (" + n.length + ") does not match " + ("the number of dimensions in input x (" + x.rank + ")"))
                }
                return tfc.tile(x, n)
            }

            exports.tile = tile;

            function identity(x) {
                return x.clone()
            }

            exports.identity = identity;

            function eyeVariable(size, dtype, name) {
                return new variables_1.LayerVariable(tfc.eye(size, size, null, dtype), dtype, name)
            }

            exports.eyeVariable = eyeVariable;

            function scalarTimesArray(c, x) {
                return tfc.mul(c, x)
            }

            exports.scalarTimesArray = scalarTimesArray;

            function scalarPlusArray(c, x) {
                return tfc.add(c, x)
            }

            exports.scalarPlusArray = scalarPlusArray;

            function randomNormal(shape, mean, stddev, dtype, seed) {
                if (mean === void 0) {
                    mean = 0
                }
                if (stddev === void 0) {
                    stddev = 1
                }
                return tfc.randomNormal(shape, mean, stddev, dtype, seed)
            }

            exports.randomNormal = randomNormal;

            function dot(x, y) {
                if (y.rank !== 2) {
                    throw new errors_1.NotImplementedError("dot support for y other than rank 2 is not yet implemented: " + ("y shape = " + shape))
                } else {
                    if (x.rank === 2) {
                        return tfc.matMul(x, y)
                    } else if (x.rank === 3) {
                        var xShape0 = x.shape[0];
                        var xShape1 = x.shape[1];
                        var xShape2 = x.shape[2];
                        x = x.reshape([xShape0 * xShape1, xShape2]);
                        return tfc.matMul(x, y).reshape([xShape0, xShape1, y.shape[1]])
                    } else {
                        throw new errors_1.NotImplementedError("dot support for x of rank " + x.rank + " is not yet implemented: " + ("x shape = " + shape))
                    }
                }
            }

            exports.dot = dot;

            function sign(x) {
                return tfjs_core_1.tidy(function () {
                    var zerosLikeX = tfjs_core_1.zerosLike(x);
                    var onesLikeX = tfjs_core_1.onesLike(x);
                    return tfjs_core_1.where(tfc.equal(x, zerosLikeX), zerosLikeX, tfjs_core_1.where(tfc.greater(x, tfjs_core_1.zerosLike(x)), onesLikeX, scalarTimesArray(getScalar(-1), onesLikeX)))
                })
            }

            exports.sign = sign;

            function qr(x) {
                var _a = tfjs_core_1.tidy(function () {
                    if (x.shape.length !== 2) {
                        throw new errors_1.ValueError("qr() requires a 2D Tensor, but got a " + x.shape.length + "D Tensor.")
                    }
                    if (x.shape[0] < x.shape[1]) {
                        throw new errors_1.ValueError("qr() requires x.shape[0] >= x.shape[1], but got shape: [" + x.shape + "]")
                    }
                    var m = x.shape[0];
                    var n = x.shape[1];
                    var q = tfc.eye(m);
                    var r = x.clone();
                    var one2D = tfjs_core_1.tensor2d([[1]], [1, 1]);
                    var w = one2D.clone();
                    var _loop_1 = function (j) {
                        var rTemp = r;
                        var wTemp = w;
                        var qTemp = q;
                        _a = tfjs_core_1.tidy(function () {
                            var rjEnd1 = r.slice([j, j], [m - j, 1]);
                            var normX = tfc.norm(rjEnd1);
                            var rjj = r.slice([j, j], [1, 1]);
                            var s = tfc.neg(sign(rjj));
                            var u1 = rjj.sub(tfc.mul(s, normX));
                            var wPre = tfc.div(rjEnd1, u1);
                            if (wPre.shape[0] === 1) {
                                w = one2D.clone()
                            } else {
                                w = one2D.concat(wPre.slice([1, 0], [wPre.shape[0] - 1, wPre.shape[1]]), 0)
                            }
                            var tau = tfc.neg(tfc.div(tfc.matMul(s, u1), normX));
                            var rjEndAll = r.slice([j, 0], [m - j, n]);
                            var tauTimesW = tau.mul(w);
                            if (j === 0) {
                                r = rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll)))
                            } else {
                                r = r.slice([0, 0], [j, n]).concat(rjEndAll.sub(tauTimesW.matMul(w.transpose().matMul(rjEndAll))), 0)
                            }
                            var qAllJEnd = q.slice([0, j], [m, q.shape[1] - j]);
                            if (j === 0) {
                                q = qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose()))
                            } else {
                                q = q.slice([0, 0], [m, j]).concat(qAllJEnd.sub(qAllJEnd.matMul(w).matMul(tauTimesW.transpose())), 1)
                            }
                            return [w, r, q]
                        }), w = _a[0], r = _a[1], q = _a[2];
                        tfjs_core_1.dispose([rTemp, wTemp, qTemp]);
                        var _a
                    };
                    for (var j = 0; j < n; ++j) {
                        _loop_1(j)
                    }
                    return [q, r]
                }), qOuter = _a[0], rOuter = _a[1];
                return [qOuter, rOuter]
            }

            exports.qr = qr;

            function oneHot(indices, numClasses) {
                return tfjs_core_1.tidy(function () {
                    if (indices.rank !== 1) {
                        throw new Error("Only 1D one-hot tensors are supported in the " + "deeplearn backend, at present.")
                    }
                    indices = indices.toInt();
                    return tfc.oneHot(indices, numClasses).toFloat()
                })
            }

            exports.oneHot = oneHot;

            function gather(reference, indices, axis) {
                return tfjs_core_1.tidy(function () {
                    if (Array.isArray(indices)) {
                        indices = tfjs_core_1.tensor1d(indices, "int32")
                    } else {
                        indices = indices.toInt()
                    }
                    return tfc.gather(reference, indices, axis)
                })
            }

            exports.gather = gather;

            function square(x) {
                return tfc.mulStrict(x, x)
            }

            exports.square = square;

            function pow(x, a) {
                return tfjs_core_1.tidy(function () {
                    if (typeof a === "number") {
                        a = tfjs_core_1.scalar(Math.round(a), "int32")
                    }
                    if (a.dtype !== "int32") {
                        throw new errors_1.NotImplementedError("Non-int32 dtype (" + a.dtype + ") is not supported by pow() yet")
                    }
                    return tfc.pow(x, a)
                })
            }

            exports.pow = pow;

            function biasAdd(x, bias, dataFormat) {
                return tfjs_core_1.tidy(function () {
                    if (dataFormat == null) {
                        dataFormat = common_3.imageDataFormat()
                    }
                    common_1.checkDataFormat(dataFormat);
                    if (bias.rank !== 1 && bias.rank !== x.rank) {
                        throw new errors_1.ValueError("Unexpected bias dimensions: " + bias.rank + "; expected it to be 1 or " + x.rank)
                    }
                    var biasShape = bias.shape;
                    var y;
                    if (x.rank === 5) {
                        if (dataFormat === "channelsFirst") {
                            if (biasShape.length === 1) {
                                y = x.add(bias.reshape([1, biasShape[0], 1, 1, 1]))
                            } else {
                                y = x.add(bias.reshape([1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]))
                            }
                        } else if (dataFormat === "channelsLast") {
                            if (biasShape.length === 1) {
                                y = x.add(bias.reshape([1, 1, 1, 1, biasShape[0]]))
                            } else {
                                y = x.add(bias.reshape([1].concat(biasShape)))
                            }
                        }
                    } else if (x.rank === 4) {
                        if (dataFormat === "channelsFirst") {
                            if (biasShape.length === 1) {
                                y = x.add(bias.reshape([1, biasShape[0], 1, 1]))
                            } else {
                                y = x.add(bias.reshape([1, biasShape[2], biasShape[0], biasShape[1]]))
                            }
                        } else if (dataFormat === "channelsLast") {
                            if (biasShape.length === 1) {
                                y = x.add(bias.reshape([1, 1, 1, biasShape[0]]))
                            } else {
                                y = x.add(bias.reshape([1].concat(biasShape)))
                            }
                        }
                    } else if (x.rank === 3) {
                        if (dataFormat === "channelsFirst") {
                            if (biasShape.length === 1) {
                                y = x.add(bias.reshape([1, biasShape[0], 1]))
                            } else {
                                y = x.add(bias.reshape([1, biasShape[1], biasShape[0]]))
                            }
                        } else if (dataFormat === "channelsLast") {
                            if (biasShape.length === 1) {
                                y = x.add(bias.reshape([1, 1, biasShape[0]]))
                            } else {
                                y = x.add(bias.reshape([1].concat(biasShape)))
                            }
                        }
                    } else if (x.rank < 3) {
                        y = x.add(bias)
                    } else {
                        throw new errors_1.ValueError("Unsupported input rank by biasAdd: " + x.rank)
                    }
                    return y
                })
            }

            exports.biasAdd = biasAdd;

            function elu(x, alpha) {
                if (alpha === void 0) {
                    alpha = 1
                }
                if (alpha !== 1) {
                    throw new errors_1.NotImplementedError("Support for alpha values other than 1 (" + alpha + ") is not implemented " + "yet.")
                }
                return tfc.elu(x)
            }

            exports.elu = elu;

            function softsign(x) {
                return tfjs_core_1.tidy(function () {
                    return tfc.div(x, tfc.add(getScalar(1), tfc.abs(x)))
                })
            }

            exports.softsign = softsign;

            function dropout(x, level, noiseShape, seed) {
                return tfjs_core_1.tidy(function () {
                    if (noiseShape != null && !tfjs_core_1.util.arraysEqual(x.shape, noiseShape)) {
                        throw new errors_1.NotImplementedError("Non-default noise shape is not implemented yet: " + JSON.stringify(noiseShape))
                    }
                    if (seed != null) {
                        throw new errors_1.NotImplementedError("seed is not implemented for dropout yet.")
                    }
                    var multiplier = tfc.step(tfc.add(tfc.neg(level), tfc.randomUniform(x.shape, 0, 1, "float32")));
                    multiplier = tfc.mul(tfc.div(getScalar(1), tfc.sub(getScalar(1), level)), multiplier);
                    return tfc.mul(x, multiplier)
                })
            }

            exports.dropout = dropout;

            function nameScope(name, fn) {
                return common_1.nameScope(name, fn)
            }

            exports.nameScope = nameScope;

            function floatx() {
                return "float32"
            }

            exports.floatx = floatx;
            var _uidPrefixes = {};

            function getUid(prefix) {
                if (prefix === void 0) {
                    prefix = ""
                }
                if (!(prefix in _uidPrefixes)) {
                    _uidPrefixes[prefix] = 0
                }
                _uidPrefixes[prefix] += 1;
                return prefix + _uidPrefixes[prefix].toString()
            }

            exports.getUid = getUid;

            function hardSigmoid(x) {
                return tfjs_core_1.tidy(function () {
                    var y = scalarPlusArray(getScalar(.5), scalarTimesArray(getScalar(.2), x));
                    return tfc.clipByValue(y, 0, 1)
                })
            }

            exports.hardSigmoid = hardSigmoid;

            function inTrainPhase(x, alt, training) {
                if (training === void 0) {
                    training = false
                }
                return training ? x() : alt()
            }

            exports.inTrainPhase = inTrainPhase;

            function gradients(lossFn, variables) {
                var variableList = variables.map(function (variable) {
                    return variable.read()
                });
                var valudAndGrads = tfjs_core_1.variableGrads(lossFn, variableList);
                return variables.map(function (variable) {
                    return valudAndGrads.grads[variable.name]
                })
            }

            exports.gradients = gradients
        }, {
            "../common": 160,
            "../errors": 165,
            "../utils/math_utils": 189,
            "../variables": 191,
            "./common": 157,
            "@tensorflow/tfjs-core": 50
        }],
        159: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var generic_utils = require("./utils/generic_utils");
            var Callback = function () {
                function Callback() {
                    this.validationData = null;
                    this.model = null
                }

                Callback.prototype.setParams = function (params) {
                    this.params = params
                };
                Callback.prototype.setModel = function (model) {
                    this.model = model
                };
                Callback.prototype.onEpochBegin = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2]
                        })
                    })
                };
                Callback.prototype.onEpochEnd = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2]
                        })
                    })
                };
                Callback.prototype.onBatchBegin = function (batch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2]
                        })
                    })
                };
                Callback.prototype.onBatchEnd = function (batch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2]
                        })
                    })
                };
                Callback.prototype.onTrainBegin = function (logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2]
                        })
                    })
                };
                Callback.prototype.onTrainEnd = function (logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2]
                        })
                    })
                };
                return Callback
            }();
            exports.Callback = Callback;
            var CallbackList = function () {
                function CallbackList(callbacks, queueLength) {
                    if (queueLength === void 0) {
                        queueLength = 10
                    }
                    if (callbacks == null) {
                        callbacks = []
                    }
                    this.callbacks = callbacks;
                    this.queueLength = queueLength
                }

                CallbackList.prototype.append = function (callback) {
                    this.callbacks.push(callback)
                };
                CallbackList.prototype.setParams = function (params) {
                    for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {
                        var callback = _a[_i];
                        callback.setParams(params)
                    }
                };
                CallbackList.prototype.setModel = function (model) {
                    for (var _i = 0, _a = this.callbacks; _i < _a.length; _i++) {
                        var callback = _a[_i];
                        callback.setModel(model)
                    }
                };
                CallbackList.prototype.onEpochBegin = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _i, _a, callback;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (logs == null) {
                                        logs = {}
                                    }
                                    _i = 0, _a = this.callbacks;
                                    _b.label = 1;
                                case 1:
                                    if (!(_i < _a.length)) return [3, 4];
                                    callback = _a[_i];
                                    return [4, callback.onEpochBegin(epoch, logs)];
                                case 2:
                                    _b.sent();
                                    _b.label = 3;
                                case 3:
                                    _i++;
                                    return [3, 1];
                                case 4:
                                    return [2]
                            }
                        })
                    })
                };
                CallbackList.prototype.onEpochEnd = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _i, _a, callback;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (logs == null) {
                                        logs = {}
                                    }
                                    _i = 0, _a = this.callbacks;
                                    _b.label = 1;
                                case 1:
                                    if (!(_i < _a.length)) return [3, 4];
                                    callback = _a[_i];
                                    return [4, callback.onEpochEnd(epoch, logs)];
                                case 2:
                                    _b.sent();
                                    _b.label = 3;
                                case 3:
                                    _i++;
                                    return [3, 1];
                                case 4:
                                    return [2]
                            }
                        })
                    })
                };
                CallbackList.prototype.onBatchBegin = function (batch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _i, _a, callback;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (logs == null) {
                                        logs = {}
                                    }
                                    _i = 0, _a = this.callbacks;
                                    _b.label = 1;
                                case 1:
                                    if (!(_i < _a.length)) return [3, 4];
                                    callback = _a[_i];
                                    return [4, callback.onBatchBegin(batch, logs)];
                                case 2:
                                    _b.sent();
                                    _b.label = 3;
                                case 3:
                                    _i++;
                                    return [3, 1];
                                case 4:
                                    return [2]
                            }
                        })
                    })
                };
                CallbackList.prototype.onBatchEnd = function (batch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _i, _a, callback;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (logs == null) {
                                        logs = {}
                                    }
                                    _i = 0, _a = this.callbacks;
                                    _b.label = 1;
                                case 1:
                                    if (!(_i < _a.length)) return [3, 4];
                                    callback = _a[_i];
                                    return [4, callback.onBatchEnd(batch, logs)];
                                case 2:
                                    _b.sent();
                                    _b.label = 3;
                                case 3:
                                    _i++;
                                    return [3, 1];
                                case 4:
                                    return [2]
                            }
                        })
                    })
                };
                CallbackList.prototype.onTrainBegin = function (logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _i, _a, callback;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (logs == null) {
                                        logs = {}
                                    }
                                    _i = 0, _a = this.callbacks;
                                    _b.label = 1;
                                case 1:
                                    if (!(_i < _a.length)) return [3, 4];
                                    callback = _a[_i];
                                    return [4, callback.onTrainBegin(logs)];
                                case 2:
                                    _b.sent();
                                    _b.label = 3;
                                case 3:
                                    _i++;
                                    return [3, 1];
                                case 4:
                                    return [2]
                            }
                        })
                    })
                };
                CallbackList.prototype.onTrainEnd = function (logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _i, _a, callback;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (logs == null) {
                                        logs = {}
                                    }
                                    _i = 0, _a = this.callbacks;
                                    _b.label = 1;
                                case 1:
                                    if (!(_i < _a.length)) return [3, 4];
                                    callback = _a[_i];
                                    return [4, callback.onTrainEnd(logs)];
                                case 2:
                                    _b.sent();
                                    _b.label = 3;
                                case 3:
                                    _i++;
                                    return [3, 1];
                                case 4:
                                    return [2]
                            }
                        })
                    })
                };
                return CallbackList
            }();
            exports.CallbackList = CallbackList;
            var BaseLogger = function (_super) {
                __extends(BaseLogger, _super);

                function BaseLogger() {
                    return _super.call(this) || this
                }

                BaseLogger.prototype.onEpochBegin = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            this.seen = 0;
                            this.totals = {};
                            return [2]
                        })
                    })
                };
                BaseLogger.prototype.onBatchEnd = function (batch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var batchSize, _loop_1, this_1, key;
                        return __generator(this, function (_a) {
                            if (logs == null) {
                                logs = {}
                            }
                            batchSize = logs["size"] == null ? 0 : logs["size"];
                            this.seen += batchSize;
                            _loop_1 = function (key) {
                                var value = logs[key];
                                if (typeof value === "number") {
                                    if (!this_1.totals.hasOwnProperty(key)) {
                                        this_1.totals[key] = 0
                                    }
                                    this_1.totals[key] = this_1.totals[key] + value * batchSize
                                } else {
                                    if (!this_1.totals.hasOwnProperty(key)) {
                                        this_1.totals[key] = K.getScalar(0)
                                    }
                                    tfjs_core_1.tidy(function () {
                                        _this.totals[key] = K.scalarPlusArray(_this.totals[key], tfjs_core_1.mul(value, K.getScalar(batchSize)));
                                        tfjs_core_1.keep(_this.totals[key])
                                    })
                                }
                            };
                            this_1 = this;
                            for (key in logs) {
                                _loop_1(key)
                            }
                            return [2]
                        })
                    })
                };
                BaseLogger.prototype.onEpochEnd = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var _loop_2, this_2, _i, _a, key;
                        return __generator(this, function (_b) {
                            if (logs != null) {
                                _loop_2 = function (key) {
                                    if (this_2.totals[key] == null) {
                                        return "continue"
                                    }
                                    if (typeof this_2.totals[key] === "number") {
                                        logs[key] = this_2.totals[key] / this_2.seen
                                    } else {
                                        tfjs_core_1.tidy(function () {
                                            logs[key] = K.scalarTimesArray(tfjs_core_1.div(K.getScalar(1), K.getScalar(_this.seen)), _this.totals[key]);
                                            tfjs_core_1.keep(logs[key])
                                        })
                                    }
                                };
                                this_2 = this;
                                for (_i = 0, _a = this.params["metrics"]; _i < _a.length; _i++) {
                                    key = _a[_i];
                                    _loop_2(key)
                                }
                            }
                            return [2]
                        })
                    })
                };
                return BaseLogger
            }(Callback);
            exports.BaseLogger = BaseLogger;

            function resolveScalarsInLogs(logs) {
                return __awaiter(this, void 0, void 0, function () {
                    var promises, keys, key, value, valueScalar, values, i;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (logs == null) {
                                    return [2]
                                }
                                promises = [];
                                keys = [];
                                for (key in logs) {
                                    value = logs[key];
                                    if (typeof value !== "number") {
                                        valueScalar = value;
                                        promises.push(valueScalar.data());
                                        keys.push(key)
                                    }
                                }
                                return [4, Promise.all(promises)];
                            case 1:
                                values = _a.sent();
                                for (i = 0; i < values.length; ++i) {
                                    logs[keys[i]] = values[i][0]
                                }
                                return [2]
                        }
                    })
                })
            }

            exports.resolveScalarsInLogs = resolveScalarsInLogs;

            function disposeTensorsInLogs(logs) {
                if (logs == null) {
                    return
                }
                for (var key in logs) {
                    var value = logs[key];
                    if (typeof value !== "number") {
                        value.dispose()
                    }
                }
            }

            exports.disposeTensorsInLogs = disposeTensorsInLogs;
            var History = function (_super) {
                __extends(History, _super);

                function History() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                History.prototype.onTrainBegin = function (logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            this.epoch = [];
                            this.history = {};
                            return [2]
                        })
                    })
                };
                History.prototype.onEpochEnd = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var key;
                        return __generator(this, function (_a) {
                            if (logs == null) {
                                logs = {}
                            }
                            this.epoch.push(epoch);
                            for (key in logs) {
                                if (this.history[key] == null) {
                                    this.history[key] = []
                                }
                                this.history[key].push(logs[key])
                            }
                            return [2]
                        })
                    })
                };
                History.prototype.syncData = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var promises, keys, indices, key, valueArray, i, valueScalar, values, n;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = [];
                                    keys = [];
                                    indices = [];
                                    for (key in this.history) {
                                        valueArray = this.history[key];
                                        for (i = 0; i < valueArray.length; ++i) {
                                            if (typeof valueArray[i] !== "number") {
                                                valueScalar = valueArray[i];
                                                promises.push(valueScalar.data());
                                                keys.push(key);
                                                indices.push(i)
                                            }
                                        }
                                    }
                                    return [4, Promise.all(promises)];
                                case 1:
                                    values = _a.sent();
                                    for (n = 0; n < values.length; ++n) {
                                        this.history[keys[n]][indices[n]].dispose();
                                        this.history[keys[n]][indices[n]] = values[n][0]
                                    }
                                    return [2]
                            }
                        })
                    })
                };
                return History
            }(Callback);
            exports.History = History;
            var CustomCallback = function (_super) {
                __extends(CustomCallback, _super);

                function CustomCallback(config) {
                    var _this = _super.call(this) || this;
                    _this.trainBegin = config.onTrainBegin;
                    _this.trainEnd = config.onTrainEnd;
                    _this.epochBegin = config.onEpochBegin;
                    _this.epochEnd = config.onEpochEnd;
                    _this.batchBegin = config.onBatchBegin;
                    _this.batchEnd = config.onBatchEnd;
                    return _this
                }

                CustomCallback.prototype.onEpochBegin = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.epochBegin != null)) return [3, 3];
                                    return [4, resolveScalarsInLogs(logs)];
                                case 1:
                                    _a.sent();
                                    return [4, this.epochBegin(epoch, logs)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    return [2]
                            }
                        })
                    })
                };
                CustomCallback.prototype.onEpochEnd = function (epoch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.epochEnd != null)) return [3, 3];
                                    return [4, resolveScalarsInLogs(logs)];
                                case 1:
                                    _a.sent();
                                    return [4, this.epochEnd(epoch, logs)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    return [2]
                            }
                        })
                    })
                };
                CustomCallback.prototype.onBatchBegin = function (batch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.batchBegin != null)) return [3, 3];
                                    return [4, resolveScalarsInLogs(logs)];
                                case 1:
                                    _a.sent();
                                    return [4, this.batchBegin(batch, logs)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    return [2]
                            }
                        })
                    })
                };
                CustomCallback.prototype.onBatchEnd = function (batch, logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.batchEnd != null)) return [3, 3];
                                    return [4, resolveScalarsInLogs(logs)];
                                case 1:
                                    _a.sent();
                                    return [4, this.batchEnd(batch, logs)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    return [2]
                            }
                        })
                    })
                };
                CustomCallback.prototype.onTrainBegin = function (logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.trainBegin != null)) return [3, 3];
                                    return [4, resolveScalarsInLogs(logs)];
                                case 1:
                                    _a.sent();
                                    return [4, this.trainBegin(logs)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    return [2]
                            }
                        })
                    })
                };
                CustomCallback.prototype.onTrainEnd = function (logs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.trainEnd != null)) return [3, 3];
                                    return [4, resolveScalarsInLogs(logs)];
                                case 1:
                                    _a.sent();
                                    return [4, this.trainEnd(logs)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    return [2]
                            }
                        })
                    })
                };
                return CustomCallback
            }(Callback);
            exports.CustomCallback = CustomCallback;

            function standardizeCallbacks(callbacks) {
                if (callbacks == null) {
                    return null
                }
                if (callbacks instanceof Callback) {
                    return [callbacks]
                }
                if (Array.isArray(callbacks) && callbacks[0] instanceof Callback) {
                    return callbacks
                }
                var callbackConfigs = generic_utils.toList(callbacks);
                return callbackConfigs.map(function (callbackConfig) {
                    return new CustomCallback(callbackConfig)
                })
            }

            exports.standardizeCallbacks = standardizeCallbacks
        }, {"./backend/tfjs_backend": 158, "./utils/generic_utils": 188, "@tensorflow/tfjs-core": 50}],
        160: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var generic_utils_1 = require("./utils/generic_utils");
            var nameMap = new Map;
            exports.VALID_DATA_FORMAT_VALUES = ["channelsFirst", "channelsLast"];

            function checkDataFormat(value) {
                generic_utils_1.checkStringTypeUnionValue(exports.VALID_DATA_FORMAT_VALUES, "DataFormat", value)
            }

            exports.checkDataFormat = checkDataFormat;
            exports.VALID_PADDING_MODE_VALUES = ["valid", "same", "causal"];

            function checkPaddingMode(value) {
                generic_utils_1.checkStringTypeUnionValue(exports.VALID_PADDING_MODE_VALUES, "PaddingMode", value)
            }

            exports.checkPaddingMode = checkPaddingMode;
            exports.VALID_POOL_MODE_VALUES = ["max", "avg"];

            function checkPoolMode(value) {
                generic_utils_1.checkStringTypeUnionValue(exports.VALID_POOL_MODE_VALUES, "PoolMode", value)
            }

            exports.checkPoolMode = checkPoolMode;
            var _nameScopeStack = [];
            var _nameScopeDivider = "/";

            function nameScope(name, fn) {
                _nameScopeStack.push(name);
                try {
                    var val = fn();
                    _nameScopeStack.pop();
                    return val
                } catch (e) {
                    _nameScopeStack.pop();
                    throw e
                }
            }

            exports.nameScope = nameScope;

            function currentNameScopePrefix() {
                if (_nameScopeStack.length === 0) {
                    return ""
                } else {
                    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider
                }
            }

            function getScopedTensorName(tensorName) {
                if (!isValidTensorName(tensorName)) {
                    throw new Error("Not a valid tensor name: '" + tensorName + "'")
                }
                return currentNameScopePrefix() + tensorName
            }

            exports.getScopedTensorName = getScopedTensorName;

            function getUniqueTensorName(scopedName) {
                if (!isValidTensorName(scopedName)) {
                    throw new Error("Not a valid tensor name: '" + scopedName + "'")
                }
                if (!nameMap.has(scopedName)) {
                    nameMap.set(scopedName, 0)
                }
                var index = nameMap.get(scopedName);
                nameMap.set(scopedName, nameMap.get(scopedName) + 1);
                if (index > 0) {
                    var result = scopedName + "_" + index;
                    nameMap.set(result, 1);
                    return result
                } else {
                    return scopedName
                }
            }

            exports.getUniqueTensorName = getUniqueTensorName;
            var tensorNameRegex = new RegExp(/^[A-Za-z][A-Za-z0-9\._\/]*$/);

            function isValidTensorName(name) {
                return name.match(tensorNameRegex) ? true : false
            }

            exports.isValidTensorName = isValidTensorName
        }, {"./utils/generic_utils": 188}],
        161: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var generic_utils_1 = require("./utils/generic_utils");

            function calcL2Norms(w, axis) {
                return tfjs_core_1.tidy(function () {
                    return tfc.sqrt(tfc.sum(K.square(w), axis, true))
                })
            }

            var Constraint = function (_super) {
                __extends(Constraint, _super);

                function Constraint() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Constraint.prototype.getConfig = function () {
                    return {}
                };
                Constraint = __decorate([tfjs_core_1.doc({
                    heading: "Constraints",
                    subheading: "Classes",
                    namespace: "constraints"
                })], Constraint);
                return Constraint
            }(tfjs_core_1.serialization.Serializable);
            exports.Constraint = Constraint;
            var MaxNorm = function (_super) {
                __extends(MaxNorm, _super);

                function MaxNorm(config) {
                    var _this = _super.call(this) || this;
                    _this.defaultMaxValue = 2;
                    _this.defaultAxis = 0;
                    _this.maxValue = config.maxValue != null ? config.maxValue : _this.defaultMaxValue;
                    _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
                    return _this
                }

                MaxNorm.prototype.apply = function (w) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var norms = calcL2Norms(w, _this.axis);
                        var desired = tfc.clipByValue(norms, 0, _this.maxValue);
                        return tfc.mul(w, tfc.div(desired, K.scalarPlusArray(K.getScalar(K.epsilon()), norms)))
                    })
                };
                MaxNorm.prototype.getConfig = function () {
                    return {maxValue: this.maxValue, axis: this.axis}
                };
                MaxNorm.className = "MaxNorm";
                return MaxNorm
            }(Constraint);
            exports.MaxNorm = MaxNorm;
            tfjs_core_1.serialization.SerializationMap.register(MaxNorm);
            var UnitNorm = function (_super) {
                __extends(UnitNorm, _super);

                function UnitNorm(config) {
                    var _this = _super.call(this) || this;
                    _this.defaultAxis = 0;
                    _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
                    return _this
                }

                UnitNorm.prototype.apply = function (w) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        return tfc.div(w, K.scalarPlusArray(K.getScalar(K.epsilon()), calcL2Norms(w, _this.axis)))
                    })
                };
                UnitNorm.prototype.getConfig = function () {
                    return {axis: this.axis}
                };
                UnitNorm.className = "UnitNorm";
                return UnitNorm
            }(Constraint);
            exports.UnitNorm = UnitNorm;
            tfjs_core_1.serialization.SerializationMap.register(UnitNorm);
            var NonNeg = function (_super) {
                __extends(NonNeg, _super);

                function NonNeg() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                NonNeg.prototype.apply = function (w) {
                    return tfc.relu(w)
                };
                NonNeg.className = "NonNeg";
                return NonNeg
            }(Constraint);
            exports.NonNeg = NonNeg;
            tfjs_core_1.serialization.SerializationMap.register(NonNeg);
            var MinMaxNorm = function (_super) {
                __extends(MinMaxNorm, _super);

                function MinMaxNorm(config) {
                    var _this = _super.call(this) || this;
                    _this.defaultMinValue = 0;
                    _this.defaultMaxValue = 1;
                    _this.defaultRate = 1;
                    _this.defaultAxis = 0;
                    _this.minValue = config.minValue != null ? config.minValue : _this.defaultMinValue;
                    _this.maxValue = config.maxValue != null ? config.maxValue : _this.defaultMaxValue;
                    _this.rate = config.rate != null ? config.rate : _this.defaultRate;
                    _this.axis = config.axis != null ? config.axis : _this.defaultAxis;
                    return _this
                }

                MinMaxNorm.prototype.apply = function (w) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var norms = calcL2Norms(w, _this.axis);
                        var desired = tfc.add(K.scalarTimesArray(K.getScalar(_this.rate), tfc.clipByValue(norms, _this.minValue, _this.maxValue)), K.scalarTimesArray(K.getScalar(1 - _this.rate), norms));
                        return tfc.mul(w, tfc.div(desired, K.scalarPlusArray(K.getScalar(K.epsilon()), norms)))
                    })
                };
                MinMaxNorm.prototype.getConfig = function () {
                    return {minValue: this.minValue, maxValue: this.maxValue, rate: this.rate, axis: this.axis}
                };
                MinMaxNorm.className = "MinMaxNorm";
                return MinMaxNorm
            }(Constraint);
            exports.MinMaxNorm = MinMaxNorm;
            tfjs_core_1.serialization.SerializationMap.register(MinMaxNorm);
            exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
                maxNorm: "MaxNorm",
                minMaxNorm: "MinMaxNorm",
                nonNeg: "NonNeg",
                unitNorm: "UnitNorm"
            };

            function serializeConstraint(constraint) {
                return generic_utils_1.serializeKerasObject(constraint)
            }

            exports.serializeConstraint = serializeConstraint;

            function deserializeConstraint(config, customObjects) {
                if (customObjects === void 0) {
                    customObjects = {}
                }
                return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, "constraint")
            }

            exports.deserializeConstraint = deserializeConstraint;

            function getConstraint(identifier) {
                if (identifier == null) {
                    return null
                }
                if (typeof identifier === "string") {
                    var className = identifier in exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
                    var config = {className: className, config: {}};
                    return deserializeConstraint(config)
                } else if (identifier instanceof Constraint) {
                    return identifier
                } else {
                    return deserializeConstraint(identifier)
                }
            }

            exports.getConstraint = getConstraint
        }, {"./backend/tfjs_backend": 158, "./utils/generic_utils": 188, "@tensorflow/tfjs-core": 50}],
        162: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var errors_1 = require("../errors");
            var topology_1 = require("./topology");

            function assertFeedCompatibility(key, val) {
                if (key.dtype != null && key.dtype !== val.dtype) {
                    throw new errors_1.ValueError("The dtype of the feed (" + val.dtype + ") is incompatible with that of " + ("the key '" + key.name + "' (" + key.dtype + ")."))
                }
                if (key.shape != null) {
                    if (key.shape.length !== val.shape.length) {
                        throw new errors_1.ValueError("The rank of feed (" + val.shape.length + ") does not match the rank of " + ("the key (" + key.shape.length + ")."))
                    }
                    for (var i = 0; i < key.shape.length; ++i) {
                        if (key.shape[i] != null && key.shape[i] !== val.shape[i]) {
                            throw new errors_1.ValueError("The " + i + "-th dimension of the feed (" + val.shape[i] + ") is " + ("incompatible with that of the key (" + key.shape[i] + ")."))
                        }
                    }
                }
            }

            var FeedDict = function () {
                function FeedDict(feeds) {
                    this.id2Value = {};
                    if (feeds instanceof FeedDict) {
                        for (var id in feeds.id2Value) {
                            this.id2Value[id] = feeds.id2Value[id]
                        }
                    } else {
                        if (feeds == null) {
                            return
                        }
                        for (var _i = 0, feeds_1 = feeds; _i < feeds_1.length; _i++) {
                            var feed = feeds_1[_i];
                            this.add(feed.key, feed.value)
                        }
                    }
                }

                FeedDict.prototype.add = function (key, value) {
                    assertFeedCompatibility(key, value);
                    if (this.id2Value[key.id] == null) {
                        this.id2Value[key.id] = value
                    } else {
                        throw new errors_1.ValueError("Duplicate key: name=" + key.name + ", id=" + key.id)
                    }
                    return this
                };
                FeedDict.prototype.addFeed = function (feed) {
                    this.add(feed.key, feed.value)
                };
                FeedDict.prototype.hasKey = function (key) {
                    return this.id2Value[key.id] != null
                };
                FeedDict.prototype.getValue = function (key) {
                    if (this.id2Value[key.id] == null) {
                        throw new errors_1.ValueError("Nonexistent key: " + JSON.stringify(key))
                    } else {
                        return this.id2Value[key.id]
                    }
                };
                return FeedDict
            }();
            exports.FeedDict = FeedDict;

            function execute(fetches, feedDict, kwargs) {
                var arrayFetches = Array.isArray(fetches);
                var fetchArray = arrayFetches ? fetches : [fetches];
                var outputs = [];
                var internalFeedDict = new FeedDict(feedDict);
                for (var _i = 0, fetchArray_1 = fetchArray; _i < fetchArray_1.length; _i++) {
                    var fetch_1 = fetchArray_1[_i];
                    outputs.push(executeInternal(fetch_1, internalFeedDict, kwargs))
                }
                return arrayFetches ? outputs : outputs[0]
            }

            exports.execute = execute;

            function executeInternal(fetch, internalFeedDict, kwargs) {
                if (internalFeedDict.hasKey(fetch)) {
                    return internalFeedDict.getValue(fetch)
                }
                if (fetch.sourceLayer instanceof topology_1.InputLayer) {
                    throw new errors_1.ValueError("Missing a feed value for SymbolicTensor from InputLayer " + ("'" + topology_1.InputLayer.name + "'"))
                }
                var inputs = fetch.inputs;
                var inputValues = [];
                for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                    var input = inputs_1[_i];
                    var inputVal = executeInternal(input, internalFeedDict, kwargs);
                    inputValues.push(inputVal)
                }
                var output = fetch.sourceLayer.apply(inputValues, kwargs);
                if (!Array.isArray(output)) {
                    output = [output]
                }
                var layerOutputs = getNodeOutputs(fetch);
                var outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];
                for (var i = 0; i < outputSymbolicTensors.length; ++i) {
                    internalFeedDict.add(outputSymbolicTensors[i], output[i])
                }
                return output.length === 1 ? output[0] : output[fetch.outputTensorIndex]
            }

            function getNodeOutputs(fetch) {
                var layerOutputs;
                if (fetch.sourceLayer.inboundNodes.length === 1) {
                    layerOutputs = fetch.sourceLayer.output
                } else {
                    var nodeIndex = null;
                    for (var i = 0; i < fetch.sourceLayer.inboundNodes.length; ++i) {
                        for (var _i = 0, _a = fetch.sourceLayer.inboundNodes[i].outputTensors; _i < _a.length; _i++) {
                            var outputTensor = _a[_i];
                            if (outputTensor.id === fetch.id) {
                                nodeIndex = i;
                                break
                            }
                        }
                    }
                    layerOutputs = fetch.sourceLayer.getOutputAt(nodeIndex)
                }
                return layerOutputs
            }
        }, {"../errors": 165, "./topology": 163}],
        163: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("../backend/tfjs_backend");
            var errors_1 = require("../errors");
            var serialization_1 = require("../layers/serialization");
            var types_1 = require("../types");
            var generic_utils = require("../utils/generic_utils");
            var serialization_utils_1 = require("../utils/serialization_utils");
            var variables_1 = require("../variables");
            var version_1 = require("../version");
            var InputSpec = function () {
                function InputSpec(config) {
                    this.dtype = config.dtype;
                    this.shape = config.shape;
                    if (config.shape != null) {
                        this.ndim = config.shape.length
                    } else {
                        this.ndim = config.ndim
                    }
                    this.maxNDim = config.maxNDim;
                    this.minNDim = config.minNDim;
                    this.axes = config.axes || {}
                }

                return InputSpec
            }();
            exports.InputSpec = InputSpec;
            var _nextNodeID = 0;
            var Node = function () {
                function Node(config, callArgs) {
                    this.callArgs = callArgs;
                    this.id = _nextNodeID++;
                    this.outboundLayer = config.outboundLayer;
                    this.inboundLayers = config.inboundLayers;
                    this.nodeIndices = config.nodeIndices;
                    this.tensorIndices = config.tensorIndices;
                    this.inputTensors = config.inputTensors;
                    this.outputTensors = config.outputTensors;
                    this.inputMasks = config.inputMasks;
                    this.outputMasks = config.outputMasks;
                    this.inputShapes = config.inputShapes;
                    this.outputShapes = config.outputShapes;
                    for (var _i = 0, _a = config.inboundLayers; _i < _a.length; _i++) {
                        var layer = _a[_i];
                        if (layer != null) {
                            layer.outboundNodes.push(this)
                        }
                    }
                    config.outboundLayer.inboundNodes.push(this)
                }

                Node.prototype.getConfig = function () {
                    var inboundNames = [];
                    for (var _i = 0, _a = this.inboundLayers; _i < _a.length; _i++) {
                        var layer = _a[_i];
                        if (layer != null) {
                            inboundNames.push(layer.name)
                        } else {
                            inboundNames.push(null)
                        }
                    }
                    return {
                        outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
                        inboundLayers: inboundNames,
                        nodeIndices: this.nodeIndices,
                        tensorIndices: this.tensorIndices
                    }
                };
                return Node
            }();
            exports.Node = Node;
            var _nextLayerID = 0;
            var Layer = function (_super) {
                __extends(Layer, _super);

                function Layer(config) {
                    var _this = _super.call(this) || this;
                    _this._callHook = null;
                    _this._addedWeightNames = [];
                    _this._stateful = false;
                    _this.id = _nextLayerID++;
                    _this.activityRegularizer = null;
                    _this.inputSpec = null;
                    _this.supportsMasking = false;
                    _this._trainableWeights = [];
                    _this._nonTrainableWeights = [];
                    _this._losses = [];
                    _this._updates = [];
                    _this._built = false;
                    _this.inboundNodes = [];
                    _this.outboundNodes = [];
                    var name = config.name;
                    if (!name) {
                        var prefix = _this.getClassName();
                        name = generic_utils.toSnakeCase(prefix) + "_" + K.getUid(prefix)
                    }
                    _this.name = name;
                    _this.trainable = config.trainable == null ? true : config.trainable;
                    _this.updatable = config.updatable == null ? true : config.updatable;
                    if (config.inputShape != null || config.batchInputShape != null) {
                        var batchInputShape = void 0;
                        if (config.batchInputShape != null) {
                            batchInputShape = config.batchInputShape
                        } else if (config.inputShape != null) {
                            var batchSize = null;
                            if (config.batchSize != null) {
                                batchSize = config.batchSize
                            }
                            batchInputShape = [batchSize].concat(config.inputShape)
                        }
                        _this.batchInputShape = batchInputShape;
                        var dtype = config.dtype;
                        if (dtype == null) {
                            dtype = config.inputDType
                        }
                        if (dtype == null) {
                            dtype = K.floatx()
                        }
                        _this.dtype = dtype
                    }
                    if (config.weights != null) {
                        _this.initialWeights = config.weights
                    } else {
                        _this.initialWeights = null
                    }
                    return _this
                }

                Layer.nodeKey = function (layer, nodeIndex) {
                    return layer.name + "_ib-" + nodeIndex.toString()
                };
                Layer.prototype.getNodeAtIndex = function (nodeIndex, attrName) {
                    if (this.inboundNodes.length === 0) {
                        throw new errors_1.RuntimeError("The layer has never been called " + ("and thus has no defined " + attrName + "."))
                    }
                    if (this.inboundNodes.length <= nodeIndex) {
                        throw new errors_1.ValueError("Asked to get " + attrName + " at node " + nodeIndex + ", " + ("but the layer has only " + this.inboundNodes.length + " inbound nodes."))
                    }
                    return this.inboundNodes[nodeIndex]
                };
                Layer.prototype.getInputAt = function (nodeIndex) {
                    return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, "input").inputTensors)
                };
                Layer.prototype.getOutputAt = function (nodeIndex) {
                    return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, "output").outputTensors)
                };
                Object.defineProperty(Layer.prototype, "input", {
                    get: function () {
                        if (this.inboundNodes.length > 1) {
                            throw new errors_1.AttributeError("Layer " + this.name + " has multiple inbound nodes, " + 'hence the notion of "layer input" ' + "is ill-defined. " + "Use `getInputAt(nodeIndex)` instead.")
                        } else if (this.inboundNodes.length === 0) {
                            throw new errors_1.AttributeError("Layer " + this.name + " is not connected, no input to return.")
                        }
                        return generic_utils.singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors)
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Layer.prototype, "output", {
                    get: function () {
                        if (this.inboundNodes.length === 0) {
                            throw new errors_1.AttributeError("Layer " + this.name + " has no inbound nodes.")
                        }
                        if (this.inboundNodes.length > 1) {
                            throw new errors_1.AttributeError("Layer " + this.name + " has multiple inbound nodes, " + 'hence the notion of "layer output" ' + "is ill-defined. " + "Use `getOutputAt(nodeIndex)` instead.")
                        }
                        return generic_utils.singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors)
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Layer.prototype, "losses", {
                    get: function () {
                        return this._losses
                    }, enumerable: true, configurable: true
                });
                Layer.prototype.calculateLosses = function () {
                    return this.losses.map(function (lossFn) {
                        return lossFn()
                    })
                };
                Object.defineProperty(Layer.prototype, "updates", {
                    get: function () {
                        return this._updates
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Layer.prototype, "built", {
                    get: function () {
                        return this._built
                    }, set: function (built) {
                        this._built = built
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Layer.prototype, "trainableWeights", {
                    get: function () {
                        if (this.trainable) {
                            return this._trainableWeights
                        } else {
                            return []
                        }
                    }, set: function (weights) {
                        this._trainableWeights = weights
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Layer.prototype, "nonTrainableWeights", {
                    get: function () {
                        if (!this.trainable) {
                            return this._trainableWeights.concat(this._nonTrainableWeights)
                        } else {
                            return this._nonTrainableWeights
                        }
                    }, set: function (weights) {
                        this._nonTrainableWeights = weights
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Layer.prototype, "weights", {
                    get: function () {
                        return this.trainableWeights.concat(this.nonTrainableWeights)
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Layer.prototype, "stateful", {
                    get: function () {
                        return this._stateful
                    }, enumerable: true, configurable: true
                });
                Layer.prototype.assertInputCompatibility = function (inputs) {
                    inputs = generic_utils.toList(inputs);
                    if (this.inputSpec == null || this.inputSpec.length === 0) {
                        return
                    }
                    var inputSpec = generic_utils.toList(this.inputSpec);
                    if (inputs.length !== inputSpec.length) {
                        throw new errors_1.ValueError("Layer " + this.name + " expects " + inputSpec.length + " inputs, " + ("but it received " + inputs.length + " input tensors. ") + ("Input received: " + inputs))
                    }
                    for (var inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
                        var x = inputs[inputIndex];
                        var spec = inputSpec[inputIndex];
                        if (spec == null) {
                            continue
                        }
                        var ndim = x.rank;
                        if (spec.ndim != null) {
                            if (ndim !== spec.ndim) {
                                throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + ": " + ("expected ndim=" + spec.ndim + ", found ndim=" + ndim))
                            }
                        }
                        if (spec.maxNDim != null) {
                            if (ndim > spec.maxNDim) {
                                throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + (": expected max_ndim=" + spec.maxNDim + ", found ndim=" + ndim))
                            }
                        }
                        if (spec.minNDim != null) {
                            if (ndim < spec.minNDim) {
                                throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + (": expected min_ndim=" + spec.minNDim + ", found ndim=" + ndim + "."))
                            }
                        }
                        if (spec.dtype != null) {
                            if (K.dtype(x) !== spec.dtype) {
                                var xDType = K.dtype(x);
                                throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + this.name + " " + (": expected dtype=" + spec.dtype + ", found dtype=" + xDType + "."))
                            }
                        }
                        if (spec.axes) {
                            var xShape = K.intShape(x);
                            for (var key in spec.axes) {
                                var axis = Number(key);
                                var value = spec.axes[key];
                                var xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];
                                if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {
                                    throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + (this.name + ": expected axis " + axis + " of input shape to ") + ("have value " + value + " but got shape " + xShape + "."))
                                }
                            }
                        }
                        if (spec.shape != null) {
                            var xShape = K.intShape(x);
                            for (var i = 0; i < spec.shape.length; ++i) {
                                var specDim = spec.shape[i];
                                var dim = xShape[i];
                                if (specDim != null && dim != null) {
                                    if (specDim !== dim) {
                                        throw new errors_1.ValueError("Input " + inputIndex + " is incompatible with layer " + (this.name + ": expected shape=" + spec.shape + ", ") + "found shape=${xShape}.")
                                    }
                                }
                            }
                        }
                    }
                };
                Layer.prototype.call = function (inputs, kwargs) {
                    return inputs
                };
                Layer.prototype.invokeCallHook = function (inputs, kwargs) {
                    if (this._callHook != null) {
                        this._callHook(inputs, kwargs)
                    }
                };
                Layer.prototype.setCallHook = function (callHook) {
                    this._callHook = callHook
                };
                Layer.prototype.clearCallHook = function () {
                    this._callHook = null
                };
                Layer.prototype.apply = function (inputs, kwargs) {
                    var _this = this;
                    kwargs = kwargs || {};
                    var inputsList = generic_utils.toList(inputs);
                    var allAreSymbolic = true;
                    for (var _i = 0, inputsList_1 = inputsList; _i < inputsList_1.length; _i++) {
                        var input = inputsList_1[_i];
                        if (!(input instanceof types_1.SymbolicTensor)) {
                            allAreSymbolic = false;
                            break
                        }
                    }
                    var noneAreSymbolic = true;
                    for (var _a = 0, inputsList_2 = inputsList; _a < inputsList_2.length; _a++) {
                        var input = inputsList_2[_a];
                        if (input instanceof types_1.SymbolicTensor) {
                            noneAreSymbolic = false;
                            break
                        }
                    }
                    if (allAreSymbolic === noneAreSymbolic) {
                        throw new errors_1.ValueError("Arguments to apply() must be all " + "SymbolicTensors or all Tensors")
                    }
                    return K.nameScope(this.name, function () {
                        if (!_this.built) {
                            _this.assertInputCompatibility(inputs);
                            var inputShapes = [];
                            for (var _i = 0, _a = generic_utils.toList(inputs); _i < _a.length; _i++) {
                                var xElem = _a[_i];
                                inputShapes.push(K.intShape(xElem))
                            }
                            _this.build(generic_utils.singletonOrArray(inputShapes));
                            _this.built = true;
                            if (_this.initialWeights) {
                                _this.setWeights(_this.initialWeights)
                            }
                        }
                        _this.assertInputCompatibility(inputs);
                        if (noneAreSymbolic) {
                            var output = _this.call(inputs, kwargs);
                            var outputList = generic_utils.toList(output);
                            var outputListCopy = [];
                            for (var _b = 0, outputList_1 = outputList; _b < outputList_1.length; _b++) {
                                var x = outputList_1[_b];
                                if (inputsList.indexOf(x) !== -1) {
                                    x = K.identity(x)
                                }
                                outputListCopy.push(x)
                            }
                            output = generic_utils.singletonOrArray(outputListCopy);
                            if (_this.activityRegularizer != null) {
                                throw new errors_1.NotImplementedError("Layer invocation in the presence of activity " + "regularizer(s) is not supported yet.")
                            }
                            return output
                        } else {
                            var inputShape = collectInputShape(inputs);
                            var outputShape = _this.computeOutputShape(inputShape);
                            var output = void 0;
                            var outputDType_1 = guessOutputDType(inputs);
                            if (outputShape != null && outputShape.length > 0 && Array.isArray(outputShape[0])) {
                                output = outputShape.map(function (shape, index) {
                                    return new types_1.SymbolicTensor(outputDType_1, shape, _this, generic_utils.toList(inputs), kwargs, _this.name, index)
                                })
                            } else {
                                output = new types_1.SymbolicTensor(outputDType_1, outputShape, _this, generic_utils.toList(inputs), kwargs, _this.name)
                            }
                            _this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);
                            if (_this.activityRegularizer != null) {
                                throw new errors_1.NotImplementedError("Layer invocation in the presence of activity " + "regularizer(s) is not supported yet.")
                            }
                            return output
                        }
                    })
                };
                Layer.prototype.build = function (inputShape) {
                    this.built = true
                };
                Layer.prototype.getWeights = function (trainableOnly) {
                    if (trainableOnly === void 0) {
                        trainableOnly = false
                    }
                    return variables_1.batchGetValue(trainableOnly ? this.trainableWeights : this.weights)
                };
                Layer.prototype.setWeights = function (weights) {
                    var _this = this;
                    tfjs_core_1.tidy(function () {
                        var params = _this.weights;
                        if (params.length !== weights.length) {
                            throw new errors_1.ValueError('You called setWeights(weights) on layer "' + _this.name + '" ' + ("with a weight list of length " + weights.length + ", ") + ("but the layer was expecting " + params.length + " weights. ") + ("Provided weights: " + weights + "..."))
                        }
                        if (params.length === 0) {
                            return
                        }
                        var weightValueTuples = [];
                        var paramValues = variables_1.batchGetValue(params);
                        for (var i = 0; i < paramValues.length; ++i) {
                            var pv = paramValues[i];
                            var p = params[i];
                            var w = weights[i];
                            if (!tfjs_core_1.util.arraysEqual(pv.shape, w.shape)) {
                                throw new errors_1.ValueError("Layer weight shape " + pv.shape + " " + ("not compatible with provided weight shape " + w.shape))
                            }
                            weightValueTuples.push([p, w])
                        }
                        variables_1.batchSetValue(weightValueTuples)
                    })
                };
                Layer.prototype.addWeight = function (name, shape, dtype, initializer, regularizer, trainable, constraint) {
                    if (this._addedWeightNames.indexOf(name) !== -1) {
                        throw new errors_1.ValueError("Duplicate weight name " + name + " for layer " + this.name)
                    }
                    this._addedWeightNames.push(name);
                    if (dtype == null) {
                        dtype = K.floatx()
                    }
                    var weight = new variables_1.LayerVariable(initializer.apply(shape, dtype), dtype, name, trainable, constraint);
                    if (regularizer != null) {
                        this.addLoss(function () {
                            return regularizer.apply(weight.read())
                        })
                    }
                    if (trainable == null) {
                        trainable = true
                    }
                    if (trainable) {
                        this._trainableWeights.push(weight)
                    } else {
                        this._nonTrainableWeights.push(weight)
                    }
                    return weight
                };
                Layer.prototype.addLoss = function (losses) {
                    if (losses == null || Array.isArray(losses) && losses.length === 0) {
                        return
                    }
                    losses = generic_utils.toList(losses);
                    if (this._losses !== undefined && this._losses !== null) {
                        (_a = this.losses).push.apply(_a, losses)
                    }
                    var _a
                };
                Layer.prototype.computeOutputShape = function (inputShape) {
                    return inputShape
                };
                Layer.prototype.computeMask = function (inputs, mask) {
                    var _this = this;
                    if (!this.supportsMasking) {
                        if (mask != null) {
                            if (Array.isArray(mask)) {
                                mask.forEach(function (maskElement) {
                                    if (maskElement != null) {
                                        throw new TypeError("Layer " + _this.name + " does not support masking," + "but was passed an inputMask.")
                                    }
                                })
                            } else {
                                throw new TypeError("Layer " + this.name + " does not support masking," + "but was passed an inputMask.")
                            }
                        }
                        return null
                    }
                    return mask
                };
                Layer.prototype.addInboundNode = function (inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs) {
                    if (kwargs === void 0) {
                        kwargs = null
                    }
                    var inputTensorList = generic_utils.toList(inputTensors);
                    outputTensors = generic_utils.toList(outputTensors);
                    inputMasks = generic_utils.toList(inputMasks);
                    outputMasks = generic_utils.toList(outputMasks);
                    inputShapes = generic_utils.normalizeShapeList(inputShapes);
                    outputShapes = generic_utils.normalizeShapeList(outputShapes);
                    var inboundLayers = [];
                    var nodeIndices = [];
                    var tensorIndices = [];
                    for (var _i = 0, inputTensorList_1 = inputTensorList; _i < inputTensorList_1.length; _i++) {
                        var x = inputTensorList_1[_i];
                        inboundLayers.push(x.sourceLayer);
                        nodeIndices.push(x.nodeIndex);
                        tensorIndices.push(x.tensorIndex)
                    }
                    new Node({
                        outboundLayer: this,
                        inboundLayers: inboundLayers,
                        nodeIndices: nodeIndices,
                        tensorIndices: tensorIndices,
                        inputTensors: inputTensorList,
                        outputTensors: outputTensors,
                        inputMasks: inputMasks,
                        outputMasks: outputMasks,
                        inputShapes: inputShapes,
                        outputShapes: outputShapes
                    }, kwargs);
                    for (var i = 0; i < outputTensors.length; i++) {
                        outputTensors[i].sourceLayer = this;
                        outputTensors[i].nodeIndex = this.inboundNodes.length - 1;
                        outputTensors[i].tensorIndex = i
                    }
                };
                Layer.prototype.getConfig = function () {
                    var config = {name: this.name, trainable: this.trainable};
                    if (this.batchInputShape != null) {
                        config["batchInputShape"] = this.batchInputShape
                    }
                    if (this.dtype != null) {
                        config["dtype"] = this.dtype
                    }
                    return config
                };
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes"
                })], Layer.prototype, "apply", null);
                Layer = __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Classes",
                    namespace: "layers"
                })], Layer);
                return Layer
            }(tfjs_core_1.serialization.Serializable);
            exports.Layer = Layer;

            function collectInputShape(inputTensors) {
                inputTensors = generic_utils.toList(inputTensors);
                var shapes = [];
                for (var _i = 0, inputTensors_1 = inputTensors; _i < inputTensors_1.length; _i++) {
                    var x = inputTensors_1[_i];
                    shapes.push(K.intShape(x))
                }
                return generic_utils.singletonOrArray(shapes)
            }

            function guessOutputDType(inputTensors) {
                return "float32"
            }

            var InputLayer = function (_super) {
                __extends(InputLayer, _super);

                function InputLayer(config) {
                    var _this = _super.call(this, {
                        dtype: config.dtype,
                        name: config.name != null ? config.name : K.getUid("input").toString()
                    }) || this;
                    if (config.batchSize == null) {
                        config.batchSize = null
                    }
                    if (config.sparse == null) {
                        config.sparse = false
                    }
                    _this.trainable = false;
                    _this.built = true;
                    _this.sparse = config.sparse;
                    if (config.inputShape != null && config.batchInputShape != null) {
                        throw new errors_1.ValueError("Only provide the inputShape OR " + "batchInputShape argument to inputLayer, not both at the same time.")
                    }
                    var batchInputShape = config.batchInputShape;
                    if (batchInputShape == null) {
                        if (config.inputShape == null) {
                            throw new errors_1.ValueError("An InputLayer should be passed either a " + "`batchInputShape` or an `inputShape`.")
                        } else {
                            batchInputShape = [config.batchSize].concat(config.inputShape)
                        }
                    } else {
                        if (config.batchSize != null) {
                            throw new errors_1.ValueError("Cannot specify batchSize if batchInputShape is" + "specified when creating an InputLayer.")
                        }
                    }
                    var dtype = config.dtype || K.floatx();
                    _this.batchInputShape = batchInputShape;
                    _this.dtype = dtype;
                    _this.inputSpec = [{shape: batchInputShape}];
                    var inputTensor = new types_1.SymbolicTensor(_this.dtype, _this.batchInputShape, _this, [], {}, _this.name);
                    inputTensor.nodeIndex = 0;
                    inputTensor.tensorIndex = 0;
                    new Node({
                        outboundLayer: _this,
                        inboundLayers: [],
                        nodeIndices: [],
                        tensorIndices: [],
                        inputTensors: [inputTensor],
                        outputTensors: [inputTensor],
                        inputMasks: [null],
                        outputMasks: [null],
                        inputShapes: [batchInputShape],
                        outputShapes: [batchInputShape]
                    });
                    return _this
                }

                InputLayer.prototype.apply = function (inputs, kwargs) {
                    throw new errors_1.ValueError("Cannot pass any input to an " + ("InputLayer's apply() method. InputLayer name: " + this.name))
                };
                InputLayer.prototype.getConfig = function () {
                    return {
                        batchInputShape: this.batchInputShape,
                        dtype: this.dtype,
                        sparse: this.sparse,
                        name: this.name
                    }
                };
                InputLayer.className = "InputLayer";
                return InputLayer
            }(Layer);
            exports.InputLayer = InputLayer;
            tfjs_core_1.serialization.SerializationMap.register(InputLayer);

            function Input(config) {
                if (config.batchShape == null && config.shape == null) {
                    throw new Error("Please provide to Input either a `shape`" + " or a `batchShape` argument. Note that " + "`shape` does not include the batch " + "dimension.")
                }
                if (config.batchShape != null && config.shape != null) {
                    throw new errors_1.ValueError("Please provide either a `shape` or `batchShape` " + "argument to Input, but not both.")
                }
                var batchShape = config.batchShape;
                if (config.shape != null && batchShape == null) {
                    batchShape = [null].concat(config.shape)
                }
                var dtype = config.dtype;
                if (dtype == null) {
                    dtype = K.floatx()
                }
                var inputLayer = new InputLayer({
                    batchInputShape: batchShape,
                    name: config.name,
                    dtype: dtype,
                    sparse: config.sparse
                });
                var outputs = inputLayer.inboundNodes[0].outputTensors;
                return outputs[0]
            }

            exports.Input = Input;
            var Container = function (_super) {
                __extends(Container, _super);

                function Container(config) {
                    var _this = _super.call(this, {}) || this;
                    _this.containerNodes = new Set;
                    _this.name = config.name;
                    if (_this.name == null) {
                        var prefix = _this.getClassName().toLowerCase();
                        _this.name = K.getUid(prefix)
                    }
                    _this.supportsMasking = false;
                    _this.trainable = true;
                    _this.updatable = true;
                    if (Array.isArray(config.inputs)) {
                        _this.inputs = config.inputs.slice()
                    } else {
                        _this.inputs = [config.inputs]
                    }
                    if (Array.isArray(config.outputs)) {
                        _this.outputs = config.outputs.slice()
                    } else {
                        _this.outputs = [config.outputs]
                    }
                    if (generic_utils.unique(_this.inputs).length !== _this.inputs.length) {
                        throw new errors_1.ValueError("The list of inputs passed to the model is " + "redundant. All inputs should only appear once. Found: " + _this.inputs.map(function (x) {
                            return x.name
                        }))
                    }
                    if (generic_utils.unique(_this.outputs).length !== _this.outputs.length) {
                        console.warn("The list of outputs passed to the model is redundant. " + "All outputs should only appear once. Found: " + _this.outputs.map(function (x) {
                            return x.name
                        }))
                    }
                    _this.inputLayers = [];
                    _this.inputLayersNodeIndices = [];
                    _this.inputLayersTensorIndices = [];
                    _this.outputLayers = [];
                    _this.outputLayersNodeIndices = [];
                    _this.outputLayersTensorIndices = [];
                    _this.layers = [];
                    for (var _i = 0, _a = _this.outputs; _i < _a.length; _i++) {
                        var x = _a[_i];
                        var layer = x.sourceLayer;
                        var nodeIndex = x.nodeIndex;
                        var tensorIndex = x.tensorIndex;
                        _this.outputLayers.push(layer);
                        _this.outputLayersNodeIndices.push(nodeIndex);
                        _this.outputLayersTensorIndices.push(tensorIndex)
                    }
                    for (var _b = 0, _c = _this.inputs; _b < _c.length; _b++) {
                        var x = _c[_b];
                        var layer = x.sourceLayer;
                        var nodeIndex = x.nodeIndex;
                        var tensorIndex = x.tensorIndex;
                        generic_utils.assert(nodeIndex === 0, "input layer has >1 nodes");
                        generic_utils.assert(tensorIndex === 0, "input layer has >1 tensors");
                        _this.inputLayers.push(layer);
                        _this.inputLayersNodeIndices.push(nodeIndex);
                        _this.inputLayersTensorIndices.push(tensorIndex)
                    }
                    _this.inputNames = [];
                    _this.outputNames = [];
                    _this.feedInputShapes = [];
                    _this.feedInputNames = [];
                    _this.feedOutputNames = [];
                    for (var i = 0; i < _this.inputLayers.length; i++) {
                        var layer = _this.inputLayers[i];
                        if (!(layer instanceof InputLayer)) {
                            throw new TypeError("Input layers to a Model must be InputLayer objects. " + ("Received inputs: " + config.inputs + ". ") + ("Input " + i + " (0-based) originates ") + ("from layer type " + layer.getClassName() + "."))
                        }
                        _this.inputNames.push(layer.name);
                        _this.feedInputShapes.push(layer.batchInputShape);
                        _this.feedInputNames.push(layer.name)
                    }
                    for (var _d = 0, _e = _this.outputLayers; _d < _e.length; _d++) {
                        var layer = _e[_d];
                        _this.outputNames.push(layer.name)
                    }
                    _this.internalInputShapes = _this.inputs.map(function (x) {
                        return x.shape
                    });
                    _this.internalOutputShapes = _this.outputs.map(function (x) {
                        return x.shape
                    });
                    var nodesDepths = {};
                    var nodeIDToNode = {};
                    var layersDepths = {};
                    var layerIDToLayer = {};
                    var layerIndices = {};
                    var nodesInDecreasingDepth = [];
                    var buildMapOfGraph = function (tensor, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex) {
                        if (layer == null || nodeIndex == null || tensorIndex == null) {
                            layer = tensor.sourceLayer;
                            nodeIndex = tensor.nodeIndex;
                            tensorIndex = tensor.tensorIndex
                        }
                        var node = layer.inboundNodes[nodeIndex];
                        if (nodesInProgress.indexOf(node) !== -1) {
                            throw new errors_1.RuntimeError("The tensor " + tensor.name + ' at layer "' + layer.name + '" ' + "is part of a cycle.")
                        }
                        if (finishedNodes.indexOf(node) !== -1) {
                            return
                        }
                        _this.containerNodes.add(Container.nodeKey(layer, nodeIndex));
                        if (!(layer.id in layerIndices)) {
                            layerIndices[layer.id] = Object.keys(layerIndices).length
                        }
                        if (nodesInProgress.indexOf(node) === -1) {
                            nodesInProgress.push(node)
                        }
                        var numInboundLayers = node.inboundLayers.length;
                        for (var i = 0; i < numInboundLayers; i++) {
                            var x = node.inputTensors[i];
                            var layer_1 = node.inboundLayers[i];
                            var nodeIndex_1 = node.nodeIndices[i];
                            var tensorIndex_1 = node.tensorIndices[i];
                            buildMapOfGraph(x, finishedNodes, nodesInProgress, layer_1, nodeIndex_1, tensorIndex_1)
                        }
                        finishedNodes.push(node);
                        while (nodesInProgress.indexOf(node) >= 0) {
                            nodesInProgress.splice(nodesInProgress.indexOf(node), 1)
                        }
                        nodesInDecreasingDepth.push(node)
                    };
                    var finishedNodes = [];
                    var nodesInProgress = [];
                    for (var _f = 0, _g = _this.outputs; _f < _g.length; _f++) {
                        var x = _g[_f];
                        buildMapOfGraph(x, finishedNodes, nodesInProgress)
                    }
                    var reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();
                    for (var _h = 0, reversedNodesInDecreasingDepth_1 = reversedNodesInDecreasingDepth; _h < reversedNodesInDecreasingDepth_1.length; _h++) {
                        var node = reversedNodesInDecreasingDepth_1[_h];
                        nodeIDToNode[node.id] = node;
                        if (!(node.id in nodesDepths)) {
                            nodesDepths[node.id] = 0
                        }
                        var depth = nodesDepths[node.id];
                        var previousDepth = layersDepths[node.outboundLayer.id] == null ? 0 : layersDepths[node.outboundLayer.id];
                        depth = Math.max(depth, previousDepth);
                        layersDepths[node.outboundLayer.id] = depth;
                        layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;
                        nodesDepths[node.id] = depth;
                        for (var i = 0; i < node.inboundLayers.length; i++) {
                            var inboundLayer = node.inboundLayers[i];
                            var nodeIndex = node.nodeIndices[i];
                            var inboundNode = inboundLayer.inboundNodes[nodeIndex];
                            var previousDepth_1 = nodesDepths[inboundNode.id] == null ? 0 : nodesDepths[inboundNode.id];
                            nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth_1);
                            nodeIDToNode[inboundNode.id] = inboundNode
                        }
                    }
                    var nodesByDepth = {};
                    for (var nodeID in nodesDepths) {
                        var depth = nodesDepths[nodeID];
                        if (!(depth in nodesByDepth)) {
                            nodesByDepth[depth] = []
                        }
                        nodesByDepth[depth].push(nodeIDToNode[nodeID])
                    }
                    var layersByDepth = {};
                    for (var layerID in layersDepths) {
                        var depth = layersDepths[layerID];
                        if (!(depth in layersByDepth)) {
                            layersByDepth[depth] = []
                        }
                        layersByDepth[depth].push(layerIDToLayer[layerID])
                    }
                    var depthKeys = Object.keys(layersByDepth).map(function (x) {
                        return parseInt(x, 10)
                    }).sort(generic_utils.reverseNumberCompare);
                    _this.layers = [];
                    for (var _j = 0, depthKeys_1 = depthKeys; _j < depthKeys_1.length; _j++) {
                        var depth = depthKeys_1[_j];
                        var layersForDepth = layersByDepth[depth];
                        layersForDepth.sort(function (a, b) {
                            var aIndex = layerIndices[a.id];
                            var bIndex = layerIndices[b.id];
                            if (aIndex < bIndex) {
                                return -1
                            }
                            if (aIndex > bIndex) {
                                return 1
                            }
                            return 0
                        });
                        for (var _k = 0, layersForDepth_1 = layersForDepth; _k < layersForDepth_1.length; _k++) {
                            var layer = layersForDepth_1[_k];
                            _this.layers.push(layer)
                        }
                    }
                    _this.layersByDepth = layersByDepth;
                    depthKeys = Object.keys(nodesByDepth).map(function (x) {
                        return parseInt(x, 10)
                    }).sort(generic_utils.reverseNumberCompare);
                    var computableTensors = _this.inputs.slice();
                    var layersWithCompleteInput = [];
                    for (var _l = 0, depthKeys_2 = depthKeys; _l < depthKeys_2.length; _l++) {
                        var depth = depthKeys_2[_l];
                        for (var _m = 0, _o = nodesByDepth[depth]; _m < _o.length; _m++) {
                            var node = _o[_m];
                            var layer = node.outboundLayer;
                            if (layer != null) {
                                for (var _p = 0, _q = node.inputTensors; _p < _q.length; _p++) {
                                    var x = _q[_p];
                                    if (computableTensors.indexOf(x) === -1) {
                                        throw new errors_1.RuntimeError("Graph disconnected: cannot obtain value for tensor " + x + (' at layer "' + layer.name + '". ') + "The following previous layers were accessed without " + ("issue: " + layersWithCompleteInput))
                                    }
                                }
                                for (var _r = 0, _s = node.outputTensors; _r < _s.length; _r++) {
                                    var x = _s[_r];
                                    computableTensors.push(x)
                                }
                                layersWithCompleteInput.push(layer.name)
                            }
                        }
                    }
                    _this.nodesByDepth = nodesByDepth;
                    var allNames = _this.layers.map(function (x) {
                        return x.name
                    });
                    var _loop_1 = function (name_1) {
                        var numOccurrences = allNames.filter(function (x) {
                            return x === name_1
                        }).length;
                        if (numOccurrences !== 1) {
                            throw new errors_1.RuntimeError('The name "' + name_1 + '" is used ' + numOccurrences + " times " + "in the model. All layer names should be unique. Layer names: " + JSON.stringify(allNames))
                        }
                    };
                    for (var _t = 0, allNames_1 = allNames; _t < allNames_1.length; _t++) {
                        var name_1 = allNames_1[_t];
                        _loop_1(name_1)
                    }
                    _this.outboundNodes = [];
                    _this.inboundNodes = [];
                    new Node({
                        outboundLayer: _this,
                        inboundLayers: [],
                        nodeIndices: [],
                        tensorIndices: [],
                        inputTensors: _this.inputs,
                        outputTensors: _this.outputs,
                        inputMasks: _this.inputs.map(function (x) {
                            return null
                        }),
                        outputMasks: _this.outputs.map(function (x) {
                            return null
                        }),
                        inputShapes: _this.inputs.map(function (x) {
                            return x.shape
                        }),
                        outputShapes: _this.outputs.map(function (x) {
                            return x.shape
                        })
                    });
                    _this.built = true;
                    return _this
                }

                Object.defineProperty(Container.prototype, "trainableWeights", {
                    get: function () {
                        if (this._trainableWeights.length > 0) {
                            throw new errors_1.ValueError("Container instance unexpectedly contains _trainableWeights." + "The trainable weights of a Container are a union of the " + "trainable weights of its consituent Layers. Its own " + "_trainableWeights must remain an empty Array.")
                        }
                        if (!this.trainable) {
                            return []
                        }
                        var weights = [];
                        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                            var layer = _a[_i];
                            weights = weights.concat(layer.trainableWeights)
                        }
                        return weights
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Container.prototype, "nonTrainableWeights", {
                    get: function () {
                        var weights = [];
                        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                            var layer = _a[_i];
                            weights.push.apply(weights, layer.nonTrainableWeights)
                        }
                        if (!this.trainable) {
                            var trainableWeights = [];
                            for (var _b = 0, _c = this.layers; _b < _c.length; _b++) {
                                var layer = _c[_b];
                                trainableWeights.push.apply(trainableWeights, layer.trainableWeights)
                            }
                            return trainableWeights.concat(weights)
                        }
                        return weights
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Container.prototype, "weights", {
                    get: function () {
                        return this.trainableWeights.concat(this.nonTrainableWeights)
                    }, enumerable: true, configurable: true
                });
                Container.prototype.loadWeights = function (weightsJSON, skipMismatch, isNamedTensorMap) {
                    if (skipMismatch === void 0) {
                        skipMismatch = false
                    }
                    if (isNamedTensorMap === void 0) {
                        isNamedTensorMap = false
                    }
                    if (isNamedTensorMap) {
                        loadWeightsFromNamedTensorMap(weightsJSON, this.layers)
                    } else {
                        loadWeightsFromJson(weightsJSON, this.layers, skipMismatch)
                    }
                };
                Container.prototype.updatedConfig = function () {
                    var theConfig = this.getConfig();
                    var modelConfig = {
                        className: this.getClassName(),
                        config: theConfig,
                        kerasVersion: "tfjs-layers " + version_1.version,
                        backend: "TensorFlow.js"
                    };
                    return modelConfig
                };
                Container.prototype.toJSON = function (unused, returnString) {
                    if (returnString === void 0) {
                        returnString = true
                    }
                    var modelConfig = serialization_utils_1.convertTsToPythonic(this.updatedConfig());
                    return returnString ? JSON.stringify(modelConfig) : modelConfig
                };
                Container.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = generic_utils.toList(inputs);
                        var masks;
                        if ("mask" in kwargs) {
                            masks = generic_utils.toList(kwargs["mask"])
                        } else {
                            masks = generic_utils.pyListRepeat(null, inputs.length)
                        }
                        return _this.runInternalGraph(inputs, masks)[0]
                    })
                };
                Container.prototype.computeMask = function (inputs, mask) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = generic_utils.toList(inputs);
                        var masks;
                        if (mask == null) {
                            masks = generic_utils.pyListRepeat(null, inputs.length)
                        } else {
                            masks = generic_utils.toList(mask)
                        }
                        return _this.runInternalGraph(inputs, masks)[1]
                    })
                };
                Container.prototype.computeOutputShape = function (inputShape) {
                    var inputShapes = generic_utils.normalizeShapeList(inputShape);
                    if (inputShapes.length !== this.inputLayers.length) {
                        throw new errors_1.ValueError("Invalid inputShape argument " + inputShape + ": " + ("model has " + this.inputLayers.length + " tensor inputs."))
                    }
                    var layersToOutputShapes = {};
                    for (var i = 0; i < inputShapes.length; i++) {
                        var layer = this.inputLayers[i];
                        var inputShape_1 = inputShapes[i];
                        var shapeKey = layer.name + "_0_0";
                        layersToOutputShapes[shapeKey] = inputShape_1
                    }
                    var depthKeys = Object.keys(this.nodesByDepth).map(function (x) {
                        return parseInt(x, 10)
                    }).sort(generic_utils.reverseNumberCompare);
                    if (depthKeys.length > 1) {
                        for (var _i = 0, depthKeys_3 = depthKeys; _i < depthKeys_3.length; _i++) {
                            var depth = depthKeys_3[_i];
                            var nodes = this.nodesByDepth[depth];
                            for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
                                var node = nodes_1[_a];
                                var layer = node.outboundLayer;
                                if (this.inputLayers.map(function (x) {
                                    return x.id
                                }).indexOf(layer.id) !== -1) {
                                    continue
                                }
                                var inputShapes_1 = [];
                                for (var j = 0; j < node.inboundLayers.length; j++) {
                                    var inboundLayer = node.inboundLayers[j];
                                    var nodeIndex_2 = node.nodeIndices[j];
                                    var tensorIndex = node.tensorIndices[j];
                                    var shapeKey = inboundLayer.name + "_" + nodeIndex_2 + "_" + tensorIndex;
                                    var inputShape_2 = layersToOutputShapes[shapeKey];
                                    inputShapes_1.push(inputShape_2)
                                }
                                var outputShape = layer.computeOutputShape(generic_utils.singletonOrArray(inputShapes_1));
                                var outputShapes_1 = generic_utils.normalizeShapeList(outputShape);
                                var nodeIndex = layer.inboundNodes.indexOf(node);
                                for (var j = 0; j < outputShapes_1.length; j++) {
                                    var shapeKey = layer.name + "_" + nodeIndex + "_" + j;
                                    layersToOutputShapes[shapeKey] = outputShapes_1[j]
                                }
                            }
                        }
                    }
                    var outputShapes = [];
                    var outputShapeKeys = [];
                    for (var i = 0; i < this.outputLayers.length; i++) {
                        var layer = this.outputLayers[i];
                        var nodeIndex = this.outputLayersNodeIndices[i];
                        var tensorIndex = this.outputLayersTensorIndices[i];
                        var shapeKey = layer.name + "_" + nodeIndex + "_" + tensorIndex;
                        outputShapeKeys.push(shapeKey)
                    }
                    for (var i = 0; i < outputShapeKeys.length; i++) {
                        var key = outputShapeKeys[i];
                        generic_utils.assert(key in layersToOutputShapes);
                        outputShapes.push(layersToOutputShapes[key])
                    }
                    return generic_utils.singletonOrArray(outputShapes)
                };
                Container.prototype.runInternalGraph = function (inputs, masks) {
                    if (masks == null) {
                        masks = generic_utils.pyListRepeat(null, inputs.length)
                    }
                    var tensorMap = {};
                    for (var i = 0; i < this.inputs.length; ++i) {
                        var x = this.inputs[i];
                        var y = inputs[i];
                        var mask = masks[i];
                        tensorMap[x.id] = [y, mask]
                    }
                    var depthKeys = Object.keys(this.nodesByDepth).map(function (x) {
                        return parseInt(x, 10)
                    }).sort(generic_utils.reverseNumberCompare);
                    for (var _i = 0, depthKeys_4 = depthKeys; _i < depthKeys_4.length; _i++) {
                        var depth = depthKeys_4[_i];
                        var nodes = this.nodesByDepth[depth];
                        for (var _a = 0, nodes_2 = nodes; _a < nodes_2.length; _a++) {
                            var node = nodes_2[_a];
                            var layer = node.outboundLayer;
                            var referenceInputTensors = node.inputTensors;
                            var referenceOutputTensors = node.outputTensors;
                            var computedData = new Array;
                            for (var _b = 0, referenceInputTensors_1 = referenceInputTensors; _b < referenceInputTensors_1.length; _b++) {
                                var x = referenceInputTensors_1[_b];
                                if (x.id in tensorMap) {
                                    computedData.push(tensorMap[x.id])
                                }
                            }
                            if (computedData.length === referenceInputTensors.length) {
                                var kwargs = {};
                                var computedTensors = void 0;
                                var computedMasks = void 0;
                                var outputTensors_1 = void 0;
                                var outputMasks_1 = void 0;
                                if (node.callArgs != null) {
                                    kwargs = node.callArgs
                                }
                                if (computedData.length === 1) {
                                    var _c = computedData[0], computedTensor = _c[0], computedMask = _c[1];
                                    if (kwargs.mask == null) {
                                        kwargs["mask"] = computedMask
                                    }
                                    outputTensors_1 = generic_utils.toList(layer.call(computedTensor, kwargs));
                                    outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensor, computedMask));
                                    computedTensors = [computedTensor];
                                    computedMasks = [computedMask]
                                } else {
                                    computedTensors = computedData.map(function (x) {
                                        return x[0]
                                    });
                                    computedMasks = computedData.map(function (x) {
                                        return x[1]
                                    });
                                    if (kwargs.mask == null) {
                                        kwargs["mask"] = computedMasks
                                    }
                                    outputTensors_1 = generic_utils.toList(layer.call(computedTensors, kwargs));
                                    outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensors, computedMasks))
                                }
                                if (layer.activityRegularizer) {
                                    throw new errors_1.NotImplementedError("Model invocation with concrete Tensor value(s) in the " + "presence of activity regularizer(s) is not supported yet.")
                                }
                                for (var i = 0; i < referenceOutputTensors.length; ++i) {
                                    var x = referenceOutputTensors[i];
                                    var y = outputTensors_1[i];
                                    var mask = outputMasks_1[i];
                                    tensorMap[x.id] = [y, mask]
                                }
                            }
                        }
                    }
                    var outputTensors = [];
                    var outputMasks = [];
                    var outputShapes = [];
                    for (var _d = 0, _e = this.outputs; _d < _e.length; _d++) {
                        var x = _e[_d];
                        generic_utils.assert(x.id in tensorMap, "Could not compute output " + x.name + " : " + x.id);
                        var _f = tensorMap[x.id], tensor = _f[0], mask = _f[1];
                        outputShapes.push(tensor.shape);
                        outputTensors.push(tensor);
                        outputMasks.push(mask)
                    }
                    return [outputTensors, outputMasks, outputShapes]
                };
                Container.prototype.buildNodeConversionMap = function (layers) {
                    var nodeConversionMap = {};
                    var keptNodes;
                    for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                        var layer = _a[_i];
                        keptNodes = layer instanceof Container ? 1 : 0;
                        for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
                            var nodeKey = Container.nodeKey(layer, originalNodeIndex);
                            if (nodeKey in this.containerNodes) {
                                nodeConversionMap[nodeKey] = keptNodes;
                                keptNodes += 1
                            }
                        }
                    }
                    return nodeConversionMap
                };
                Container.prototype.getLayer = function (name, index) {
                    if (index != null) {
                        if (this.layers.length <= index) {
                            throw new errors_1.ValueError("Was asked to retrieve layer at index " + index + ", but model only " + ("has " + this.layers.length + " layer(s)."))
                        } else {
                            return this.layers[index]
                        }
                    } else {
                        if (name == null) {
                            throw new errors_1.ValueError("Provide either a layer name or layer index")
                        }
                    }
                    for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                        var layer = _a[_i];
                        if (layer.name === name) {
                            return layer
                        }
                    }
                    throw new errors_1.ValueError("No such layer: " + name)
                };
                Container.prototype.calculateLosses = function () {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var losses = [];
                        for (var _i = 0, _a = _this.layers; _i < _a.length; _i++) {
                            var layer = _a[_i];
                            for (var nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {
                                var nodeKey = Container.nodeKey(layer, nodeIndex);
                                if (_this.containerNodes.has(nodeKey)) {
                                    losses.push.apply(losses, layer.calculateLosses())
                                }
                            }
                        }
                        return losses
                    })
                };
                Container.prototype.getConfig = function () {
                    var config = {name: this.name};
                    var nodeConversionMap = this.buildNodeConversionMap(this.layers);
                    var layerConfigs = [];
                    for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                        var layer = _a[_i];
                        var layerClassName = layer.getClassName();
                        var layerConfig = layer.getConfig();
                        var filteredInboundNodes = [];
                        for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
                            var node = layer.inboundNodes[originalNodeIndex];
                            var nodeKey = Container.nodeKey(layer, originalNodeIndex);
                            var kwargs = {};
                            if (this.containerNodes.has(nodeKey)) {
                                if (node.callArgs) {
                                    var testString = JSON.stringify(node.callArgs);
                                    if (testString.indexOf("undefined") === -1) {
                                        kwargs = node.callArgs
                                    } else {
                                        console.warn("Layer " + layer.name + " was passed " + "non-serializable keyword arguments: " + (node.callArgs + ". They will not be included ") + "in the serialized model (and thus will be " + "missing at deserialization time).");
                                        kwargs = {}
                                    }
                                }
                                if (node.inboundLayers.length > 0) {
                                    var nodeData = [];
                                    for (var i = 0; i < node.inboundLayers.length; i++) {
                                        var inboundLayer = node.inboundLayers[i];
                                        var nodeIndex = node.nodeIndices[i];
                                        var tensorIndex = node.tensorIndices[i];
                                        var nodeKey_1 = Container.nodeKey(inboundLayer, nodeIndex);
                                        var newNodeIndex = nodeConversionMap[nodeKey_1];
                                        if (newNodeIndex === null || newNodeIndex === undefined) {
                                            newNodeIndex = 0
                                        }
                                        nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs])
                                    }
                                    filteredInboundNodes.push(nodeData)
                                }
                            }
                        }
                        layerConfigs.push({
                            name: layer.name,
                            className: layerClassName,
                            config: layerConfig,
                            inboundNodes: filteredInboundNodes
                        })
                    }
                    config["layers"] = layerConfigs;
                    var modelInputs = [];
                    for (var i = 0; i < this.inputLayers.length; i++) {
                        var layer = this.inputLayers[i];
                        var nodeIndex = this.inputLayersNodeIndices[i];
                        var nodeKey = Container.nodeKey(layer, nodeIndex);
                        if (!this.containerNodes.has(nodeKey)) {
                            continue
                        }
                        var newNodeIndex = nodeConversionMap[nodeKey];
                        if (newNodeIndex === null || newNodeIndex === undefined) {
                            newNodeIndex = 0
                        }
                        var tensorIndex = this.inputLayersTensorIndices[i];
                        modelInputs.push([layer.name, newNodeIndex, tensorIndex])
                    }
                    config["inputLayers"] = modelInputs;
                    var modelOutputs = [];
                    for (var i = 0; i < this.outputLayers.length; i++) {
                        var layer = this.outputLayers[i];
                        var nodeIndex = this.outputLayersNodeIndices[i];
                        var nodeKey = Container.nodeKey(layer, nodeIndex);
                        if (!this.containerNodes.has(nodeKey)) {
                            continue
                        }
                        var newNodeIndex = nodeConversionMap[nodeKey];
                        if (newNodeIndex === null || newNodeIndex === undefined) {
                            newNodeIndex = 0
                        }
                        var tensorIndex = this.outputLayersTensorIndices[i];
                        modelOutputs.push([layer.name, newNodeIndex, tensorIndex])
                    }
                    config["outputLayers"] = modelOutputs;
                    return config
                };
                Container.fromConfig = function (cls, config) {
                    var createdLayers = {};
                    var unprocessedNodes = {};

                    function addUnprocessedNode(layer, nodeData) {
                        if (!(layer.name in unprocessedNodes)) {
                            unprocessedNodes[layer.name] = [nodeData]
                        } else {
                            unprocessedNodes[layer.name].push(nodeData)
                        }
                    }

                    function processNode(layer, nodeData) {
                        var inputTensors = [];
                        var kwargs;
                        for (var _i = 0, nodeData_1 = nodeData; _i < nodeData_1.length; _i++) {
                            var inputData = nodeData_1[_i];
                            var inboundLayerName = inputData[0];
                            var inboundNodeIndex = inputData[1];
                            var inboundTensorIndex = inputData[2];
                            if (inputData.length === 3) {
                                kwargs = {}
                            } else if (inputData.length === 4) {
                                kwargs = inputData[3]
                            } else {
                                throw new errors_1.ValueError("Improperly formatted model config for layer " + JSON.stringify(layer) + ": " + JSON.stringify(inputData))
                            }
                            if (!(inboundLayerName in createdLayers)) {
                                addUnprocessedNode(layer, nodeData);
                                return
                            }
                            var inboundLayer = createdLayers[inboundLayerName];
                            if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {
                                addUnprocessedNode(layer, nodeData);
                                return
                            }
                            var inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];
                            inputTensors.push(inboundNode.outputTensors[inboundTensorIndex])
                        }
                        if (inputTensors.length > 0) {
                            layer.apply(generic_utils.singletonOrArray(inputTensors), kwargs)
                        }
                    }

                    function processLayer(layerData) {
                        var layerName = layerData.name;
                        var layer = serialization_1.deserialize(layerData, config.customObjects != null ? config.customObjects : {});
                        createdLayers[layerName] = layer;
                        var inboundNodesData = layerData.inboundNodes;
                        for (var _i = 0, inboundNodesData_1 = inboundNodesData; _i < inboundNodesData_1.length; _i++) {
                            var nodeData = inboundNodesData_1[_i];
                            if (!(nodeData instanceof Array)) {
                                throw new errors_1.ValueError("Corrupted configuration, expected array for nodeData: " + nodeData)
                            }
                            addUnprocessedNode(layer, nodeData)
                        }
                    }

                    var name = config.name;
                    var layersFromConfig = config.layers;
                    for (var _i = 0, layersFromConfig_1 = layersFromConfig; _i < layersFromConfig_1.length; _i++) {
                        var layerData = layersFromConfig_1[_i];
                        processLayer(layerData)
                    }
                    while (!generic_utils.isObjectEmpty(unprocessedNodes)) {
                        for (var _a = 0, layersFromConfig_2 = layersFromConfig; _a < layersFromConfig_2.length; _a++) {
                            var layerData = layersFromConfig_2[_a];
                            var layer = createdLayers[layerData.name];
                            if (layer.name in unprocessedNodes) {
                                for (var _b = 0, _c = unprocessedNodes[layer.name]; _b < _c.length; _b++) {
                                    var nodeData = _c[_b];
                                    processNode(layer, nodeData)
                                }
                                delete unprocessedNodes[layer.name]
                            }
                        }
                    }
                    var inputTensors = [];
                    var outputTensors = [];
                    var inputLayersFromConfig = config.inputLayers;
                    for (var _d = 0, inputLayersFromConfig_1 = inputLayersFromConfig; _d < inputLayersFromConfig_1.length; _d++) {
                        var layerData = inputLayersFromConfig_1[_d];
                        var layerName = layerData[0];
                        var nodeIndex = layerData[1];
                        var tensorIndex = layerData[2];
                        generic_utils.assert(layerName in createdLayers);
                        var layer = createdLayers[layerName];
                        var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
                        inputTensors.push(layerOutputTensors[tensorIndex])
                    }
                    var outputLayersFromConfig = config.outputLayers;
                    for (var _e = 0, outputLayersFromConfig_1 = outputLayersFromConfig; _e < outputLayersFromConfig_1.length; _e++) {
                        var layerData = outputLayersFromConfig_1[_e];
                        var layerName = layerData[0];
                        var nodeIndex = layerData[1];
                        var tensorIndex = layerData[2];
                        generic_utils.assert(layerName in createdLayers);
                        var layer = createdLayers[layerName];
                        var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
                        outputTensors.push(layerOutputTensors[tensorIndex])
                    }
                    return new cls({inputs: inputTensors, outputs: outputTensors, name: name})
                };
                Object.defineProperty(Container.prototype, "stateful", {
                    get: function () {
                        if (this._stateful) {
                            throw new errors_1.ValueError("Container instance unexpectedly has _stateful = true. The " + "statefulness of a Container is determined by the Layers it " + "contains. Its _stateful property must remain the default false.")
                        }
                        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                            var layer = _a[_i];
                            if (layer.stateful) {
                                return true
                            }
                        }
                        return false
                    }, enumerable: true, configurable: true
                });
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Classes",
                    namespace: "layers",
                    subclasses: ["Model"]
                })], Container.prototype, "getLayer", null);
                return Container
            }(Layer);
            exports.Container = Container;

            function getSourceInputs(tensor, layer, nodeIndex) {
                if (layer == null || nodeIndex != null && nodeIndex > 0) {
                    layer = tensor.sourceLayer;
                    nodeIndex = tensor.nodeIndex
                }
                if (layer.inboundNodes.length === 0) {
                    return [tensor]
                } else {
                    var node = layer.inboundNodes[nodeIndex];
                    if (node.inboundLayers.length === 0) {
                        return node.inputTensors
                    } else {
                        var sourceTensors = [];
                        for (var i = 0; i < node.inboundLayers.length; i++) {
                            var x = node.inputTensors[i];
                            var layer_2 = node.inboundLayers[i];
                            var nodeIndex_3 = node.nodeIndices[i];
                            var previousSources = getSourceInputs(x, layer_2, nodeIndex_3);
                            for (var _i = 0, previousSources_1 = previousSources; _i < previousSources_1.length; _i++) {
                                var x_1 = previousSources_1[_i];
                                if (sourceTensors.indexOf(x_1) === -1) {
                                    sourceTensors.push(x_1)
                                }
                            }
                        }
                        return sourceTensors
                    }
                }
            }

            exports.getSourceInputs = getSourceInputs;

            function loadTensor(dtype, shape, value) {
                var dataType = generic_utils.stringToDType(dtype);
                return tfjs_core_1.Tensor.make(shape, {values: shape.length === 0 ? value : tfjs_core_1.util.flatten(value)}, dataType)
            }

            function preprocessWeightsForLoading(layer, weights, originalKerasVersion, originalBackend) {
                if (!originalKerasVersion.startsWith("2.")) {
                    throw new errors_1.ValueError("Unsupported Keras version in weights being loaded: " + originalKerasVersion)
                }
                return weights
            }

            function loadWeightsFromNamedTensorMap(weights, layers) {
                var nameToWeight = {};
                var totalWeightsCount = 0;
                for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
                    var layer = layers_1[_i];
                    for (var _a = 0, _b = layer.weights; _a < _b.length; _a++) {
                        var weight = _b[_a];
                        if (nameToWeight[weight.originalName] != null) {
                            throw new errors_1.ValueError("Duplicate weight name: " + weight.originalName)
                        }
                        nameToWeight[weight.originalName] = weight;
                        totalWeightsCount++
                    }
                }
                var weightValueTuples = [];
                for (var name_2 in weights) {
                    weightValueTuples.push([nameToWeight[name_2], weights[name_2]]);
                    delete nameToWeight[name_2]
                }
                var unsetNames = [];
                for (var name_3 in nameToWeight) {
                    unsetNames.push(name_3)
                }
                if (unsetNames.length > 0) {
                    throw new errors_1.ValueError(unsetNames.length + " of " + totalWeightsCount + " weights are not set: " + ("" + unsetNames))
                }
                variables_1.batchSetValue(weightValueTuples)
            }

            exports.loadWeightsFromNamedTensorMap = loadWeightsFromNamedTensorMap;

            function loadWeightsFromJson(weightsJSON, layers, skipMismatch) {
                if (skipMismatch === void 0) {
                    skipMismatch = false
                }
                var originalKerasVersion = weightsJSON["keras_version"];
                var originalBackend = weightsJSON["backend"];
                var layerNames = layers.map(function (layer) {
                    return layer.name
                });
                var index = {};
                for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {
                    var layer = layers_2[_i];
                    if (layer.name != null) {
                        if (index[layer.name] == null) {
                            index[layer.name] = []
                        }
                        index[layer.name].push(layer)
                    }
                }
                var nameToWeights = weightsJSON["weights"];
                var weightValueTuples = [];
                for (var k = 0; k < layerNames.length; ++k) {
                    var name_4 = layerNames[k];
                    var layerWeights = nameToWeights[name_4];
                    if (layerWeights == null) {
                        layerWeights = []
                    }
                    var weightValues = [];
                    for (var n = 0; n < layerWeights.length; ++n) {
                        var weightEntry = layerWeights[n];
                        weightValues.push(new variables_1.LayerVariable(loadTensor(weightEntry["dtype"], weightEntry["shape"], weightEntry["value"])))
                    }
                    for (var _a = 0, _b = index[name_4]; _a < _b.length; _a++) {
                        var layer = _b[_a];
                        var symbolicWeights = layer.weights;
                        weightValues = preprocessWeightsForLoading(layer, weightValues, originalKerasVersion, originalBackend);
                        if (weightValues.length !== symbolicWeights.length) {
                            if (skipMismatch) {
                                console.warn("Skipping loading of weights of layer " + layer.name + " " + ("due to mismatch in number of weights: (" + weightValues.length + " ") + ("vs " + symbolicWeights.length + ")."))
                            } else {
                                throw new errors_1.ValueError("Layer #" + k + ' (named "' + layer.name + '") expects ' + (symbolicWeights.length + " weight(s), but the saved weights ") + ("have " + weightValues.length + " element(s)."))
                            }
                        }
                        for (var i = 0; i < weightValues.length; ++i) {
                            if (skipMismatch) {
                                if (!tfjs_core_1.util.arraysEqual(symbolicWeights[i].shape, weightValues[i].shape)) {
                                    console.warn("Skipping loading of weights for layer " + layer.name + " due " + ("to mismatch in shape (" + symbolicWeights[i].shape + " vs ") + (weightValues[i].shape + ")"));
                                    continue
                                }
                            }
                            weightValueTuples.push([symbolicWeights[i], weightValues[i].read()])
                        }
                    }
                }
                variables_1.batchSetValue(weightValueTuples)
            }

            exports.loadWeightsFromJson = loadWeightsFromJson
        }, {
            "../backend/tfjs_backend": 158,
            "../errors": 165,
            "../layers/serialization": 179,
            "../types": 186,
            "../utils/generic_utils": 188,
            "../utils/serialization_utils": 190,
            "../variables": 191,
            "../version": 192,
            "@tensorflow/tfjs-core": 50
        }],
        164: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("../backend/tfjs_backend");
            var callbacks_1 = require("../callbacks");
            var errors_1 = require("../errors");
            var losses = require("../losses");
            var Metrics = require("../metrics");
            var optimizers = require("../optimizers");
            var generic_utils_1 = require("../utils/generic_utils");
            var math_utils_1 = require("../utils/math_utils");
            var executor_1 = require("./executor");
            var topology_1 = require("./topology");

            function isDataTensor(x) {
                return x instanceof tfjs_core_1.Tensor
            }

            exports.isDataTensor = isDataTensor;

            function isDataArray(x) {
                return Array.isArray(x)
            }

            exports.isDataArray = isDataArray;

            function isDataDict(x) {
                return !isDataTensor(x) && !isDataArray(x)
            }

            exports.isDataDict = isDataDict;

            function standardizeInputData(data, names, shapes, checkBatchAxis, exceptionPrefix) {
                if (checkBatchAxis === void 0) {
                    checkBatchAxis = true
                }
                if (exceptionPrefix === void 0) {
                    exceptionPrefix = ""
                }
                if (names == null || names.length === 0) {
                    if (data != null) {
                        var gotUnexpectedData = false;
                        if (isDataArray(data) && data.length > 0) {
                            gotUnexpectedData = true
                        } else if (isDataDict(data)) {
                            for (var key in data) {
                                if (data.hasOwnProperty(key)) {
                                    gotUnexpectedData = true;
                                    break
                                }
                            }
                        } else {
                            gotUnexpectedData = true
                        }
                        if (gotUnexpectedData) {
                            throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + " expected no data, " + ("but got " + data))
                        }
                    }
                    return []
                }
                if (data == null) {
                    return names.map(function (name) {
                        return null
                    })
                }
                var arrays;
                if (isDataDict(data)) {
                    data = data;
                    arrays = [];
                    for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                        var name_1 = names_1[_i];
                        if (data[name_1] == null) {
                            throw new errors_1.ValueError('No data provided for "' + name_1 + '". Need data for each key in: ' + ("" + names))
                        }
                        arrays.push(data[name_1])
                    }
                } else if (isDataArray(data)) {
                    data = data;
                    if (data.length !== names.length) {
                        throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + ": the Array of " + "Tensors that you are passing to your model is not the size the " + ("model expected. Expected to see " + names.length + " Tensor(s), but ") + ("instead got the following list of Tensor(s): " + data))
                    }
                    arrays = data
                } else {
                    data = data;
                    if (names.length > 1) {
                        throw new errors_1.ValueError("The model " + exceptionPrefix + " expects " + names.length + " Tensor(s), " + ("but only received one Tensor. Found: Tensor with shape " + data.shape))
                    }
                    arrays = [data]
                }
                for (var i = 0; i < names.length; ++i) {
                    var array = arrays[i];
                    if (array.shape.length === 1) {
                        arrays[i] = K.expandDims(array, 1)
                    }
                }
                if (shapes != null) {
                    for (var i = 0; i < names.length; ++i) {
                        if (shapes[i] == null) {
                            continue
                        }
                        var array = arrays[i];
                        if (array.shape.length !== shapes[i].length) {
                            throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " + ("to have " + shapes[i].length + " dimension(s). but got array with ") + ("shape " + array.shape))
                        }
                        for (var j = 0; j < shapes[i].length; ++j) {
                            if (j === 0 && !checkBatchAxis) {
                                continue
                            }
                            var dim = array.shape[j];
                            var refDim = shapes[i][j];
                            if (refDim != null && refDim >= 0 && dim !== refDim) {
                                throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " + ("to have shape [" + shapes[i] + "], but got array with shape ") + ("[" + array.shape + "]."))
                            }
                        }
                    }
                }
                return arrays
            }

            exports.standardizeInputData = standardizeInputData;

            function checkArrayLengths(inputs, targets, weights) {
                var setX = generic_utils_1.unique(inputs.map(function (input) {
                    return input.shape[0]
                }));
                setX.sort();
                var setY = generic_utils_1.unique(targets.map(function (target) {
                    return target.shape[0]
                }));
                setY.sort();
                if (setX.length > 1) {
                    throw new errors_1.ValueError("All input Tensors (x) should have the same number of samples. " + "Got array shapes: " + ("" + JSON.stringify(inputs.map(function (input) {
                        return input.shape
                    }))))
                }
                if (setY.length > 1) {
                    throw new errors_1.ValueError("All target Tensors (y) should have the same number of samples. " + "Got array shapes: " + ("" + JSON.stringify(targets.map(function (target) {
                        return target.shape
                    }))))
                }
                if (setX.length > 0 && setY.length > 0 && !tfjs_core_1.util.arraysEqual(setX, setY)) {
                    throw new errors_1.ValueError("Input Tensors should have the same number of samples as target " + ("Tensors. Found " + setX[0] + " input sample(s) and " + setY[0] + " target ") + "sample(s).")
                }
            }

            exports.checkArrayLengths = checkArrayLengths;

            function checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {
                var keyLosses = [losses.meanSquaredError, losses.binaryCrossentropy, losses.categoricalCrossentropy];
                for (var i = 0; i < targets.length; ++i) {
                    var y = targets[i];
                    var loss = lossFns[i];
                    var shape = outputShapes[i];
                    if (loss == null) {
                        continue
                    }
                    if (loss === losses.categoricalCrossentropy) {
                        if (y.shape[y.shape.length - 1] === 1) {
                            throw new errors_1.ValueError("You are passing a target array of shape " + y.shape + " while using " + "a loss 'categorical_crossentropy'. 'categorical_crossentropy'" + "expects targets to be binary matrices (1s and 0s) of shape " + "[samples, classes].")
                        }
                    }
                    if (keyLosses.indexOf(loss) !== -1) {
                        var slicedYShape = y.shape.slice(1);
                        var slicedShape = shape.slice(1);
                        for (var j = 0; j < slicedYShape.length; ++j) {
                            var targetDim = slicedYShape[j];
                            var outDim = slicedShape[j];
                            if (outDim != null && targetDim !== outDim) {
                                throw new errors_1.ValueError("A target Tensor with shape " + y.shape + " was passed for an " + ("output of shape " + shape + ", while using a loss function that ") + "expects targets to have the same shape as the output.")
                            }
                        }
                    }
                }
            }

            function makeBatches(size, batchSize) {
                var output = [];
                var batchStart = 0;
                var batchEnd = null;
                while (batchStart < size) {
                    batchEnd = batchStart + batchSize;
                    if (batchEnd >= size) {
                        batchEnd = size
                    }
                    output.push([batchStart, batchEnd]);
                    batchStart = batchEnd
                }
                return output
            }

            exports.makeBatches = makeBatches;

            function sliceArrays(arrays, start, stop) {
                if (arrays == null) {
                    return [null]
                } else if (Array.isArray(arrays)) {
                    return arrays.map(function (array) {
                        return K.sliceAlongFirstAxis(array, start, stop - start)
                    })
                } else {
                    return K.sliceAlongFirstAxis(arrays, start, stop - start)
                }
            }

            function sliceArraysByIndices(arrays, indices) {
                if (arrays == null) {
                    return null
                } else if (Array.isArray(arrays)) {
                    return arrays.map(function (array) {
                        return sliceArraysByIndices(array, indices)
                    })
                } else {
                    return K.gather(arrays, indices.dtype === "int32" ? indices : indices.toInt())
                }
            }

            exports.sliceArraysByIndices = sliceArraysByIndices;

            function checkInputData(data, names, shapes, checkBatchAxis, exceptionPrefix) {
                if (checkBatchAxis === void 0) {
                    checkBatchAxis = true
                }
                if (exceptionPrefix === void 0) {
                    exceptionPrefix = ""
                }
                var arrays;
                if (Array.isArray(data)) {
                    if (data.length !== names.length) {
                        throw new errors_1.ValueError("Error when checking model " + exceptionPrefix + ": the Array of " + "Tensors that you are passing to your model is not the size the " + ("the model expected. Expected to see " + names.length + " Tensor(s),") + (" but instead got " + data.length + " Tensors(s)."))
                    }
                    arrays = data
                } else {
                    if (names.length > 1) {
                        throw new errors_1.ValueError("The model expects " + names.length + " " + exceptionPrefix + " Tensors, " + "but only received one Tensor. Found: array with shape " + (JSON.stringify(data.shape) + "."))
                    }
                    arrays = [data]
                }
                if (shapes != null) {
                    for (var i = 0; i < names.length; ++i) {
                        if (shapes[i] == null) {
                            continue
                        }
                        var array = arrays[i];
                        if (array.shape.length !== shapes[i].length) {
                            throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + names[i] + " " + ("to have " + shapes[i].length + " dimension(s), but got array with ") + ("shape " + JSON.stringify(array.shape)))
                        }
                        for (var j = 0; j < shapes[i].length; ++j) {
                            if (j === 0 && !checkBatchAxis) {
                                continue
                            }
                            var dim = array.shape[j];
                            var refDim = shapes[i][j];
                            if (refDim != null) {
                                if (refDim !== dim) {
                                    throw new errors_1.ValueError("Error when checking " + exceptionPrefix + ": expected " + (names[i] + " to have shape " + JSON.stringify(shapes[i]) + " but ") + ("got array with shape " + JSON.stringify(array.shape) + "."))
                                }
                            }
                        }
                    }
                }
            }

            function collectMetrics(metrics, outputNames) {
                if (metrics == null || Array.isArray(metrics) && metrics.length === 0) {
                    return outputNames.map(function (name) {
                        return []
                    })
                }
                if (Array.isArray(metrics)) {
                    return outputNames.map(function (name) {
                        return metrics
                    })
                } else if (metrics != null) {
                    var nestedMetrics = [];
                    for (var _i = 0, outputNames_1 = outputNames; _i < outputNames_1.length; _i++) {
                        var name_2 = outputNames_1[_i];
                        var outputMetrics = metrics.hasOwnProperty(name_2) ? metrics[name_2] : [];
                        if (!Array.isArray(outputMetrics)) {
                            outputMetrics = [outputMetrics]
                        }
                        nestedMetrics.push(outputMetrics)
                    }
                    return nestedMetrics
                } else {
                    throw new TypeError("Type of metrics argument not understood. Expected an Array or " + "Object, found: " + metrics)
                }
            }

            var ModelLoggingVerbosity;
            (function (ModelLoggingVerbosity) {
                ModelLoggingVerbosity[ModelLoggingVerbosity["SILENT"] = 0] = "SILENT";
                ModelLoggingVerbosity[ModelLoggingVerbosity["VERBOSE"] = 1] = "VERBOSE"
            })(ModelLoggingVerbosity = exports.ModelLoggingVerbosity || (exports.ModelLoggingVerbosity = {}));
            var Model = function (_super) {
                __extends(Model, _super);

                function Model(config) {
                    return _super.call(this, config) || this
                }

                Model.prototype.compile = function (config) {
                    var _this = this;
                    if (config.loss == null) {
                        config.loss = []
                    }
                    this.loss = config.loss;
                    if (typeof config.optimizer === "string") {
                        this.optimizer = optimizers.getOptimizer(config.optimizer)
                    } else {
                        if (!(config.optimizer instanceof tfjs_core_1.Optimizer)) {
                            throw new errors_1.ValueError("User-defined optimizer must be an instance of tf.Optimizer.")
                        }
                        this.optimizer = config.optimizer
                    }
                    var lossFunctions = [];
                    if (!Array.isArray(config.loss) && typeof config.loss !== "string" && typeof config.loss !== "function") {
                        config.loss = config.loss;
                        for (var name_3 in config.loss) {
                            if (this.outputNames.indexOf(name_3) === -1) {
                                throw new errors_1.ValueError('Unknown entry in loss dictionary: "' + name_3 + '". Only expect the ' + ("following keys: " + this.outputNames))
                            }
                        }
                        for (var name_4 in this.outputNames) {
                            if (config.loss[name_4] == null) {
                                console.warn('Output "' + name_4 + '" is missing from loss dictionary. We assume ' + "this was done on purpose, and we will not be expecting data " + ("to be passed to " + name_4 + " during training"))
                            }
                            lossFunctions.push(losses.get(config.loss[name_4]))
                        }
                    } else if (Array.isArray(config.loss)) {
                        if (config.loss.length !== this.outputs.length) {
                            throw new errors_1.ValueError("When passing an Array as loss, it should have one entry per " + ("model output. The model has " + this.outputs.length + " output(s), ") + ("but you passed loss=" + config.loss + "."))
                        }
                        var theLosses = config.loss;
                        lossFunctions = theLosses.map(function (l) {
                            return losses.get(l)
                        })
                    } else {
                        var lossFunction_1 = losses.get(config.loss);
                        this.outputs.map(function (layer) {
                            lossFunctions.push(lossFunction_1)
                        })
                    }
                    this.lossFunctions = lossFunctions;
                    this.feedOutputNames = [];
                    this.feedOutputShapes = [];
                    this.feedLossFns = [];
                    for (var i = 0; i < this.outputs.length; ++i) {
                        var shape = this.internalOutputShapes[i];
                        var name_5 = this.outputNames[i];
                        this.feedOutputNames.push(name_5);
                        this.feedOutputShapes.push(shape);
                        this.feedLossFns.push(this.lossFunctions[i])
                    }
                    var skipTargetIndices = [];
                    this.metrics = config.metrics;
                    this.metricsNames = ["loss"];
                    this.metricsTensors = [];
                    K.nameScope("loss", function () {
                        for (var i = 0; i < _this.outputs.length; ++i) {
                            if (skipTargetIndices.indexOf(i) !== -1) {
                                continue
                            }
                            var weightedLoss = _this.lossFunctions[i];
                            if (_this.outputs.length > 1) {
                                _this.metricsTensors.push([weightedLoss, i]);
                                _this.metricsNames.push(_this.outputNames[i] + "_loss")
                            }
                        }
                    });
                    var nestedMetrics = collectMetrics(config.metrics, this.outputNames);
                    var appendMetric = function (outputIndex, metricName, metricTensor) {
                        if (_this.outputNames.length > 1) {
                            metricName = _this.outputNames[outputIndex] + "_" + metricName
                        }
                        _this.metricsNames.push(metricName);
                        _this.metricsTensors.push([metricTensor, outputIndex])
                    };
                    K.nameScope("metric", function () {
                        var _loop_1 = function (i) {
                            if (skipTargetIndices.indexOf(i) !== -1) {
                                return "continue"
                            }
                            var outputMetrics = nestedMetrics[i];
                            var handleMetrics = function (metrics) {
                                var metricNamePrefix = "";
                                var metricName;
                                var accFn;
                                var weightedMetricFn;
                                var _loop_2 = function (metric) {
                                    if (["accuracy", "acc", "crossentropy", "ce"].indexOf(metric) !== -1) {
                                        var outputShape = _this.internalOutputShapes[i];
                                        if (outputShape[outputShape.length - 1] === 1 || _this.lossFunctions[i] === losses.binaryCrossentropy) {
                                            if (["accuracy", "acc"].indexOf(metric) !== -1) {
                                                accFn = Metrics.binaryAccuracy
                                            } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                                                accFn = Metrics.binaryCrossentropy
                                            }
                                        } else if (_this.lossFunctions[i] === losses.sparseCategoricalCrossentropy) {
                                            if (["accuracy", "acc"].indexOf(metric) !== -1) {
                                                accFn = Metrics.sparseCategoricalAccuracy
                                            } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                                                accFn = Metrics.sparseCategoricalCrossentropy
                                            }
                                        } else {
                                            if (["accuracy", "acc"].indexOf(metric) !== -1) {
                                                accFn = Metrics.categoricalAccuracy
                                            } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                                                accFn = Metrics.categoricalCrossentropy
                                            }
                                        }
                                        var suffix = void 0;
                                        if (["accuracy", "acc"].indexOf(metric) !== -1) {
                                            suffix = "acc"
                                        } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                                            suffix = "ce"
                                        }
                                        weightedMetricFn = accFn;
                                        metricName = metricNamePrefix + suffix
                                    } else {
                                        var metricFn = Metrics.get(metric);
                                        weightedMetricFn = metricFn;
                                        metricName = metricNamePrefix + metric
                                    }
                                    var metricResult;
                                    K.nameScope(metricName, function () {
                                        metricResult = weightedMetricFn
                                    });
                                    appendMetric(i, metricName, metricResult)
                                };
                                for (var _i = 0, metrics_1 = metrics; _i < metrics_1.length; _i++) {
                                    var metric = metrics_1[_i];
                                    _loop_2(metric)
                                }
                            };
                            handleMetrics(outputMetrics)
                        };
                        for (var i = 0; i < _this.outputs.length; ++i) {
                            _loop_1(i)
                        }
                    });
                    this.collectedTrainableWeights = this.trainableWeights
                };
                Model.prototype.checkTrainableWeightsConsistency = function () {
                    if (this.collectedTrainableWeights == null) {
                        return
                    }
                    if (this.trainableWeights.length !== this.collectedTrainableWeights.length) {
                        console.warn("Discrepancy between trainableweights and collected trainable " + "weights. Did you set `model.trainable` without calling " + "`model.compile()` afterwards?")
                    }
                };
                Model.prototype.evaluate = function (x, y, config) {
                    if (config === void 0) {
                        config = {}
                    }
                    var batchSize = config.batchSize == null ? 32 : config.batchSize;
                    var standardizedOuts = this.standardizeUserData(x, y, true, batchSize);
                    var ins = standardizedOuts[0].concat(standardizedOuts[1]);
                    this.makeTestFunction();
                    var f = this.testFunction;
                    var testOuts = this.testLoop(f, ins, batchSize, config.verbose, config.steps);
                    return generic_utils_1.singletonOrArray(testOuts)
                };
                Model.prototype.checkNumSamples = function (ins, batchSize, steps, stepsName) {
                    if (stepsName === void 0) {
                        stepsName = "steps"
                    }
                    var numSamples;
                    if (steps != null) {
                        numSamples = null;
                        if (batchSize != null) {
                            throw new errors_1.ValueError("If " + stepsName + " is set, batchSize must be null or undefined." + ("Got batchSize = " + batchSize))
                        }
                    } else if (ins != null) {
                        if (Array.isArray(ins)) {
                            numSamples = ins[0].shape[0]
                        } else {
                            numSamples = ins.shape[0]
                        }
                    } else {
                        throw new errors_1.ValueError("Either the input data should have a defined shape, or " + (stepsName + " shoud be specified."))
                    }
                    return numSamples
                };
                Model.prototype.predictLoop = function (ins, batchSize, verbose) {
                    var _this = this;
                    if (batchSize === void 0) {
                        batchSize = 32
                    }
                    if (verbose === void 0) {
                        verbose = false
                    }
                    var numSamples = this.checkNumSamples(ins);
                    if (verbose) {
                        throw new errors_1.NotImplementedError("Verbose predictLoop() is not implemented yet.")
                    }
                    var batches = makeBatches(numSamples, batchSize);
                    var outs = [];
                    var _loop_3 = function (batchIndex) {
                        var batchOuts = tfc.tidy(function () {
                            var batchStart = batches[batchIndex][0];
                            var batchEnd = batches[batchIndex][1];
                            var insBatch = sliceArrays(ins, batchStart, batchEnd);
                            var feeds = [];
                            if (Array.isArray(insBatch)) {
                                for (var i = 0; i < insBatch.length; ++i) {
                                    feeds.push({key: _this.inputs[i], value: insBatch[i]})
                                }
                            } else {
                                feeds.push({key: _this.inputs[0], value: insBatch})
                            }
                            var feedDict = new executor_1.FeedDict(feeds);
                            return executor_1.execute(_this.outputs, feedDict)
                        });
                        if (batchIndex === 0) {
                            for (var _i = 0, batchOuts_1 = batchOuts; _i < batchOuts_1.length; _i++) {
                                var batchOut = batchOuts_1[_i];
                                outs.push(batchOut)
                            }
                        } else {
                            for (var i = 0; i < batchOuts.length; ++i) {
                                outs[i] = K.concatAlongFirstAxis(outs[i], batchOuts[i])
                            }
                        }
                    };
                    for (var batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
                        _loop_3(batchIndex)
                    }
                    return generic_utils_1.singletonOrArray(outs)
                };
                Model.prototype.predict = function (x, config) {
                    if (config === void 0) {
                        config = {}
                    }
                    checkInputData(x, this.inputNames, this.feedInputShapes, false);
                    var batchSize = config.batchSize == null ? 32 : config.batchSize;
                    return this.predictLoop(x, batchSize)
                };
                Model.prototype.predictOnBatch = function (x) {
                    checkInputData(x, this.inputNames, this.feedInputShapes, true);
                    return this.predictLoop(x, x.shape[0])
                };
                Model.prototype.standardizeUserData = function (x, y, checkBatchAxis, batchSize) {
                    if (checkBatchAxis === void 0) {
                        checkBatchAxis = true
                    }
                    if (this.optimizer == null) {
                        throw new errors_1.RuntimeError("You must compile a model before training/testing. Use " + "Model.compile(modelCompileConfig).")
                    }
                    var outputShapes = [];
                    for (var i = 0; i < this.feedOutputShapes.length; ++i) {
                        var outputShape = this.feedOutputShapes[i];
                        var lossFn = this.feedLossFns[i];
                        if (lossFn === losses.sparseCategoricalCrossentropy) {
                            outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]))
                        } else {
                            outputShapes.push(outputShape)
                        }
                    }
                    x = standardizeInputData(x, this.feedInputNames, this.feedInputShapes, false, "input");
                    y = standardizeInputData(y, this.feedOutputNames, outputShapes, false, "target");
                    checkArrayLengths(x, y, null);
                    checkLossAndTargetCompatibility(y, this.feedLossFns, this.feedOutputShapes);
                    if (this.stateful && batchSize != null && batchSize > 0) {
                        if (x[0].shape[0] % batchSize !== 0) {
                            throw new errors_1.ValueError("In a stateful network, you should only pass inputs with a " + "number of samples that is divisible by the batch size " + (batchSize + ". Found: " + x[0].shape[0] + " sample(s)."))
                        }
                    }
                    return [x, y, null]
                };
                Model.prototype.fitLoop = function (f, ins, outLabels, batchSize, epochs, verbose, callbacks, valF, valIns, shuffle, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {
                    if (initialEpoch === void 0) {
                        initialEpoch = 0
                    }
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var doValidation, numTrainSamples, indexArray, callbackList, _loop_4, epoch;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (batchSize == null) {
                                        batchSize = 32
                                    }
                                    if (epochs == null) {
                                        epochs = 1
                                    }
                                    if (shuffle == null) {
                                        shuffle = true
                                    }
                                    if (initialEpoch == null) {
                                        initialEpoch = 0
                                    }
                                    doValidation = false;
                                    if (valF != null && valIns != null) {
                                        doValidation = true
                                    }
                                    if (validationSteps != null) {
                                        doValidation = true;
                                        if (stepsPerEpoch == null) {
                                            throw new errors_1.ValueError("Can only use `validationSteps` when doing step-wise training, " + "i.e., `stepsPerEpoch` must be set.")
                                        }
                                    }
                                    numTrainSamples = this.checkNumSamples(ins, batchSize, stepsPerEpoch, "steps_per_epoch");
                                    if (numTrainSamples != null) {
                                        indexArray = math_utils_1.range(0, numTrainSamples)
                                    }
                                    this.history = new callbacks_1.History;
                                    if (callbacks == null) {
                                        callbacks = [new callbacks_1.BaseLogger]
                                    } else {
                                        callbacks = [new callbacks_1.BaseLogger].concat(callbacks)
                                    }
                                    callbacks = callbacks.concat([this.history]);
                                    if (verbose > 0) {
                                        throw new errors_1.NotImplementedError("Verbose mode is not implemented yet.")
                                    }
                                    callbackList = new callbacks_1.CallbackList(callbacks);
                                    callbackList.setModel(this);
                                    callbackList.setParams({
                                        epochs: epochs,
                                        steps: stepsPerEpoch,
                                        verbose: verbose,
                                        doValidation: doValidation,
                                        metrics: callbackMetrics
                                    });
                                    return [4, callbackList.onTrainBegin()];
                                case 1:
                                    _a.sent();
                                    _loop_4 = function (epoch) {
                                        var epochLogs, epochIndexArray1D_1, batches_1, _loop_5, batchIndex;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    return [4, callbackList.onEpochBegin(epoch)];
                                                case 1:
                                                    _a.sent();
                                                    epochLogs = {};
                                                    if (!(stepsPerEpoch != null)) return [3, 2];
                                                    throw new errors_1.NotImplementedError("stepsPerEpoch mode is not implemented yet.");
                                                case 2:
                                                    if (shuffle === "batch") {
                                                        throw new errors_1.NotImplementedError("batch shuffling is not implemneted yet")
                                                    } else if (shuffle) {
                                                        tfjs_core_1.util.shuffle(indexArray)
                                                    }
                                                    epochIndexArray1D_1 = tfjs_core_1.tensor1d(indexArray);
                                                    batches_1 = makeBatches(numTrainSamples, batchSize);
                                                    _loop_5 = function (batchIndex) {
                                                        var batchLogs;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    batchLogs = {};
                                                                    return [4, callbackList.onBatchBegin(batchIndex, batchLogs)];
                                                                case 1:
                                                                    _a.sent();
                                                                    tfc.tidy(function () {
                                                                        var batchStart = batches_1[batchIndex][0];
                                                                        var batchEnd = batches_1[batchIndex][1];
                                                                        var batchIds = K.sliceAlongFirstAxis(epochIndexArray1D_1, batchStart, batchEnd - batchStart);
                                                                        batchLogs["batch"] = batchIndex;
                                                                        batchLogs["size"] = batchEnd - batchStart;
                                                                        var insBatch = sliceArraysByIndices(ins, batchIds);
                                                                        var outs = f(insBatch);
                                                                        for (var i = 0; i < outLabels.length; ++i) {
                                                                            var label = outLabels[i];
                                                                            var out = outs[i];
                                                                            batchLogs[label] = out;
                                                                            tfc.keep(out)
                                                                        }
                                                                        if (batchIndex === batches_1.length - 1) {
                                                                            if (doValidation) {
                                                                                var valOuts = _this.testLoop(valF, valIns, batchSize);
                                                                                for (var i = 0; i < outLabels.length; ++i) {
                                                                                    var label = outLabels[i];
                                                                                    var out = valOuts[i];
                                                                                    tfc.keep(out);
                                                                                    epochLogs["val_" + label] = out
                                                                                }
                                                                            }
                                                                        }
                                                                    });
                                                                    return [4, callbackList.onBatchEnd(batchIndex, batchLogs)];
                                                                case 2:
                                                                    _a.sent();
                                                                    callbacks_1.disposeTensorsInLogs(batchLogs);
                                                                    return [2]
                                                            }
                                                        })
                                                    };
                                                    batchIndex = 0;
                                                    _a.label = 3;
                                                case 3:
                                                    if (!(batchIndex < batches_1.length)) return [3, 6];
                                                    return [5, _loop_5(batchIndex)];
                                                case 4:
                                                    _a.sent();
                                                    _a.label = 5;
                                                case 5:
                                                    ++batchIndex;
                                                    return [3, 3];
                                                case 6:
                                                    epochIndexArray1D_1.dispose();
                                                    _a.label = 7;
                                                case 7:
                                                    return [4, callbackList.onEpochEnd(epoch, epochLogs)];
                                                case 8:
                                                    _a.sent();
                                                    return [2]
                                            }
                                        })
                                    };
                                    epoch = initialEpoch;
                                    _a.label = 2;
                                case 2:
                                    if (!(epoch < epochs)) return [3, 5];
                                    return [5, _loop_4(epoch)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4:
                                    ++epoch;
                                    return [3, 2];
                                case 5:
                                    return [4, callbackList.onTrainEnd()];
                                case 6:
                                    _a.sent();
                                    return [4, this.history.syncData()];
                                case 7:
                                    _a.sent();
                                    return [2, this.history]
                            }
                        })
                    })
                };
                Model.prototype.testLoop = function (f, ins, batchSize, verbose, steps) {
                    if (verbose === void 0) {
                        verbose = 0
                    }
                    var numSamples = this.checkNumSamples(ins, batchSize, steps, "steps");
                    var outs = [];
                    if (verbose === 1) {
                        throw new errors_1.NotImplementedError("Verbose mode is not implemented yet.")
                    }
                    if (steps != null) {
                        throw new errors_1.NotImplementedError("steps mode in testLoop() is not implemented yet")
                    } else {
                        var batches = makeBatches(numSamples, batchSize);
                        var indexArray = tfjs_core_1.tensor1d(math_utils_1.range(0, numSamples));
                        for (var batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
                            var batchStart = batches[batchIndex][0];
                            var batchEnd = batches[batchIndex][1];
                            var batchIds = K.sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);
                            var insBatch = sliceArraysByIndices(ins, batchIds);
                            var batchOuts = f(insBatch);
                            if (batchIndex === 0) {
                                for (var i = 0; i < batchOuts.length; ++i) {
                                    outs.push(K.getScalar(0))
                                }
                            }
                            for (var i = 0; i < batchOuts.length; ++i) {
                                var batchOut = batchOuts[i];
                                outs[i] = tfc.add(outs[i], K.scalarTimesArray(K.getScalar(batchEnd - batchStart), batchOut))
                            }
                        }
                        for (var i = 0; i < outs.length; ++i) {
                            outs[i] = tfc.div(outs[i], K.getScalar(numSamples))
                        }
                    }
                    return outs
                };
                Model.prototype.getDedupedMetricsNames = function () {
                    var outLabels = this.metricsNames;
                    var dedupedOutLabels = [];
                    for (var i = 0; i < outLabels.length; ++i) {
                        var label = outLabels[i];
                        var newLabel = label;
                        if (generic_utils_1.count(outLabels, label) > 1) {
                            var dupIndex = generic_utils_1.count(outLabels.slice(0, i), label);
                            newLabel += "_" + dupIndex
                        }
                        dedupedOutLabels.push(newLabel)
                    }
                    return dedupedOutLabels
                };
                Model.prototype.makeTestFunction = function () {
                    var _this = this;
                    this.testFunction = function (data) {
                        return tfc.tidy(function () {
                            var valOutputs = [];
                            var totalLoss;
                            var inputs = data.slice(0, _this.inputs.length);
                            var targets = data.slice(_this.inputs.length, _this.inputs.length + _this.outputs.length);
                            var feeds = [];
                            for (var i = 0; i < _this.inputs.length; ++i) {
                                feeds.push({key: _this.inputs[i], value: inputs[i]})
                            }
                            var feedDict = new executor_1.FeedDict(feeds);
                            var outputs = executor_1.execute(_this.outputs, feedDict);
                            for (var i = 0; i < _this.lossFunctions.length; ++i) {
                                var lossFunction = _this.lossFunctions[i];
                                var loss = tfc.mean(lossFunction(targets[i], outputs[i]));
                                if (i === 0) {
                                    totalLoss = loss
                                } else {
                                    totalLoss = tfc.add(totalLoss, loss)
                                }
                                valOutputs.push(totalLoss)
                            }
                            for (var i = 0; i < _this.metricsTensors.length; ++i) {
                                var metric = _this.metricsTensors[i][0];
                                var outputIndex = _this.metricsTensors[i][1];
                                var meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));
                                valOutputs.push(meanMetric)
                            }
                            return valOutputs
                        })
                    }
                };
                Model.prototype.fit = function (x, y, config) {
                    if (config === void 0) {
                        config = {}
                    }
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var batchSize, standardizedOuts, inputs, targets, doValidation, valX, valY, valIns,
                            valStandardized, splitAt, originalBatchSize, ins, trainFunction, outLabels, valFunction,
                            callbackMetrics, callbacks;
                        return __generator(this, function (_a) {
                            batchSize = config.batchSize == null ? 32 : config.batchSize;
                            standardizedOuts = this.standardizeUserData(x, y, false, batchSize);
                            inputs = standardizedOuts[0];
                            targets = standardizedOuts[1];
                            doValidation = false;
                            if (config.validationData != null && config.validationData.length > 0) {
                                doValidation = true;
                                if (config.validationData.length === 2) {
                                    valX = config.validationData[0];
                                    valY = config.validationData[1]
                                } else if (config.validationData.length === 3) {
                                    throw new errors_1.NotImplementedError("validationData including sample weights is not supported yet.")
                                } else {
                                    throw new errors_1.ValueError("When passing validation data, it must contain 2 (valX, valY) " + "or 3 (valX, valY, valSampleWeight) items; " + (config.validationData + " is invalid."))
                                }
                                valStandardized = this.standardizeUserData(valX, valY, true, batchSize);
                                valX = valStandardized[0];
                                valY = valStandardized[1];
                                valIns = valX.concat(valY)
                            } else if (config.validationSplit != null && config.validationSplit > 0 && config.validationSplit < 1) {
                                doValidation = true;
                                splitAt = Math.floor(inputs[0].shape[0] * (1 - config.validationSplit));
                                originalBatchSize = inputs[0].shape[0];
                                valX = sliceArrays(inputs, splitAt, originalBatchSize);
                                inputs = sliceArrays(inputs, 0, splitAt);
                                valY = sliceArrays(targets, splitAt, originalBatchSize);
                                targets = sliceArrays(targets, 0, splitAt);
                                valIns = valX.concat(valY)
                            } else if (config.validationSteps != null) {
                                doValidation = true
                            }
                            ins = inputs.concat(targets);
                            this.checkTrainableWeightsConsistency();
                            trainFunction = function (data) {
                                var losses = [];
                                var lossValues = [];
                                var inputs = data.slice(0, _this.inputs.length);
                                var targets = data.slice(_this.inputs.length, _this.inputs.length + _this.outputs.length);
                                var metricsValues = [];
                                var totalLossFunction = function () {
                                    var feeds = [];
                                    for (var i = 0; i < _this.inputs.length; ++i) {
                                        feeds.push({key: _this.inputs[i], value: inputs[i]})
                                    }
                                    var feedDict = new executor_1.FeedDict(feeds);
                                    var outputs = executor_1.execute(_this.outputs, feedDict, {training: true});
                                    var totalLoss;
                                    for (var i = 0; i < _this.lossFunctions.length; ++i) {
                                        var lossFunction = _this.lossFunctions[i];
                                        var loss = lossFunction(targets[i], outputs[i]);
                                        losses.push(loss);
                                        var meanLoss = tfc.mean(loss);
                                        lossValues.push(meanLoss);
                                        if (i === 0) {
                                            totalLoss = loss
                                        } else {
                                            totalLoss = tfc.add(totalLoss, loss)
                                        }
                                    }
                                    for (var i = 0; i < _this.metricsTensors.length; ++i) {
                                        var metric = _this.metricsTensors[i][0];
                                        var outputIndex = _this.metricsTensors[i][1];
                                        var meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));
                                        tfc.keep(meanMetric);
                                        metricsValues.push(meanMetric)
                                    }
                                    totalLoss = tfc.mean(totalLoss);
                                    _this.calculateLosses().forEach(function (regularizerLoss) {
                                        totalLoss = tfc.add(totalLoss, regularizerLoss)
                                    });
                                    return totalLoss
                                };
                                var variables = _this.collectedTrainableWeights.map(function (param) {
                                    return param.read()
                                });
                                var returnCost = true;
                                var totalLossValue = _this.optimizer.minimize(totalLossFunction, returnCost, variables);
                                return [totalLossValue].concat(metricsValues)
                            };
                            outLabels = this.getDedupedMetricsNames();
                            if (doValidation) {
                                this.makeTestFunction();
                                valFunction = this.testFunction;
                                callbackMetrics = outLabels.slice().concat(outLabels.map(function (n) {
                                    return "val_" + n
                                }))
                            } else {
                                valFunction = null;
                                valIns = [];
                                callbackMetrics = outLabels.slice()
                            }
                            callbacks = callbacks_1.standardizeCallbacks(config.callbacks);
                            return [2, this.fitLoop(trainFunction, ins, outLabels, batchSize, config.epochs, config.verbose, callbacks, valFunction, valIns, config.shuffle, callbackMetrics, null, null, null)]
                        })
                    })
                };
                Model.prototype.getNamedWeights = function (config) {
                    var namedWeights = {};
                    var trainableOnly = config != null && config.trainableOnly;
                    var weights = trainableOnly ? this.trainableWeights : this.weights;
                    var weightValues = this.getWeights(trainableOnly);
                    for (var i = 0; i < weights.length; ++i) {
                        if (trainableOnly && !weights[i].trainable) {
                            continue
                        }
                        namedWeights[weights[i].originalName] = weightValues[i]
                    }
                    return namedWeights
                };
                Model.prototype.save = function (handlerOrURL, config) {
                    return __awaiter(this, void 0, void 0, function () {
                        var handlers, weightDataAndSpecs, returnString, unusedArg, modelConfig;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof handlerOrURL === "string") {
                                        handlers = tfjs_core_1.io.getSaveHandlers(handlerOrURL);
                                        if (handlers.length === 0) {
                                            throw new errors_1.ValueError("Cannot find any save handlers for URL '" + handlerOrURL + "'")
                                        } else if (handlers.length > 1) {
                                            throw new errors_1.ValueError("Found more than one (" + handlers.length + ") save handlers for " + ("URL '" + handlerOrURL + "'"))
                                        }
                                        handlerOrURL = handlers[0]
                                    }
                                    if (handlerOrURL.save == null) {
                                        throw new errors_1.ValueError("Model.save() cannot proceed because the IOHandler provided does " + "not have the `save` attribute defined.")
                                    }
                                    return [4, tfjs_core_1.io.encodeWeights(this.getNamedWeights(config))];
                                case 1:
                                    weightDataAndSpecs = _a.sent();
                                    returnString = false;
                                    unusedArg = null;
                                    modelConfig = this.toJSON(unusedArg, returnString);
                                    return [2, handlerOrURL.save({
                                        modelTopology: modelConfig,
                                        weightData: weightDataAndSpecs.data,
                                        weightSpecs: weightDataAndSpecs.specs
                                    })]
                            }
                        })
                    })
                };
                Model.className = "Model";
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes",
                    configParamIndices: [0]
                })], Model.prototype, "compile", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes",
                    configParamIndices: [2]
                })], Model.prototype, "evaluate", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes",
                    configParamIndices: [1]
                })], Model.prototype, "predict", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes"
                })], Model.prototype, "predictOnBatch", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes",
                    configParamIndices: [2]
                })], Model.prototype, "fit", null);
                Model = __decorate([tfjs_core_1.doc({heading: "Models", subheading: "Classes"})], Model);
                return Model
            }(topology_1.Container);
            exports.Model = Model;
            tfjs_core_1.serialization.SerializationMap.register(Model)
        }, {
            "../backend/tfjs_backend": 158,
            "../callbacks": 159,
            "../errors": 165,
            "../losses": 181,
            "../metrics": 182,
            "../optimizers": 184,
            "../utils/generic_utils": 188,
            "../utils/math_utils": 189,
            "./executor": 162,
            "./topology": 163,
            "@tensorflow/tfjs-core": 50
        }],
        165: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var AttributeError = function (_super) {
                __extends(AttributeError, _super);

                function AttributeError(message) {
                    var _this = _super.call(this, message) || this;
                    Object.setPrototypeOf(_this, AttributeError.prototype);
                    return _this
                }

                return AttributeError
            }(Error);
            exports.AttributeError = AttributeError;
            var RuntimeError = function (_super) {
                __extends(RuntimeError, _super);

                function RuntimeError(message) {
                    var _this = _super.call(this, message) || this;
                    Object.setPrototypeOf(_this, RuntimeError.prototype);
                    return _this
                }

                return RuntimeError
            }(Error);
            exports.RuntimeError = RuntimeError;
            var ValueError = function (_super) {
                __extends(ValueError, _super);

                function ValueError(message) {
                    var _this = _super.call(this, message) || this;
                    Object.setPrototypeOf(_this, ValueError.prototype);
                    return _this
                }

                return ValueError
            }(Error);
            exports.ValueError = ValueError;
            var NotImplementedError = function (_super) {
                __extends(NotImplementedError, _super);

                function NotImplementedError(message) {
                    var _this = _super.call(this, message) || this;
                    Object.setPrototypeOf(_this, NotImplementedError.prototype);
                    return _this
                }

                return NotImplementedError
            }(Error);
            exports.NotImplementedError = NotImplementedError;
            var AssertionError = function (_super) {
                __extends(AssertionError, _super);

                function AssertionError(message) {
                    var _this = _super.call(this, message) || this;
                    Object.setPrototypeOf(_this, AssertionError.prototype);
                    return _this
                }

                return AssertionError
            }(Error);
            exports.AssertionError = AssertionError;
            var IndexError = function (_super) {
                __extends(IndexError, _super);

                function IndexError(message) {
                    var _this = _super.call(this, message) || this;
                    Object.setPrototypeOf(_this, IndexError.prototype);
                    return _this
                }

                return IndexError
            }(Error);
            exports.IndexError = IndexError
        }, {}],
        166: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var constraints_1 = require("./constraints");
            var topology_1 = require("./engine/topology");
            var training_1 = require("./engine/training");
            var initializers_1 = require("./initializers");
            var advanced_activations_1 = require("./layers/advanced_activations");
            var convolutional_1 = require("./layers/convolutional");
            var convolutional_depthwise_1 = require("./layers/convolutional_depthwise");
            var core_1 = require("./layers/core");
            var embeddings_1 = require("./layers/embeddings");
            var merge_1 = require("./layers/merge");
            var normalization_1 = require("./layers/normalization");
            var padding_1 = require("./layers/padding");
            var pooling_1 = require("./layers/pooling");
            var recurrent_1 = require("./layers/recurrent");
            var wrappers_1 = require("./layers/wrappers");
            var losses_1 = require("./losses");
            var metrics_1 = require("./metrics");
            var models_1 = require("./models");
            var regularizers_1 = require("./regularizers");
            var ModelExports = function () {
                function ModelExports() {
                }

                ModelExports.model = function (config) {
                    return new training_1.Model(config)
                };
                ModelExports.sequential = function (config) {
                    return new models_1.Sequential(config)
                };
                ModelExports.loadModel = function (pathOrIOHandler) {
                    return models_1.loadModelInternal(pathOrIOHandler)
                };
                ModelExports.input = function (config) {
                    return topology_1.Input(config)
                };
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Creation",
                    configParamIndices: [0]
                })], ModelExports, "model", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Creation",
                    configParamIndices: [0]
                })], ModelExports, "sequential", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Loading",
                    useDocsFrom: "loadModelInternal"
                })], ModelExports, "loadModel", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Inputs",
                    useDocsFrom: "Input",
                    configParamIndices: [0]
                })], ModelExports, "input", null);
                return ModelExports
            }();
            exports.ModelExports = ModelExports;
            var LayerExports = function () {
                function LayerExports() {
                }

                LayerExports.inputLayer = function (config) {
                    return new topology_1.InputLayer(config)
                };
                LayerExports.elu = function (config) {
                    return new advanced_activations_1.ELU(config)
                };
                LayerExports.leakyReLU = function (config) {
                    return new advanced_activations_1.LeakyReLU(config)
                };
                LayerExports.softmax = function (config) {
                    return new advanced_activations_1.Softmax(config)
                };
                LayerExports.thresholdedReLU = function (config) {
                    return new advanced_activations_1.ThresholdedReLU(config)
                };
                LayerExports.conv1d = function (config) {
                    return new convolutional_1.Conv1D(config)
                };
                LayerExports.conv2d = function (config) {
                    return new convolutional_1.Conv2D(config)
                };
                LayerExports.conv2dTranspose = function (config) {
                    return new convolutional_1.Conv2DTranspose(config)
                };
                LayerExports.separableConv2d = function (config) {
                    return new convolutional_1.SeparableConv2D(config)
                };
                LayerExports.cropping2D = function (config) {
                    return new convolutional_1.Cropping2D(config)
                };
                LayerExports.depthwiseConv2d = function (config) {
                    return new convolutional_depthwise_1.DepthwiseConv2D(config)
                };
                LayerExports.activation = function (config) {
                    return new core_1.Activation(config)
                };
                LayerExports.dense = function (config) {
                    return new core_1.Dense(config)
                };
                LayerExports.dropout = function (config) {
                    return new core_1.Dropout(config)
                };
                LayerExports.flatten = function (config) {
                    return new core_1.Flatten(config)
                };
                LayerExports.repeatVector = function (config) {
                    return new core_1.RepeatVector(config)
                };
                LayerExports.reshape = function (config) {
                    return new core_1.Reshape(config)
                };
                LayerExports.embedding = function (config) {
                    return new embeddings_1.Embedding(config)
                };
                LayerExports.add = function (config) {
                    return new merge_1.Add(config)
                };
                LayerExports.average = function (config) {
                    return new merge_1.Average(config)
                };
                LayerExports.concatenate = function (config) {
                    return new merge_1.Concatenate(config)
                };
                LayerExports.maximum = function (config) {
                    return new merge_1.Maximum(config)
                };
                LayerExports.minimum = function (config) {
                    return new merge_1.Minimum(config)
                };
                LayerExports.multiply = function (config) {
                    return new merge_1.Multiply(config)
                };
                LayerExports.batchNormalization = function (config) {
                    return new normalization_1.BatchNormalization(config)
                };
                LayerExports.zeroPadding2d = function (config) {
                    return new padding_1.ZeroPadding2D(config)
                };
                LayerExports.averagePooling1d = function (config) {
                    return new pooling_1.AveragePooling1D(config)
                };
                LayerExports.avgPool1d = function (config) {
                    return LayerExports.averagePooling1d(config)
                };
                LayerExports.avgPooling1d = function (config) {
                    return LayerExports.averagePooling1d(config)
                };
                LayerExports.averagePooling2d = function (config) {
                    return new pooling_1.AveragePooling2D(config)
                };
                LayerExports.avgPool2d = function (config) {
                    return LayerExports.averagePooling2d(config)
                };
                LayerExports.avgPooling2d = function (config) {
                    return LayerExports.averagePooling2d(config)
                };
                LayerExports.globalAveragePooling1d = function (config) {
                    return new pooling_1.GlobalAveragePooling1D(config)
                };
                LayerExports.globalAveragePooling2d = function (config) {
                    return new pooling_1.GlobalAveragePooling2D(config)
                };
                LayerExports.globalMaxPooling1d = function (config) {
                    return new pooling_1.GlobalMaxPooling1D(config)
                };
                LayerExports.globalMaxPooling2d = function (config) {
                    return new pooling_1.GlobalMaxPooling2D(config)
                };
                LayerExports.maxPooling1d = function (config) {
                    return new pooling_1.MaxPooling1D(config)
                };
                LayerExports.maxPooling2d = function (config) {
                    return new pooling_1.MaxPooling2D(config)
                };
                LayerExports.gru = function (config) {
                    return new recurrent_1.GRU(config)
                };
                LayerExports.gruCell = function (config) {
                    return new recurrent_1.GRUCell(config)
                };
                LayerExports.lstm = function (config) {
                    return new recurrent_1.LSTM(config)
                };
                LayerExports.lstmCell = function (config) {
                    return new recurrent_1.LSTMCell(config)
                };
                LayerExports.simpleRNN = function (config) {
                    return new recurrent_1.SimpleRNN(config)
                };
                LayerExports.simpleRNNCell = function (config) {
                    return new recurrent_1.SimpleRNNCell(config)
                };
                LayerExports.rnn = function (config) {
                    return new recurrent_1.RNN(config)
                };
                LayerExports.stackedRNNCells = function (config) {
                    return new recurrent_1.StackedRNNCells(config)
                };
                LayerExports.bidirectional = function (config) {
                    return new wrappers_1.Bidirectional(config)
                };
                LayerExports.timeDistributed = function (config) {
                    return new wrappers_1.TimeDistributed(config)
                };
                LayerExports.Layer = topology_1.Layer;
                LayerExports.RNN = recurrent_1.RNN;
                LayerExports.RNNCell = recurrent_1.RNNCell;
                LayerExports.input = ModelExports.input;
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Inputs",
                    namespace: "layers",
                    useDocsFrom: "InputLayer",
                    configParamIndices: [0]
                })], LayerExports, "inputLayer", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Advanced Activation",
                    namespace: "layers",
                    useDocsFrom: "ELU",
                    configParamIndices: [0]
                })], LayerExports, "elu", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Advanced Activation",
                    namespace: "layers",
                    useDocsFrom: "LeakyReLU",
                    configParamIndices: [0]
                })], LayerExports, "leakyReLU", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Advanced Activation",
                    namespace: "layers",
                    useDocsFrom: "Softmax",
                    configParamIndices: [0]
                })], LayerExports, "softmax", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Advanced Activation",
                    namespace: "layers",
                    useDocsFrom: "ThresholdedReLU",
                    configParamIndices: [0]
                })], LayerExports, "thresholdedReLU", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Convolutional",
                    namespace: "layers",
                    useDocsFrom: "Conv1D",
                    configParamIndices: [0]
                })], LayerExports, "conv1d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Convolutional",
                    namespace: "layers",
                    useDocsFrom: "Conv2D",
                    configParamIndices: [0]
                })], LayerExports, "conv2d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Convolutional",
                    namespace: "layers",
                    useDocsFrom: "Conv2DTranspose",
                    configParamIndices: [0]
                })], LayerExports, "conv2dTranspose", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Convolutional",
                    namespace: "layers",
                    useDocsFrom: "SeparableConv2D",
                    configParamIndices: [0]
                })], LayerExports, "separableConv2d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Convolutional",
                    namespace: "layers",
                    useDocsFrom: "Cropping2D",
                    configParamIndices: [0]
                })], LayerExports, "cropping2D", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Convolutional",
                    namespace: "layers",
                    useDocsFrom: "DepthwiseConv2D",
                    configParamIndices: [0]
                })], LayerExports, "depthwiseConv2d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Basic",
                    namespace: "layers",
                    useDocsFrom: "Activation",
                    configParamIndices: [0]
                })], LayerExports, "activation", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Basic",
                    namespace: "layers",
                    useDocsFrom: "Dense",
                    configParamIndices: [0]
                })], LayerExports, "dense", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Basic",
                    namespace: "layers",
                    useDocsFrom: "Dropout",
                    configParamIndices: [0]
                })], LayerExports, "dropout", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Basic",
                    namespace: "layers",
                    useDocsFrom: "Flatten",
                    configParamIndices: [0]
                })], LayerExports, "flatten", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Basic",
                    namespace: "layers",
                    useDocsFrom: "RepeatVector",
                    configParamIndices: [0]
                })], LayerExports, "repeatVector", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Basic",
                    namespace: "layers",
                    useDocsFrom: "Reshape",
                    configParamIndices: [0]
                })], LayerExports, "reshape", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Basic",
                    namespace: "layers",
                    useDocsFrom: "Embedding",
                    configParamIndices: [0]
                })], LayerExports, "embedding", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Merge",
                    namespace: "layers",
                    useDocsFrom: "Add",
                    configParamIndices: [0]
                })], LayerExports, "add", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Merge",
                    namespace: "layers",
                    useDocsFrom: "Average",
                    configParamIndices: [0]
                })], LayerExports, "average", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Merge",
                    namespace: "layers",
                    useDocsFrom: "Concatenate",
                    configParamIndices: [0]
                })], LayerExports, "concatenate", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Merge",
                    namespace: "layers",
                    useDocsFrom: "Maximum",
                    configParamIndices: [0]
                })], LayerExports, "maximum", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Merge",
                    namespace: "layers",
                    useDocsFrom: "Minimum",
                    configParamIndices: [0]
                })], LayerExports, "minimum", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Merge",
                    namespace: "layers",
                    useDocsFrom: "Multiply",
                    configParamIndices: [0]
                })], LayerExports, "multiply", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Normalization",
                    namespace: "layers",
                    useDocsFrom: "BatchNormalization",
                    configParamIndices: [0]
                })], LayerExports, "batchNormalization", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Padding",
                    namespace: "layers",
                    useDocsFrom: "ZeroPadding2D",
                    configParamIndices: [0]
                })], LayerExports, "zeroPadding2d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Pooling",
                    namespace: "layers",
                    useDocsFrom: "AveragePooling1D",
                    configParamIndices: [0]
                })], LayerExports, "averagePooling1d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Pooling",
                    namespace: "layers",
                    useDocsFrom: "AveragePooling2D",
                    configParamIndices: [0]
                })], LayerExports, "averagePooling2d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Pooling",
                    namespace: "layers",
                    useDocsFrom: "GlobalAveragePooling1D",
                    configParamIndices: [0]
                })], LayerExports, "globalAveragePooling1d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Pooling",
                    namespace: "layers",
                    useDocsFrom: "GlobalAveragePooling2D",
                    configParamIndices: [0]
                })], LayerExports, "globalAveragePooling2d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Pooling",
                    namespace: "layers",
                    useDocsFrom: "GlobalMaxPooling1D",
                    configParamIndices: [0]
                })], LayerExports, "globalMaxPooling1d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Pooling",
                    namespace: "layers",
                    useDocsFrom: "GlobalMaxPooling2D",
                    configParamIndices: [0]
                })], LayerExports, "globalMaxPooling2d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Pooling",
                    namespace: "layers",
                    useDocsFrom: "MaxPooling1D",
                    configParamIndices: [0]
                })], LayerExports, "maxPooling1d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Pooling",
                    namespace: "layers",
                    useDocsFrom: "MaxPooling2D",
                    configParamIndices: [0]
                })], LayerExports, "maxPooling2d", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Recurrent",
                    namespace: "layers",
                    useDocsFrom: "GRU",
                    configParamIndices: [0]
                })], LayerExports, "gru", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Recurrent",
                    namespace: "layers",
                    useDocsFrom: "GRUCell",
                    configParamIndices: [0]
                })], LayerExports, "gruCell", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Recurrent",
                    namespace: "layers",
                    useDocsFrom: "LSTM",
                    configParamIndices: [0]
                })], LayerExports, "lstm", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Recurrent",
                    namespace: "layers",
                    useDocsFrom: "LSTMCell",
                    configParamIndices: [0]
                })], LayerExports, "lstmCell", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Recurrent",
                    namespace: "layers",
                    useDocsFrom: "SimpleRNN",
                    configParamIndices: [0]
                })], LayerExports, "simpleRNN", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Recurrent",
                    namespace: "layers",
                    useDocsFrom: "SimpleRNNCell",
                    configParamIndices: [0]
                })], LayerExports, "simpleRNNCell", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Recurrent",
                    namespace: "layers",
                    useDocsFrom: "RNN",
                    configParamIndices: [0]
                })], LayerExports, "rnn", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Recurrent",
                    namespace: "layers",
                    useDocsFrom: "RNN",
                    configParamIndices: [0]
                })], LayerExports, "stackedRNNCells", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Wrapper",
                    namespace: "layers",
                    useDocsFrom: "Bidirectional",
                    configParamIndices: [0]
                })], LayerExports, "bidirectional", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Layers",
                    subheading: "Wrapper",
                    namespace: "layers",
                    useDocsFrom: "TimeDistributed",
                    configParamIndices: [0]
                })], LayerExports, "timeDistributed", null);
                return LayerExports
            }();
            exports.LayerExports = LayerExports;
            var ConstraintExports = function () {
                function ConstraintExports() {
                }

                ConstraintExports.maxNorm = function (config) {
                    return new constraints_1.MaxNorm(config)
                };
                ConstraintExports.unitNorm = function (config) {
                    return new constraints_1.UnitNorm(config)
                };
                ConstraintExports.nonNeg = function () {
                    return new constraints_1.NonNeg
                };
                ConstraintExports.minMaxNorm = function (config) {
                    return new constraints_1.MinMaxNorm(config)
                };
                __decorate([tfjs_core_1.doc({
                    heading: "Constraints",
                    namespace: "constraints",
                    useDocsFrom: "MaxNorm",
                    configParamIndices: [0]
                })], ConstraintExports, "maxNorm", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Constraints",
                    namespace: "constraints",
                    useDocsFrom: "UnitNorm",
                    configParamIndices: [0]
                })], ConstraintExports, "unitNorm", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Constraints",
                    namespace: "constraints",
                    useDocsFrom: "NonNeg"
                })], ConstraintExports, "nonNeg", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Constraints",
                    namespace: "constraints",
                    useDocsFrom: "MinMaxNormConfig",
                    configParamIndices: [0]
                })], ConstraintExports, "minMaxNorm", null);
                return ConstraintExports
            }();
            exports.ConstraintExports = ConstraintExports;
            var InitializerExports = function () {
                function InitializerExports() {
                }

                InitializerExports.zeros = function () {
                    return new initializers_1.Zeros
                };
                InitializerExports.ones = function () {
                    return new initializers_1.Ones
                };
                InitializerExports.constant = function (config) {
                    return new initializers_1.Constant(config)
                };
                InitializerExports.randomUniform = function (config) {
                    return new initializers_1.RandomUniform(config)
                };
                InitializerExports.randomNormal = function (config) {
                    return new initializers_1.RandomNormal(config)
                };
                InitializerExports.truncatedNormal = function (config) {
                    return new initializers_1.TruncatedNormal(config)
                };
                InitializerExports.identity = function (config) {
                    return new initializers_1.Identity(config)
                };
                InitializerExports.varianceScaling = function (config) {
                    return new initializers_1.VarianceScaling(config)
                };
                InitializerExports.glorotUniform = function (config) {
                    return new initializers_1.GlorotUniform(config)
                };
                InitializerExports.glorotNormal = function (config) {
                    return new initializers_1.GlorotNormal(config)
                };
                InitializerExports.heNormal = function (config) {
                    return new initializers_1.HeNormal(config)
                };
                InitializerExports.leCunNormal = function (config) {
                    return new initializers_1.LeCunNormal(config)
                };
                InitializerExports.orthogonal = function (config) {
                    return new initializers_1.Orthogonal(config)
                };
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "Zeros"
                })], InitializerExports, "zeros", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "Ones"
                })], InitializerExports, "ones", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "Constant",
                    configParamIndices: [0]
                })], InitializerExports, "constant", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "RandomUniform",
                    configParamIndices: [0]
                })], InitializerExports, "randomUniform", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "RandomNormal",
                    configParamIndices: [0]
                })], InitializerExports, "randomNormal", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "TruncatedNormal",
                    configParamIndices: [0]
                })], InitializerExports, "truncatedNormal", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "Identity",
                    configParamIndices: [0]
                })], InitializerExports, "identity", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "VarianceScaling",
                    configParamIndices: [0]
                })], InitializerExports, "varianceScaling", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "GlorotUniform",
                    configParamIndices: [0]
                })], InitializerExports, "glorotUniform", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "GlorotNormal",
                    configParamIndices: [0]
                })], InitializerExports, "glorotNormal", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "HeNormal",
                    configParamIndices: [0]
                })], InitializerExports, "heNormal", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "LeCunNormal",
                    configParamIndices: [0]
                })], InitializerExports, "leCunNormal", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    namespace: "initializers",
                    useDocsFrom: "Orthogonal",
                    configParamIndices: [0]
                })], InitializerExports, "orthogonal", null);
                return InitializerExports
            }();
            exports.InitializerExports = InitializerExports;
            var MetricExports = function () {
                function MetricExports() {
                }

                MetricExports.binaryAccuracy = function (yTrue, yPred) {
                    return metrics_1.binaryAccuracy(yTrue, yPred)
                };
                MetricExports.binaryCrossentropy = function (yTrue, yPred) {
                    return metrics_1.binaryCrossentropy(yTrue, yPred)
                };
                MetricExports.categoricalAccuracy = function (yTrue, yPred) {
                    return metrics_1.categoricalAccuracy(yTrue, yPred)
                };
                MetricExports.categoricalCrossentropy = function (yTrue, yPred) {
                    return losses_1.categoricalCrossentropy(yTrue, yPred)
                };
                MetricExports.cosineProximity = function (yTrue, yPred) {
                    return losses_1.cosineProximity(yTrue, yPred)
                };
                MetricExports.prototype.meanAbsoluteError = function (yTrue, yPred) {
                    return losses_1.meanAbsoluteError(yTrue, yPred)
                };
                MetricExports.prototype.meanAbsolutePercentageError = function (yTrue, yPred) {
                    return losses_1.meanAbsolutePercentageError(yTrue, yPred)
                };
                MetricExports.prototype.MAPE = function (yTrue, yPred) {
                    return losses_1.meanAbsolutePercentageError(yTrue, yPred)
                };
                MetricExports.prototype.mape = function (yTrue, yPred) {
                    return losses_1.meanAbsolutePercentageError(yTrue, yPred)
                };
                MetricExports.meanSquaredError = function (yTrue, yPred) {
                    return losses_1.meanSquaredError(yTrue, yPred)
                };
                MetricExports.MSE = function (yTrue, yPred) {
                    return losses_1.meanSquaredError(yTrue, yPred)
                };
                MetricExports.mse = function (yTrue, yPred) {
                    return losses_1.meanSquaredError(yTrue, yPred)
                };
                __decorate([tfjs_core_1.doc({
                    heading: "Metrics",
                    namespace: "metrics",
                    useDocsFrom: "meanAbsoluteError"
                })], MetricExports.prototype, "meanAbsoluteError", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Metrics",
                    namespace: "metrics",
                    useDocsFrom: "meanAbsolutePercentageError"
                })], MetricExports.prototype, "meanAbsolutePercentageError", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Metrics",
                    namespace: "metrics",
                    useDocsFrom: "binaryAccuracy"
                })], MetricExports, "binaryAccuracy", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Metrics",
                    namespace: "metrics",
                    useDocsFrom: "binaryCrossentropy"
                })], MetricExports, "binaryCrossentropy", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Metrics",
                    namespace: "metrics",
                    useDocsFrom: "categoricalAccuracy"
                })], MetricExports, "categoricalAccuracy", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Metrics",
                    namespace: "metrics",
                    useDocsFrom: "categoricalCrossentropy"
                })], MetricExports, "categoricalCrossentropy", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Metrics",
                    namespace: "metrics",
                    useDocsFrom: "cosineProximity"
                })], MetricExports, "cosineProximity", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Metrics",
                    namespace: "metrics",
                    useDocsFrom: "meanSquaredError"
                })], MetricExports, "meanSquaredError", null);
                return MetricExports
            }();
            exports.MetricExports = MetricExports;
            var RegularizerExports = function () {
                function RegularizerExports() {
                }

                RegularizerExports.l1l2 = function (config) {
                    return new regularizers_1.L1L2(config)
                };
                RegularizerExports.l1 = function (config) {
                    return regularizers_1.l1(config)
                };
                RegularizerExports.l2 = function (config) {
                    return regularizers_1.l2(config)
                };
                __decorate([tfjs_core_1.doc({
                    heading: "Regularizers",
                    namespace: "regularizers",
                    useDocsFrom: "L1L2"
                })], RegularizerExports, "l1l2", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Regularizers",
                    namespace: "regularizers",
                    useDocsFrom: "L1L2"
                })], RegularizerExports, "l1", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Regularizers",
                    namespace: "regularizers",
                    useDocsFrom: "L1L2"
                })], RegularizerExports, "l2", null);
                return RegularizerExports
            }();
            exports.RegularizerExports = RegularizerExports
        }, {
            "./constraints": 161,
            "./engine/topology": 163,
            "./engine/training": 164,
            "./initializers": 168,
            "./layers/advanced_activations": 169,
            "./layers/convolutional": 170,
            "./layers/convolutional_depthwise": 171,
            "./layers/core": 172,
            "./layers/embeddings": 173,
            "./layers/merge": 174,
            "./layers/normalization": 175,
            "./layers/padding": 176,
            "./layers/pooling": 177,
            "./layers/recurrent": 178,
            "./layers/wrappers": 180,
            "./losses": 181,
            "./metrics": 182,
            "./models": 183,
            "./regularizers": 185,
            "@tensorflow/tfjs-core": 50
        }],
        167: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var exports_1 = require("./exports");
            var callbacks_1 = require("./callbacks");
            exports.Callback = callbacks_1.Callback;
            exports.CallbackList = callbacks_1.CallbackList;
            exports.CustomCallback = callbacks_1.CustomCallback;
            var training_1 = require("./engine/training");
            exports.Model = training_1.Model;
            var recurrent_1 = require("./layers/recurrent");
            exports.RNN = recurrent_1.RNN;
            var models_1 = require("./models");
            exports.Sequential = models_1.Sequential;
            var types_1 = require("./types");
            exports.SymbolicTensor = types_1.SymbolicTensor;
            var version_1 = require("./version");
            exports.version_layers = version_1.version;
            exports.model = exports_1.ModelExports.model;
            exports.sequential = exports_1.ModelExports.sequential;
            exports.loadModel = exports_1.ModelExports.loadModel;
            exports.input = exports_1.ModelExports.input;
            exports.layers = exports_1.LayerExports;
            exports.constraints = exports_1.ConstraintExports;
            exports.initializers = exports_1.InitializerExports;
            exports.metrics = exports_1.MetricExports;
            exports.regularizers = exports_1.RegularizerExports
        }, {
            "./callbacks": 159,
            "./engine/training": 164,
            "./exports": 166,
            "./layers/recurrent": 178,
            "./models": 183,
            "./types": 186,
            "./version": 192
        }],
        168: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var common_1 = require("./common");
            var errors_1 = require("./errors");
            var generic_utils_1 = require("./utils/generic_utils");
            var math_utils_1 = require("./utils/math_utils");
            exports.VALID_FAN_MODE_VALUES = ["fanIn", "fanOut", "fanAvg"];

            function checkFanMode(value) {
                generic_utils_1.checkStringTypeUnionValue(exports.VALID_FAN_MODE_VALUES, "FanMode", value)
            }

            exports.checkFanMode = checkFanMode;
            exports.VALID_DISTRIBUTION_VALUES = ["normal", "uniform"];

            function checkDistribution(value) {
                generic_utils_1.checkStringTypeUnionValue(exports.VALID_DISTRIBUTION_VALUES, "Distribution", value)
            }

            exports.checkDistribution = checkDistribution;
            var Initializer = function (_super) {
                __extends(Initializer, _super);

                function Initializer() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Initializer.prototype.fromConfigUsesCustomObjects = function () {
                    return false
                };
                Initializer.prototype.getConfig = function () {
                    return {}
                };
                Initializer = __decorate([tfjs_core_1.doc({
                    heading: "Initializers",
                    subheading: "Classes",
                    namespace: "initializers"
                })], Initializer);
                return Initializer
            }(tfjs_core_1.serialization.Serializable);
            exports.Initializer = Initializer;
            var Zeros = function (_super) {
                __extends(Zeros, _super);

                function Zeros() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Zeros.prototype.apply = function (shape, dtype) {
                    return tfjs_core_1.zeros(shape, dtype)
                };
                Zeros.className = "Zeros";
                return Zeros
            }(Initializer);
            exports.Zeros = Zeros;
            tfjs_core_1.serialization.SerializationMap.register(Zeros);
            var Ones = function (_super) {
                __extends(Ones, _super);

                function Ones() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                Ones.prototype.apply = function (shape, dtype) {
                    return tfjs_core_1.ones(shape, dtype)
                };
                Ones.className = "Ones";
                return Ones
            }(Initializer);
            exports.Ones = Ones;
            tfjs_core_1.serialization.SerializationMap.register(Ones);
            var Constant = function (_super) {
                __extends(Constant, _super);

                function Constant(config) {
                    var _this = _super.call(this) || this;
                    _this.value = config.value;
                    return _this
                }

                Constant.prototype.apply = function (shape, dtype) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        return K.scalarTimesArray(tfjs_core_1.scalar(_this.value), tfjs_core_1.ones(shape, dtype))
                    })
                };
                Constant.prototype.getConfig = function () {
                    return {value: this.value}
                };
                Constant.className = "Constant";
                return Constant
            }(Initializer);
            exports.Constant = Constant;
            tfjs_core_1.serialization.SerializationMap.register(Constant);
            var RandomUniform = function (_super) {
                __extends(RandomUniform, _super);

                function RandomUniform(config) {
                    var _this = _super.call(this) || this;
                    _this.DEFAULT_MINVAL = -.05;
                    _this.DEFAULT_MAXVAL = .05;
                    _this.minval = config.minval || _this.DEFAULT_MINVAL;
                    _this.maxval = config.maxval || _this.DEFAULT_MAXVAL;
                    _this.seed = config.seed;
                    return _this
                }

                RandomUniform.prototype.apply = function (shape, dtype) {
                    return tfjs_core_1.randomUniform(shape, this.minval, this.maxval, dtype)
                };
                RandomUniform.prototype.getConfig = function () {
                    return {minval: this.minval, maxval: this.maxval, seed: this.seed}
                };
                RandomUniform.className = "RandomUniform";
                return RandomUniform
            }(Initializer);
            exports.RandomUniform = RandomUniform;
            tfjs_core_1.serialization.SerializationMap.register(RandomUniform);
            var RandomNormal = function (_super) {
                __extends(RandomNormal, _super);

                function RandomNormal(config) {
                    var _this = _super.call(this) || this;
                    _this.DEFAULT_MEAN = 0;
                    _this.DEFAULT_STDDEV = .05;
                    _this.mean = config.mean || _this.DEFAULT_MEAN;
                    _this.stddev = config.stddev || _this.DEFAULT_STDDEV;
                    _this.seed = config.seed;
                    return _this
                }

                RandomNormal.prototype.apply = function (shape, dtype) {
                    if (dtype === "bool") {
                        throw new errors_1.NotImplementedError("randomNormal does not support dType bool.")
                    }
                    return K.randomNormal(shape, this.mean, this.stddev, dtype, this.seed)
                };
                RandomNormal.prototype.getConfig = function () {
                    return {mean: this.mean, stddev: this.stddev, seed: this.seed}
                };
                RandomNormal.className = "RandomNormal";
                return RandomNormal
            }(Initializer);
            exports.RandomNormal = RandomNormal;
            tfjs_core_1.serialization.SerializationMap.register(RandomNormal);
            var TruncatedNormal = function (_super) {
                __extends(TruncatedNormal, _super);

                function TruncatedNormal(config) {
                    var _this = _super.call(this) || this;
                    _this.DEFAULT_MEAN = 0;
                    _this.DEFAULT_STDDEV = .05;
                    _this.mean = config.mean || _this.DEFAULT_MEAN;
                    _this.stddev = config.stddev || _this.DEFAULT_STDDEV;
                    _this.seed = config.seed;
                    return _this
                }

                TruncatedNormal.prototype.apply = function (shape, dtype) {
                    if (dtype === "bool") {
                        throw new errors_1.NotImplementedError("truncatedNormal does not support dType bool.")
                    }
                    return tfjs_core_1.truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed)
                };
                TruncatedNormal.prototype.getConfig = function () {
                    return {mean: this.mean, stddev: this.stddev, seed: this.seed}
                };
                TruncatedNormal.className = "TruncatedNormal";
                return TruncatedNormal
            }(Initializer);
            exports.TruncatedNormal = TruncatedNormal;
            tfjs_core_1.serialization.SerializationMap.register(TruncatedNormal);
            var Identity = function (_super) {
                __extends(Identity, _super);

                function Identity(config) {
                    var _this = _super.call(this) || this;
                    _this.gain = config.gain != null ? tfjs_core_1.scalar(config.gain) : K.getScalar(1);
                    return _this
                }

                Identity.prototype.apply = function (shape, dtype) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        if (shape.length !== 2 || shape[0] !== shape[1]) {
                            throw new errors_1.ValueError("Identity matrix initializer can only be used for" + " 2D square matrices.")
                        } else {
                            return K.scalarTimesArray(_this.gain, tfjs_core_1.eye(shape[0]))
                        }
                    })
                };
                Identity.prototype.getConfig = function () {
                    return {gain: this.gain.get()}
                };
                Identity.className = "Identity";
                return Identity
            }(Initializer);
            exports.Identity = Identity;
            tfjs_core_1.serialization.SerializationMap.register(Identity);

            function computeFans(shape, dataFormat) {
                if (dataFormat === void 0) {
                    dataFormat = "channelsLast"
                }
                var fanIn;
                var fanOut;
                common_1.checkDataFormat(dataFormat);
                if (shape.length === 2) {
                    fanIn = shape[0];
                    fanOut = shape[1]
                } else if ([3, 4, 5].indexOf(shape.length) !== -1) {
                    if (dataFormat === "channelsFirst") {
                        var receptiveFieldSize = math_utils_1.arrayProd(shape, 2);
                        fanIn = shape[1] * receptiveFieldSize;
                        fanOut = shape[0] * receptiveFieldSize
                    } else if (dataFormat === "channelsLast") {
                        var receptiveFieldSize = math_utils_1.arrayProd(shape, 0, shape.length - 2);
                        fanIn = shape[shape.length - 2] * receptiveFieldSize;
                        fanOut = shape[shape.length - 1] * receptiveFieldSize
                    }
                } else {
                    var shapeProd = math_utils_1.arrayProd(shape);
                    fanIn = Math.sqrt(shapeProd);
                    fanOut = Math.sqrt(shapeProd)
                }
                return [fanIn, fanOut]
            }

            var VarianceScaling = function (_super) {
                __extends(VarianceScaling, _super);

                function VarianceScaling(config) {
                    var _this = _super.call(this) || this;
                    if (config.scale < 0) {
                        throw new errors_1.ValueError("scale must be a positive float. Got: " + config.scale)
                    }
                    _this.scale = config.scale == null ? 1 : config.scale;
                    _this.mode = config.mode;
                    checkFanMode(_this.mode);
                    _this.distribution = config.distribution;
                    checkDistribution(_this.distribution);
                    _this.seed = config.seed;
                    return _this
                }

                VarianceScaling.prototype.apply = function (shape, dtype) {
                    var fans = computeFans(shape);
                    var fanIn = fans[0];
                    var fanOut = fans[1];
                    var scale = this.scale;
                    if (this.mode === "fanIn") {
                        scale /= Math.max(1, fanIn)
                    } else if (this.mode === "fanOut") {
                        scale /= Math.max(1, fanOut)
                    } else {
                        scale /= Math.max(1, (fanIn + fanOut) / 2)
                    }
                    if (this.distribution === "normal") {
                        var stddev = Math.sqrt(scale);
                        if (dtype === "bool") {
                            throw new errors_1.NotImplementedError(this.getClassName() + " does not support dType bool.")
                        }
                        return tfjs_core_1.truncatedNormal(shape, 0, stddev, dtype, this.seed)
                    } else {
                        var limit = Math.sqrt(3 * scale);
                        return tfjs_core_1.randomUniform(shape, -limit, limit, dtype)
                    }
                };
                VarianceScaling.prototype.getConfig = function () {
                    return {scale: this.scale, mode: this.mode, distribution: this.distribution, seed: this.seed}
                };
                VarianceScaling.className = "VarianceScaling";
                return VarianceScaling
            }(Initializer);
            exports.VarianceScaling = VarianceScaling;
            tfjs_core_1.serialization.SerializationMap.register(VarianceScaling);
            var GlorotUniform = function (_super) {
                __extends(GlorotUniform, _super);

                function GlorotUniform(config) {
                    return _super.call(this, {
                        scale: 1,
                        mode: "fanAvg",
                        distribution: "uniform",
                        seed: config == null ? null : config.seed
                    }) || this
                }

                GlorotUniform.prototype.getClassName = function () {
                    return VarianceScaling.className
                };
                return GlorotUniform
            }(VarianceScaling);
            exports.GlorotUniform = GlorotUniform;
            var GlorotNormal = function (_super) {
                __extends(GlorotNormal, _super);

                function GlorotNormal(config) {
                    return _super.call(this, {
                        scale: 1,
                        mode: "fanAvg",
                        distribution: "normal",
                        seed: config == null ? null : config.seed
                    }) || this
                }

                GlorotNormal.prototype.getClassName = function () {
                    return VarianceScaling.className
                };
                return GlorotNormal
            }(VarianceScaling);
            exports.GlorotNormal = GlorotNormal;
            var HeNormal = function (_super) {
                __extends(HeNormal, _super);

                function HeNormal(config) {
                    return _super.call(this, {
                        scale: 2,
                        mode: "fanIn",
                        distribution: "normal",
                        seed: config == null ? null : config.seed
                    }) || this
                }

                HeNormal.prototype.getClassName = function () {
                    return VarianceScaling.className
                };
                return HeNormal
            }(VarianceScaling);
            exports.HeNormal = HeNormal;
            var LeCunNormal = function (_super) {
                __extends(LeCunNormal, _super);

                function LeCunNormal(config) {
                    return _super.call(this, {
                        scale: 1,
                        mode: "fanIn",
                        distribution: "normal",
                        seed: config == null ? null : config.seed
                    }) || this
                }

                LeCunNormal.prototype.getClassName = function () {
                    return VarianceScaling.className
                };
                return LeCunNormal
            }(VarianceScaling);
            exports.LeCunNormal = LeCunNormal;
            var Orthogonal = function (_super) {
                __extends(Orthogonal, _super);

                function Orthogonal(config) {
                    var _this = _super.call(this) || this;
                    _this.DEFAULT_GAIN = 1;
                    _this.gain = config.gain == null ? _this.DEFAULT_GAIN : config.gain;
                    _this.seed = config.seed;
                    if (_this.seed != null) {
                        throw new errors_1.NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.")
                    }
                    return _this
                }

                Orthogonal.prototype.apply = function (shape, dtype) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        if (shape.length !== 2) {
                            throw new errors_1.NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.")
                        }
                        if (shape[0] * shape[1] > 2e3) {
                            console.warn("Orthogonal initializer is being called on a matrix with more " + ("than 2000 (" + shape[0] * shape[1] + ") elements: ") + "Slowness may result.")
                        }
                        var normalizedShape = shape[0] > shape[1] ? [shape[1], shape[0]] : shape;
                        var a = K.randomNormal(normalizedShape, 0, 1, "float32");
                        var q = tfjs_core_1.linalg.gramSchmidt(a);
                        if (shape[0] > shape[1]) {
                            q = q.transpose()
                        }
                        return K.scalarTimesArray(K.getScalar(_this.gain), q)
                    })
                };
                Orthogonal.prototype.getConfig = function () {
                    return {gain: this.gain, seed: this.seed}
                };
                Orthogonal.className = "Orthogonal";
                return Orthogonal
            }(Initializer);
            exports.Orthogonal = Orthogonal;
            tfjs_core_1.serialization.SerializationMap.register(Orthogonal);
            exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
                constant: "Constant",
                glorotNormal: "GlorotNormal",
                glorotUniform: "GlorotUniform",
                heNormal: "HeNormal",
                identity: "Identity",
                leCunNormal: "LeCunNormal",
                ones: "Ones",
                orthogonal: "Orthogonal",
                randomNormal: "RandomNormal",
                randomUniform: "RandomUniform",
                truncatedNormal: "TruncatedNormal",
                varianceScaling: "VarianceScaling",
                zeros: "Zeros"
            };

            function deserializeInitializer(config, customObjects) {
                if (customObjects === void 0) {
                    customObjects = {}
                }
                return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, "initializer")
            }

            function serializeInitializer(initializer) {
                return generic_utils_1.serializeKerasObject(initializer)
            }

            exports.serializeInitializer = serializeInitializer;

            function getInitializer(identifier) {
                if (typeof identifier === "string") {
                    var className = identifier in exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
                    if (className === "GlorotUniform") {
                        return new GlorotUniform
                    } else if (className === "GlorotNormal") {
                        return new GlorotNormal
                    } else if (className === "HeNormal") {
                        return new HeNormal
                    } else if (className === "LeCunNormal") {
                        return new LeCunNormal
                    } else {
                        var config = {className: className, config: {}};
                        return deserializeInitializer(config)
                    }
                } else if (identifier instanceof Initializer) {
                    return identifier
                } else {
                    return deserializeInitializer(identifier)
                }
            }

            exports.getInitializer = getInitializer
        }, {
            "./backend/tfjs_backend": 158,
            "./common": 160,
            "./errors": 165,
            "./utils/generic_utils": 188,
            "./utils/math_utils": 189,
            "@tensorflow/tfjs-core": 50
        }],
        169: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var activations_1 = require("../activations");
            var tfjs_backend_1 = require("../backend/tfjs_backend");
            var tfjs_backend_2 = require("../backend/tfjs_backend");
            var topology_1 = require("../engine/topology");
            var errors_1 = require("../errors");
            var generic_utils = require("../utils/generic_utils");
            var LeakyReLU = function (_super) {
                __extends(LeakyReLU, _super);

                function LeakyReLU(config) {
                    var _this = _super.call(this, config == null ? {} : config) || this;
                    _this.DEFAULT_ALPHA = .3;
                    if (config == null) {
                        config = {}
                    }
                    _this.alpha = config.alpha == null ? _this.DEFAULT_ALPHA : config.alpha;
                    return _this
                }

                LeakyReLU.prototype.call = function (inputs, kwargs) {
                    var x = generic_utils.getExactlyOneTensor(inputs);
                    return tfjs_core_1.leakyRelu(x, this.alpha)
                };
                LeakyReLU.prototype.computeOutputShape = function (inputShape) {
                    return inputShape
                };
                LeakyReLU.prototype.getConfig = function () {
                    var config = {alpha: this.alpha};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                LeakyReLU.className = "LeakyReLU";
                return LeakyReLU
            }(topology_1.Layer);
            exports.LeakyReLU = LeakyReLU;
            tfjs_core_1.serialization.SerializationMap.register(LeakyReLU);
            var ELU = function (_super) {
                __extends(ELU, _super);

                function ELU(config) {
                    var _this = _super.call(this, config == null ? {} : config) || this;
                    _this.DEFAULT_ALPHA = 1;
                    if (config == null) {
                        config = {}
                    }
                    if (config.alpha != null && config.alpha !== _this.DEFAULT_ALPHA) {
                        throw new errors_1.NotImplementedError("Non-default alpha value (" + config.alpha + ") is not supported by the " + "ELU layer yet.")
                    }
                    _this.alpha = config.alpha == null ? _this.DEFAULT_ALPHA : config.alpha;
                    return _this
                }

                ELU.prototype.call = function (inputs, kwargs) {
                    var x = generic_utils.getExactlyOneTensor(inputs);
                    return tfjs_core_1.elu(x)
                };
                ELU.prototype.computeOutputShape = function (inputShape) {
                    return inputShape
                };
                ELU.prototype.getConfig = function () {
                    var config = {alpha: this.alpha};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                ELU.className = "ELU";
                return ELU
            }(topology_1.Layer);
            exports.ELU = ELU;
            tfjs_core_1.serialization.SerializationMap.register(ELU);
            var ThresholdedReLU = function (_super) {
                __extends(ThresholdedReLU, _super);

                function ThresholdedReLU(config) {
                    var _this = _super.call(this, config == null ? {} : config) || this;
                    _this.DEFAULT_THETA = 1;
                    if (config == null) {
                        config = {}
                    }
                    _this.theta = config.theta == null ? _this.DEFAULT_THETA : config.theta;
                    _this.thetaTensor = tfjs_backend_2.getScalar(_this.theta);
                    return _this
                }

                ThresholdedReLU.prototype.call = function (inputs, kwargs) {
                    var x = generic_utils.getExactlyOneTensor(inputs);
                    return x.mul(tfjs_backend_1.cast(x.greater(this.thetaTensor), "float32"))
                };
                ThresholdedReLU.prototype.computeOutputShape = function (inputShape) {
                    return inputShape
                };
                ThresholdedReLU.prototype.getConfig = function () {
                    var config = {theta: this.theta};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                ThresholdedReLU.className = "ThresholdedReLU";
                return ThresholdedReLU
            }(topology_1.Layer);
            exports.ThresholdedReLU = ThresholdedReLU;
            tfjs_core_1.serialization.SerializationMap.register(ThresholdedReLU);
            var Softmax = function (_super) {
                __extends(Softmax, _super);

                function Softmax(config) {
                    var _this = _super.call(this, config == null ? {} : config) || this;
                    _this.DEFAULT_AXIS = 1;
                    if (config == null) {
                        config = {}
                    }
                    _this.softmax = (new activations_1.Softmax).apply;
                    _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;
                    return _this
                }

                Softmax.prototype.call = function (inputs, kwargs) {
                    var x = generic_utils.getExactlyOneTensor(inputs);
                    return this.softmax(x, this.axis)
                };
                Softmax.prototype.computeOutputShape = function (inputShape) {
                    return inputShape
                };
                Softmax.prototype.getConfig = function () {
                    var config = {axis: this.axis};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Softmax.className = "Softmax";
                return Softmax
            }(topology_1.Layer);
            exports.Softmax = Softmax;
            tfjs_core_1.serialization.SerializationMap.register(Softmax)
        }, {
            "../activations": 156,
            "../backend/tfjs_backend": 158,
            "../engine/topology": 163,
            "../errors": 165,
            "../utils/generic_utils": 188,
            "@tensorflow/tfjs-core": 50
        }],
        170: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var activations_1 = require("../activations");
            var common_1 = require("../backend/common");
            var K = require("../backend/tfjs_backend");
            var common_2 = require("../common");
            var constraints_1 = require("../constraints");
            var topology_1 = require("../engine/topology");
            var errors_1 = require("../errors");
            var initializers_1 = require("../initializers");
            var regularizers_1 = require("../regularizers");
            var conv_utils_1 = require("../utils/conv_utils");
            var generic_utils = require("../utils/generic_utils");

            function preprocessConv2DInput(x, dataFormat) {
                return tfjs_core_1.tidy(function () {
                    common_2.checkDataFormat(dataFormat);
                    if (dataFormat === "channelsFirst") {
                        return tfc.transpose(x, [0, 2, 3, 1])
                    } else {
                        return x
                    }
                })
            }

            exports.preprocessConv2DInput = preprocessConv2DInput;

            function conv1dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {
                if (strides === void 0) {
                    strides = 1
                }
                if (padding === void 0) {
                    padding = "valid"
                }
                if (dilationRate === void 0) {
                    dilationRate = 1
                }
                return tfjs_core_1.tidy(function () {
                    if (dataFormat == null) {
                        dataFormat = common_1.imageDataFormat()
                    }
                    common_2.checkDataFormat(dataFormat);
                    if (x.shape.length !== 3) {
                        throw new errors_1.ValueError("The input of a conv1dWithBias operation should be 3, but is " + (x.shape.length + " instead."))
                    }
                    if (kernel.shape.length !== 3) {
                        throw new errors_1.ValueError("The kernel for a conv1dWithBias operation should be 3, but is " + (kernel.shape.length + " instead"))
                    }
                    if (bias != null && bias.shape.length !== 1) {
                        throw new errors_1.ValueError("The bias for a conv1dWithBias operation should be 1, but is " + (kernel.shape.length + " instead"))
                    }
                    if (dataFormat === "channelsFirst") {
                        x = tfc.transpose(x, [0, 2, 1])
                    }
                    if (padding === "causal") {
                        throw new errors_1.NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not " + "implemented yet.")
                    }
                    var y = tfc.conv1d(x, kernel, strides, padding === "same" ? "same" : "valid", "NWC", dilationRate);
                    if (bias != null) {
                        y = K.biasAdd(y, bias)
                    }
                    return y
                })
            }

            exports.conv1dWithBias = conv1dWithBias;

            function conv1d(x, kernel, strides, padding, dataFormat, dilationRate) {
                if (strides === void 0) {
                    strides = 1
                }
                if (padding === void 0) {
                    padding = "valid"
                }
                if (dilationRate === void 0) {
                    dilationRate = 1
                }
                return tfjs_core_1.tidy(function () {
                    common_2.checkDataFormat(dataFormat);
                    return conv1dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate)
                })
            }

            exports.conv1d = conv1d;

            function conv2d(x, kernel, strides, padding, dataFormat, dilationRate) {
                if (strides === void 0) {
                    strides = [1, 1]
                }
                if (padding === void 0) {
                    padding = "valid"
                }
                return tfjs_core_1.tidy(function () {
                    common_2.checkDataFormat(dataFormat);
                    return conv2dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate)
                })
            }

            exports.conv2d = conv2d;

            function conv2dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {
                if (strides === void 0) {
                    strides = [1, 1]
                }
                if (padding === void 0) {
                    padding = "valid"
                }
                return tfjs_core_1.tidy(function () {
                    if (dataFormat == null) {
                        dataFormat = common_1.imageDataFormat()
                    }
                    common_2.checkDataFormat(dataFormat);
                    if (x.rank !== 3 && x.rank !== 4) {
                        throw new errors_1.ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received " + (x.rank + "."))
                    }
                    if (kernel.rank !== 3 && kernel.rank !== 4) {
                        throw new errors_1.ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received " + (x.rank + "."))
                    }
                    var y = preprocessConv2DInput(x, dataFormat);
                    if (padding === "causal") {
                        throw new errors_1.NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not " + "implemented yet.")
                    }
                    y = tfc.conv2d(y, kernel, strides, padding === "same" ? "same" : "valid", "NHWC", dilationRate);
                    if (bias != null) {
                        y = K.biasAdd(y, bias)
                    }
                    if (dataFormat === "channelsFirst") {
                        y = tfc.transpose(y, [0, 3, 1, 2])
                    }
                    return y
                })
            }

            exports.conv2dWithBias = conv2dWithBias;
            var Conv = function (_super) {
                __extends(Conv, _super);

                function Conv(rank, config) {
                    var _this = _super.call(this, config) || this;
                    _this.kernel = null;
                    _this.bias = null;
                    _this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
                    _this.DEFAULT_BIAS_INITIALIZER = "zeros";
                    _this.rank = rank;
                    if (_this.rank !== 1 && _this.rank !== 2) {
                        throw new errors_1.NotImplementedError("Convolution layer for rank other than 1 or 2 (" + _this.rank + ") is " + "not implemented yet.")
                    }
                    _this.filters = config.filters;
                    _this.kernelSize = conv_utils_1.normalizeArray(config.kernelSize, rank, "kernelSize");
                    _this.strides = conv_utils_1.normalizeArray(config.strides == null ? 1 : config.strides, rank, "strides");
                    _this.padding = config.padding == null ? "valid" : config.padding;
                    common_2.checkPaddingMode(_this.padding);
                    _this.dataFormat = config.dataFormat == null ? "channelsLast" : config.dataFormat;
                    common_2.checkDataFormat(_this.dataFormat);
                    _this.dilationRate = config.dilationRate == null ? 1 : config.dilationRate;
                    if (_this.rank === 1 && (Array.isArray(_this.dilationRate) && _this.dilationRate.length !== 1)) {
                        throw new errors_1.ValueError("dilationRate must be a number or an array of a single number " + "for 1D convolution, but received " + ("" + JSON.stringify(_this.dilationRate)))
                    }
                    if (_this.rank === 2) {
                        if (typeof _this.dilationRate === "number") {
                            _this.dilationRate = [_this.dilationRate, _this.dilationRate]
                        } else if (_this.dilationRate.length !== 2) {
                            throw new errors_1.ValueError("dilationRate must be a number or array of two numbers for 2D " + ("convolution, but received " + JSON.stringify(_this.dilationRate)))
                        }
                    }
                    _this.activation = activations_1.getActivation(config.activation);
                    _this.useBias = config.useBias == null ? true : config.useBias;
                    _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
                    _this.biasInitializer = initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
                    _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
                    _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
                    _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
                    _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
                    _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
                    return _this
                }

                Conv.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
                    if (inputShape[channelAxis] == null) {
                        throw new errors_1.ValueError("The channel dimension of the input should be defined. " + ("Found " + inputShape[channelAxis]))
                    }
                    var inputDim = inputShape[channelAxis];
                    var kernelShape = this.kernelSize.concat([inputDim, this.filters]);
                    this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
                    if (this.useBias) {
                        this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)
                    }
                    this.inputSpec = [{ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a)}];
                    this.built = true;
                    var _a
                };
                Conv.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = generic_utils.getExactlyOneTensor(inputs);
                        var outputs;
                        var biasValue = _this.bias == null ? null : _this.bias.read();
                        if (_this.rank === 1) {
                            outputs = conv1dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides[0], _this.padding, _this.dataFormat, _this.dilationRate)
                        } else if (_this.rank === 2) {
                            outputs = conv2dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides, _this.padding, _this.dataFormat, _this.dilationRate)
                        } else if (_this.rank === 3) {
                            throw new errors_1.NotImplementedError("3D convolution is not implemented yet.")
                        }
                        if (_this.activation != null) {
                            outputs = _this.activation.apply(outputs)
                        }
                        return outputs
                    })
                };
                Conv.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var newSpace = [];
                    var space = this.dataFormat === "channelsLast" ? inputShape.slice(1, inputShape.length - 1) : inputShape.slice(2);
                    for (var i = 0; i < space.length; ++i) {
                        var newDim = conv_utils_1.convOutputLength(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === "number" ? this.dilationRate : this.dilationRate[i]);
                        newSpace.push(newDim)
                    }
                    var outputShape = [inputShape[0]];
                    if (this.dataFormat === "channelsLast") {
                        outputShape = outputShape.concat(newSpace);
                        outputShape.push(this.filters)
                    } else {
                        outputShape.push(this.filters);
                        outputShape = outputShape.concat(newSpace)
                    }
                    return outputShape
                };
                Conv.prototype.getConfig = function () {
                    var config = {
                        rank: this.rank,
                        filters: this.filters,
                        kernelSize: this.kernelSize,
                        strides: this.strides,
                        padding: this.padding,
                        dataFormat: this.dataFormat,
                        dilationRate: this.dilationRate,
                        activation: activations_1.serializeActivation(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
                        biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
                        kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
                        biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
                        biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                return Conv
            }(topology_1.Layer);
            exports.Conv = Conv;
            var Conv2D = function (_super) {
                __extends(Conv2D, _super);

                function Conv2D(config) {
                    return _super.call(this, 2, config) || this
                }

                Conv2D.prototype.getConfig = function () {
                    var config = _super.prototype.getConfig.call(this);
                    delete config["rank"];
                    return config
                };
                Conv2D.className = "Conv2D";
                return Conv2D
            }(Conv);
            exports.Conv2D = Conv2D;
            tfjs_core_1.serialization.SerializationMap.register(Conv2D);
            var Conv2DTranspose = function (_super) {
                __extends(Conv2DTranspose, _super);

                function Conv2DTranspose(config) {
                    var _this = _super.call(this, config) || this;
                    _this.inputSpec = [new topology_1.InputSpec({ndim: 4})];
                    if (_this.padding !== "same" && _this.padding !== "valid") {
                        throw new errors_1.ValueError("Conv2DTranspose currently supports only padding modes 'same' " + ("and 'valid', but received padding mode " + _this.padding))
                    }
                    return _this
                }

                Conv2DTranspose.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    if (inputShape.length !== 4) {
                        throw new errors_1.ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(inputShape))
                    }
                    var channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
                    if (inputShape[channelAxis] == null) {
                        throw new errors_1.ValueError("The channel dimension of the inputs should be defined. " + "Found `None`.")
                    }
                    var inputDim = inputShape[channelAxis];
                    var kernelShape = this.kernelSize.concat([this.filters, inputDim]);
                    this.kernel = this.addWeight("kernel", kernelShape, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
                    if (this.useBias) {
                        this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)
                    }
                    this.inputSpec = [new topology_1.InputSpec({
                        ndim: 4,
                        axes: (_a = {}, _a[channelAxis] = inputDim, _a)
                    })];
                    this.built = true;
                    var _a
                };
                Conv2DTranspose.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfc.tidy(function () {
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        if (input.shape.length !== 4) {
                            throw new errors_1.ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but " + ("received a tensor of rank-" + input.shape.length))
                        }
                        var inputShape = input.shape;
                        var batchSize = inputShape[0];
                        var hAxis;
                        var wAxis;
                        if (_this.dataFormat === "channelsFirst") {
                            hAxis = 2;
                            wAxis = 3
                        } else {
                            hAxis = 1;
                            wAxis = 2
                        }
                        var height = inputShape[hAxis];
                        var width = inputShape[wAxis];
                        var kernelH = _this.kernelSize[0];
                        var kernelW = _this.kernelSize[1];
                        var strideH = _this.strides[0];
                        var strideW = _this.strides[1];
                        var outHeight = conv_utils_1.deconvLength(height, strideH, kernelH, _this.padding);
                        var outWidth = conv_utils_1.deconvLength(width, strideW, kernelW, _this.padding);
                        var outputShape = [batchSize, outHeight, outWidth, _this.filters];
                        if (_this.dataFormat !== "channelsLast") {
                            input = tfc.transpose(input, [0, 2, 3, 1])
                        }
                        var outputs = tfc.conv2dTranspose(input, _this.kernel.read(), outputShape, _this.strides, _this.padding);
                        if (_this.dataFormat !== "channelsLast") {
                            outputs = tfc.transpose(outputs, [0, 3, 1, 2])
                        }
                        if (_this.bias != null) {
                            outputs = K.biasAdd(outputs, _this.bias.read(), _this.dataFormat)
                        }
                        if (_this.activation != null) {
                            outputs = _this.activation.apply(outputs)
                        }
                        return outputs
                    })
                };
                Conv2DTranspose.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var outputShape = inputShape.slice();
                    var channelAxis;
                    var heightAxis;
                    var widthAxis;
                    if (this.dataFormat === "channelsFirst") {
                        channelAxis = 1;
                        heightAxis = 2;
                        widthAxis = 3
                    } else {
                        channelAxis = 3;
                        heightAxis = 1;
                        widthAxis = 2
                    }
                    var kernelH = this.kernelSize[0];
                    var kernelW = this.kernelSize[1];
                    var strideH = this.strides[0];
                    var strideW = this.strides[1];
                    outputShape[channelAxis] = this.filters;
                    outputShape[heightAxis] = conv_utils_1.deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
                    outputShape[widthAxis] = conv_utils_1.deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
                    return outputShape
                };
                Conv2DTranspose.prototype.getConfig = function () {
                    var config = _super.prototype.getConfig.call(this);
                    delete config["dilationRate"];
                    return config
                };
                Conv2DTranspose.className = "Conv2DTranspose";
                return Conv2DTranspose
            }(Conv2D);
            exports.Conv2DTranspose = Conv2DTranspose;
            tfjs_core_1.serialization.SerializationMap.register(Conv2DTranspose);
            var SeparableConv = function (_super) {
                __extends(SeparableConv, _super);

                function SeparableConv(rank, config) {
                    var _this = _super.call(this, rank, config) || this;
                    _this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform";
                    _this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform";
                    _this.depthwiseKernel = null;
                    _this.pointwiseKernel = null;
                    if (config.filters == null) {
                        throw new errors_1.ValueError("The `filters` configuration field is required by SeparableConv, " + "but is unspecified.")
                    }
                    if (config.kernelInitializer != null || config.kernelRegularizer != null || config.kernelConstraint != null) {
                        throw new errors_1.ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint " + "are invalid for SeparableConv2D. Use depthwiseInitializer, " + "depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, " + "pointwiseRegularizer and pointwiseConstraint instead.")
                    }
                    if (config.padding != null && config.padding !== "same" && config.padding !== "valid") {
                        throw new errors_1.ValueError("SeparableConv" + _this.rank + "D supports only padding modes: " + ("'same' and 'valid', but received " + JSON.stringify(config.padding)))
                    }
                    _this.depthMultiplier = config.depthMultiplier == null ? 1 : config.depthMultiplier;
                    _this.depthwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_DEPTHWISE_INITIALIZER);
                    _this.depthwiseRegularizer = regularizers_1.getRegularizer(config.depthwiseRegularizer);
                    _this.depthwiseConstraint = constraints_1.getConstraint(config.depthwiseConstraint);
                    _this.pointwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_POINTWISE_INITIALIZER);
                    _this.pointwiseRegularizer = regularizers_1.getRegularizer(config.pointwiseRegularizer);
                    _this.pointwiseConstraint = constraints_1.getConstraint(config.pointwiseConstraint);
                    return _this
                }

                SeparableConv.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    if (inputShape.length < this.rank + 2) {
                        throw new errors_1.ValueError("Inputs to SeparableConv" + this.rank + "D should have rank " + (this.rank + 2 + ", but received input shape: ") + ("" + JSON.stringify(inputShape)))
                    }
                    var channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
                    if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
                        throw new errors_1.ValueError("The channel dimension of the inputs should be defined, " + ("but found " + JSON.stringify(inputShape[channelAxis])))
                    }
                    var inputDim = inputShape[channelAxis];
                    var depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);
                    var pointwiseKernelShape = [];
                    for (var i = 0; i < this.rank; ++i) {
                        pointwiseKernelShape.push(1)
                    }
                    pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);
                    var trainable = true;
                    this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);
                    this.pointwiseKernel = this.addWeight("pointwise_kernel", pointwiseKernelShape, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);
                    if (this.useBias) {
                        this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint)
                    } else {
                        this.bias = null
                    }
                    this.inputSpec = [new topology_1.InputSpec({
                        ndim: this.rank + 2,
                        axes: (_a = {}, _a[channelAxis] = inputDim, _a)
                    })];
                    this.built = true;
                    var _a
                };
                SeparableConv.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = generic_utils.getExactlyOneTensor(inputs);
                        var output;
                        if (_this.rank === 1) {
                            throw new errors_1.NotImplementedError("1D separable convolution is not implemented yet.")
                        } else if (_this.rank === 2) {
                            if (_this.dataFormat === "channelsFirst") {
                                inputs = tfc.transpose(inputs, [0, 2, 3, 1])
                            }
                            output = tfc.separableConv2d(inputs, _this.depthwiseKernel.read(), _this.pointwiseKernel.read(), _this.strides, _this.padding, _this.dilationRate, "NHWC")
                        }
                        if (_this.useBias) {
                            output = K.biasAdd(output, _this.bias.read(), _this.dataFormat)
                        }
                        if (_this.activation != null) {
                            output = _this.activation.apply(output)
                        }
                        if (_this.dataFormat === "channelsFirst") {
                            output = tfc.transpose(output, [0, 3, 1, 2])
                        }
                        return output
                    })
                };
                SeparableConv.prototype.getConfig = function () {
                    var config = _super.prototype.getConfig.call(this);
                    delete config["rank"];
                    delete config["kernelInitializer"];
                    delete config["kernelRegularizer"];
                    delete config["kernelConstraint"];
                    config["depthwiseInitializer"] = initializers_1.serializeInitializer(this.depthwiseInitializer);
                    config["pointwiseInitializer"] = initializers_1.serializeInitializer(this.pointwiseInitializer);
                    config["depthwiseRegularizer"] = regularizers_1.serializeRegularizer(this.depthwiseRegularizer);
                    config["pointwiseRegularizer"] = regularizers_1.serializeRegularizer(this.pointwiseRegularizer);
                    config["depthwiseConstraint"] = constraints_1.serializeConstraint(this.depthwiseConstraint);
                    config["pointwiseConstraint"] = constraints_1.serializeConstraint(this.pointwiseConstraint);
                    return config
                };
                SeparableConv.className = "SeparableConv";
                return SeparableConv
            }(Conv);
            exports.SeparableConv = SeparableConv;
            var SeparableConv2D = function (_super) {
                __extends(SeparableConv2D, _super);

                function SeparableConv2D(config) {
                    return _super.call(this, 2, config) || this
                }

                SeparableConv2D.className = "SeparableConv2D";
                return SeparableConv2D
            }(SeparableConv);
            exports.SeparableConv2D = SeparableConv2D;
            tfjs_core_1.serialization.SerializationMap.register(SeparableConv2D);
            var Conv1D = function (_super) {
                __extends(Conv1D, _super);

                function Conv1D(config) {
                    var _this = _super.call(this, 1, config) || this;
                    _this.inputSpec = [{ndim: 3}];
                    return _this
                }

                Conv1D.prototype.getConfig = function () {
                    var config = _super.prototype.getConfig.call(this);
                    delete config["rank"];
                    delete config["dataFormat"];
                    return config
                };
                Conv1D.className = "Conv1D";
                return Conv1D
            }(Conv);
            exports.Conv1D = Conv1D;
            tfjs_core_1.serialization.SerializationMap.register(Conv1D);
            var Cropping2D = function (_super) {
                __extends(Cropping2D, _super);

                function Cropping2D(config) {
                    var _this = _super.call(this, config) || this;
                    if (typeof config.cropping === "number") _this.cropping = [[config.cropping, config.cropping], [config.cropping, config.cropping]]; else if (typeof config.cropping[0] === "number") _this.cropping = [[config.cropping[0], config.cropping[0]], [config.cropping[1], config.cropping[1]]]; else _this.cropping = config.cropping;
                    _this.dataFormat = config.dataFormat === undefined ? "channelsLast" : config.dataFormat;
                    _this.inputSpec = [{ndim: 4}];
                    return _this
                }

                Cropping2D.prototype.computeOutputShape = function (inputShape) {
                    if (this.dataFormat === "channelsFirst") return [inputShape[0], inputShape[1], inputShape[2] - this.cropping[0][0] - this.cropping[0][1], inputShape[2] - this.cropping[1][0] - this.cropping[1][1]]; else return [inputShape[0], inputShape[1] - this.cropping[0][0] - this.cropping[0][1], inputShape[2] - this.cropping[1][0] - this.cropping[1][1], inputShape[3]]
                };
                Cropping2D.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = generic_utils.getExactlyOneTensor(inputs);
                        if (_this.dataFormat === "channelsLast") {
                            var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[1] - _this.cropping[0][0] - _this.cropping[0][1], 2);
                            return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[2] - _this.cropping[1][1] - _this.cropping[1][0], 3)
                        } else {
                            var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[2] - _this.cropping[0][0] - _this.cropping[0][1], 3);
                            return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[3] - _this.cropping[1][1] - _this.cropping[1][0], 4)
                        }
                    })
                };
                Cropping2D.prototype.getConfig = function () {
                    var config = {cropping: this.cropping, dataFormat: this.dataFormat};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Cropping2D.className = "Cropping2D";
                return Cropping2D
            }(topology_1.Layer);
            exports.Cropping2D = Cropping2D;
            tfjs_core_1.serialization.SerializationMap.register(Cropping2D)
        }, {
            "../activations": 156,
            "../backend/common": 157,
            "../backend/tfjs_backend": 158,
            "../common": 160,
            "../constraints": 161,
            "../engine/topology": 163,
            "../errors": 165,
            "../initializers": 168,
            "../regularizers": 185,
            "../utils/conv_utils": 187,
            "../utils/generic_utils": 188,
            "@tensorflow/tfjs-core": 50
        }],
        171: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var common_1 = require("../backend/common");
            var K = require("../backend/tfjs_backend");
            var common_2 = require("../common");
            var constraints_1 = require("../constraints");
            var errors_1 = require("../errors");
            var initializers_1 = require("../initializers");
            var regularizers_1 = require("../regularizers");
            var conv_utils_1 = require("../utils/conv_utils");
            var generic_utils_1 = require("../utils/generic_utils");
            var convolutional_1 = require("./convolutional");

            function depthwiseConv2d(x, depthwiseKernel, strides, padding, dataFormat, dilationRate) {
                if (strides === void 0) {
                    strides = [1, 1]
                }
                if (padding === void 0) {
                    padding = "valid"
                }
                return tfjs_core_1.tidy(function () {
                    if (dataFormat == null) {
                        dataFormat = common_1.imageDataFormat()
                    }
                    common_2.checkDataFormat(dataFormat);
                    var y = convolutional_1.preprocessConv2DInput(x, dataFormat);
                    if (x.rank !== 4) {
                        throw new errors_1.ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead " + (x.rank + "-D"))
                    }
                    if (depthwiseKernel.rank !== 4) {
                        throw new errors_1.ValueError("depthwiseKernel is required to be 4-D, but is instead " + (depthwiseKernel.rank + "-D"))
                    }
                    y = tfc.depthwiseConv2d(y, depthwiseKernel, strides, padding === "same" ? "same" : "valid", "NHWC", dilationRate);
                    if (dataFormat === "channelsFirst") {
                        y = tfc.transpose(y, [0, 3, 1, 2])
                    }
                    return y
                })
            }

            exports.depthwiseConv2d = depthwiseConv2d;
            var DepthwiseConv2D = function (_super) {
                __extends(DepthwiseConv2D, _super);

                function DepthwiseConv2D(config) {
                    var _this = _super.call(this, config) || this;
                    _this.depthwiseKernel = null;
                    _this.depthMultiplier = config.depthMultiplier == null ? 1 : config.depthMultiplier;
                    _this.depthwiseInitializer = initializers_1.getInitializer(config.depthwiseInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
                    _this.depthwiseConstraint = constraints_1.getConstraint(config.depthwiseConstraint);
                    _this.depthwiseRegularizer = regularizers_1.getRegularizer(config.depthwiseRegularizer);
                    return _this
                }

                DepthwiseConv2D.prototype.build = function (inputShape) {
                    inputShape = generic_utils_1.getExactlyOneShape(inputShape);
                    if (inputShape.length < 4) {
                        throw new errors_1.ValueError("Inputs to DepthwiseConv2D should have rank 4. " + ("Received input shape: " + JSON.stringify(inputShape) + "."))
                    }
                    var channelAxis = this.dataFormat === "channelsFirst" ? 1 : 3;
                    if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
                        throw new errors_1.ValueError("The channel dimension of the inputs to DepthwiseConv2D should " + ("be defined, but is not (" + inputShape[channelAxis] + ")."))
                    }
                    var inputDim = inputShape[channelAxis];
                    var depthwiseKernelShape = [this.kernelSize[0], this.kernelSize[1], inputDim, this.depthMultiplier];
                    this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
                    if (this.useBias) {
                        this.bias = this.addWeight("bias", [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)
                    } else {
                        this.bias = null
                    }
                    this.built = true
                };
                DepthwiseConv2D.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = generic_utils_1.getExactlyOneTensor(inputs);
                        var outputs = depthwiseConv2d(inputs, _this.depthwiseKernel.read(), _this.strides, _this.padding, _this.dataFormat, null);
                        if (_this.useBias) {
                            outputs = K.biasAdd(outputs, _this.bias.read(), _this.dataFormat)
                        }
                        if (_this.activation != null) {
                            outputs = _this.activation.apply(outputs)
                        }
                        return outputs
                    })
                };
                DepthwiseConv2D.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils_1.getExactlyOneShape(inputShape);
                    var rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
                    var cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
                    var outFilters = this.dataFormat === "channelsFirst" ? inputShape[1] * this.depthMultiplier : inputShape[3] * this.depthMultiplier;
                    var outRows = conv_utils_1.convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);
                    var outCols = conv_utils_1.convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);
                    if (this.dataFormat === "channelsFirst") {
                        return [inputShape[0], outFilters, outRows, outCols]
                    } else {
                        return [inputShape[0], outRows, outCols, outFilters]
                    }
                };
                DepthwiseConv2D.className = "DepthwiseConv2D";
                return DepthwiseConv2D
            }(convolutional_1.Conv2D);
            exports.DepthwiseConv2D = DepthwiseConv2D;
            tfjs_core_1.serialization.SerializationMap.register(DepthwiseConv2D)
        }, {
            "../backend/common": 157,
            "../backend/tfjs_backend": 158,
            "../common": 160,
            "../constraints": 161,
            "../errors": 165,
            "../initializers": 168,
            "../regularizers": 185,
            "../utils/conv_utils": 187,
            "../utils/generic_utils": 188,
            "./convolutional": 170,
            "@tensorflow/tfjs-core": 50
        }],
        172: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var activations_1 = require("../activations");
            var K = require("../backend/tfjs_backend");
            var constraints_1 = require("../constraints");
            var topology_1 = require("../engine/topology");
            var errors_1 = require("../errors");
            var initializers_1 = require("../initializers");
            var regularizers_1 = require("../regularizers");
            var generic_utils = require("../utils/generic_utils");
            var generic_utils_1 = require("../utils/generic_utils");
            var math_utils = require("../utils/math_utils");
            var Dropout = function (_super) {
                __extends(Dropout, _super);

                function Dropout(config) {
                    var _this = _super.call(this, config) || this;
                    _this.rate = Math.max(Math.min(config.rate, 1), 0);
                    _this.rateScalar = K.getScalar(_this.rate);
                    _this.noiseShape = config.noiseShape;
                    _this.seed = config.seed;
                    if (_this.seed != null) {
                        throw new errors_1.NotImplementedError("Non-default seed is not implemented in Dropout layer yet: " + _this.seed)
                    }
                    _this.supportsMasking = true;
                    return _this
                }

                Dropout.prototype.getNoiseShape = function (input) {
                    if (this.noiseShape == null) {
                        return this.noiseShape
                    }
                    var inputShape = input.shape;
                    var noiseShape = [];
                    for (var i = 0; i < this.noiseShape.length; ++i) {
                        noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i])
                    }
                    return noiseShape
                };
                Dropout.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        _this.invokeCallHook(inputs, kwargs);
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        if (_this.noiseShape != null && !tfjs_core_1.util.arraysEqual(input.shape, _this.noiseShape)) {
                            throw new errors_1.NotImplementedError("Non-default noise shape is not implemented in Dropout " + "layer yet: " + JSON.stringify(_this.noiseShape))
                        }
                        if (0 < _this.rate && _this.rate < 1) {
                            var training = kwargs["training"] == null ? false : kwargs["training"];
                            var noiseShape_1 = _this.getNoiseShape(input);
                            var output = K.inTrainPhase(function () {
                                return K.dropout(input, _this.rateScalar, noiseShape_1, _this.seed)
                            }, function () {
                                return input
                            }, training);
                            return output
                        }
                        return inputs
                    })
                };
                Dropout.prototype.getConfig = function () {
                    var config = {rate: this.rate, noiseShape: this.noiseShape, seed: this.seed};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Dropout.className = "Dropout";
                return Dropout
            }(topology_1.Layer);
            exports.Dropout = Dropout;
            tfjs_core_1.serialization.SerializationMap.register(Dropout);
            var Dense = function (_super) {
                __extends(Dense, _super);

                function Dense(config) {
                    var _this = _super.call(this, config) || this;
                    _this.activation = null;
                    _this.useBias = true;
                    _this.kernel = null;
                    _this.bias = null;
                    _this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
                    _this.DEFAULT_BIAS_INITIALIZER = "zeros";
                    if (config.batchInputShape == null && config.inputShape == null && config.inputDim != null) {
                        var batchSize = null;
                        if (config.batchSize != null) {
                            batchSize = config.batchSize
                        }
                        _this.batchInputShape = [batchSize, config.inputDim]
                    }
                    _this.units = config.units;
                    _this.activation = activations_1.getActivation(config.activation);
                    if (config.useBias != null) {
                        _this.useBias = config.useBias
                    }
                    _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
                    _this.biasInitializer = initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
                    _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
                    _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
                    _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
                    _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
                    _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
                    _this.inputSpec = [{minNDim: 2}];
                    return _this
                }

                Dense.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var inputLastDim = inputShape[inputShape.length - 1];
                    if (this.kernel == null) {
                        this.kernel = this.addWeight("kernel", [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
                        if (this.useBias) {
                            this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)
                        }
                    }
                    this.inputSpec = [{minNDim: 2, axes: (_a = {}, _a[-1] = inputLastDim, _a)}];
                    this.built = true;
                    var _a
                };
                Dense.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var outputShape = inputShape.slice();
                    outputShape[outputShape.length - 1] = this.units;
                    return outputShape
                };
                Dense.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        _this.invokeCallHook(inputs, kwargs);
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        var output = K.dot(input, _this.kernel.read());
                        if (_this.bias != null) {
                            output = K.biasAdd(output, _this.bias.read())
                        }
                        if (_this.activation != null) {
                            output = _this.activation.apply(output)
                        }
                        return output
                    })
                };
                Dense.prototype.getConfig = function () {
                    var config = {
                        units: this.units,
                        activation: activations_1.serializeActivation(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
                        biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
                        kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
                        biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
                        biasConstraint: constraints_1.serializeConstraint(this.biasConstraint)
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Dense.className = "Dense";
                return Dense
            }(topology_1.Layer);
            exports.Dense = Dense;
            tfjs_core_1.serialization.SerializationMap.register(Dense);
            var Flatten = function (_super) {
                __extends(Flatten, _super);

                function Flatten(config) {
                    var _this = _super.call(this, config || {}) || this;
                    _this.inputSpec = [{minNDim: 3}];
                    return _this
                }

                Flatten.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    for (var _i = 0, _a = inputShape.slice(1); _i < _a.length; _i++) {
                        var dim = _a[_i];
                        if (dim == null) {
                            throw new errors_1.ValueError('The shape of the input to "Flatten" is not fully defined ' + ("(got " + inputShape.slice(1) + "). Make sure to pass a complete ") + '"input_shape" or "batch_input_shape" argument to the first ' + "layer in your model.")
                        }
                    }
                    return [inputShape[0], math_utils.arrayProd(inputShape, 1)]
                };
                Flatten.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        _this.invokeCallHook(inputs, kwargs);
                        return K.batchFlatten(generic_utils.getExactlyOneTensor(inputs))
                    })
                };
                Flatten.className = "Flatten";
                return Flatten
            }(topology_1.Layer);
            exports.Flatten = Flatten;
            tfjs_core_1.serialization.SerializationMap.register(Flatten);
            var Activation = function (_super) {
                __extends(Activation, _super);

                function Activation(config) {
                    var _this = _super.call(this, config) || this;
                    _this.supportsMasking = true;
                    _this.activation = activations_1.getActivation(config.activation);
                    return _this
                }

                Activation.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        _this.invokeCallHook(inputs, kwargs);
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        return _this.activation.apply(input)
                    })
                };
                Activation.prototype.getConfig = function () {
                    var config = {activation: activations_1.serializeActivation(this.activation)};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Activation.className = "Activation";
                return Activation
            }(topology_1.Layer);
            exports.Activation = Activation;
            tfjs_core_1.serialization.SerializationMap.register(Activation);
            var RepeatVector = function (_super) {
                __extends(RepeatVector, _super);

                function RepeatVector(config) {
                    var _this = _super.call(this, config) || this;
                    _this.n = config.n;
                    _this.inputSpec = [{ndim: 2}];
                    return _this
                }

                RepeatVector.prototype.computeOutputShape = function (inputShape) {
                    return [inputShape[0], this.n, inputShape[1]]
                };
                RepeatVector.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = generic_utils_1.getExactlyOneTensor(inputs);
                        return K.repeat(inputs, _this.n)
                    })
                };
                RepeatVector.prototype.getConfig = function () {
                    var config = {n: this.n};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                RepeatVector.className = "RepeatVector";
                return RepeatVector
            }(topology_1.Layer);
            exports.RepeatVector = RepeatVector;
            tfjs_core_1.serialization.SerializationMap.register(RepeatVector);
            var Reshape = function (_super) {
                __extends(Reshape, _super);

                function Reshape(config) {
                    var _this = _super.call(this, config) || this;
                    _this.targetShape = config.targetShape;
                    for (var i = 0; i < _this.targetShape.length; ++i) {
                        if (_this.isUnknown(_this.targetShape[i])) {
                            _this.targetShape[i] = null
                        }
                    }
                    return _this
                }

                Reshape.prototype.isUnknown = function (dim) {
                    return dim < 0 || dim == null
                };
                Reshape.prototype.fixUnknownDimension = function (inputShape, outputShape) {
                    var errorMsg = "Total size of new array must be unchanged.";
                    var finalShape = outputShape.slice();
                    var known = 1;
                    var unknown = null;
                    for (var i = 0; i < finalShape.length; ++i) {
                        var dim = finalShape[i];
                        if (this.isUnknown(dim)) {
                            if (unknown === null) {
                                unknown = i
                            } else {
                                throw new errors_1.ValueError("Can only specifiy one unknown dimension.")
                            }
                        } else {
                            known *= dim
                        }
                    }
                    var originalSize = math_utils.arrayProd(inputShape);
                    if (unknown !== null) {
                        if (known === 0 || originalSize % known !== 0) {
                            throw new errors_1.ValueError(errorMsg)
                        }
                        finalShape[unknown] = originalSize / known
                    } else if (originalSize !== known) {
                        throw new errors_1.ValueError(errorMsg)
                    }
                    return finalShape
                };
                Reshape.prototype.computeOutputShape = function (inputShape) {
                    var anyUnknownDims = false;
                    for (var i = 0; i < inputShape.length; ++i) {
                        if (this.isUnknown(inputShape[i])) {
                            anyUnknownDims = true;
                            break
                        }
                    }
                    if (anyUnknownDims) {
                        return inputShape.slice(0, 1).concat(this.targetShape)
                    } else {
                        return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape))
                    }
                };
                Reshape.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        _this.invokeCallHook(inputs, kwargs);
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        var inputShape = K.shape(input);
                        var outputShape = inputShape.slice(0, 1).concat(_this.fixUnknownDimension(inputShape.slice(1), _this.targetShape));
                        return input.reshape(outputShape)
                    })
                };
                Reshape.prototype.getConfig = function () {
                    var config = {targetShape: this.targetShape};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Reshape.className = "Reshape";
                return Reshape
            }(topology_1.Layer);
            exports.Reshape = Reshape;
            tfjs_core_1.serialization.SerializationMap.register(Reshape)
        }, {
            "../activations": 156,
            "../backend/tfjs_backend": 158,
            "../constraints": 161,
            "../engine/topology": 163,
            "../errors": 165,
            "../initializers": 168,
            "../regularizers": 185,
            "../utils/generic_utils": 188,
            "../utils/math_utils": 189,
            "@tensorflow/tfjs-core": 50
        }],
        173: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("../backend/tfjs_backend");
            var constraints_1 = require("../constraints");
            var topology_1 = require("../engine/topology");
            var errors_1 = require("../errors");
            var initializers_1 = require("../initializers");
            var regularizers_1 = require("../regularizers");
            var generic_utils = require("../utils/generic_utils");
            var generic_utils_1 = require("../utils/generic_utils");
            var Embedding = function (_super) {
                __extends(Embedding, _super);

                function Embedding(config) {
                    var _this = _super.call(this, config) || this;
                    _this.embeddings = null;
                    _this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform";
                    if (config.batchInputShape == null && config.inputShape == null) {
                        var batchSize = null;
                        if (config.batchSize != null) {
                            batchSize = config.batchSize
                        }
                        if (config.inputLength == null) {
                            _this.batchInputShape = [batchSize, null]
                        } else {
                            _this.batchInputShape = [batchSize].concat(generic_utils.toList(config.inputLength))
                        }
                    }
                    _this.inputDim = config.inputDim;
                    _this.outputDim = config.outputDim;
                    _this.embeddingsInitializer = initializers_1.getInitializer(config.embeddingsInitializer || _this.DEFAULT_EMBEDDINGS_INITIALIZER);
                    _this.embeddingsRegularizer = regularizers_1.getRegularizer(config.embeddingsRegularizer);
                    _this.activityRegularizer = regularizers_1.getRegularizer(config.activityRegularizer);
                    _this.embeddingsConstraint = constraints_1.getConstraint(config.embeddingsConstraint);
                    _this.maskZero = config.maskZero;
                    _this.inputLength = config.inputLength;
                    return _this
                }

                Embedding.prototype.build = function (inputShape) {
                    this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
                    this.built = true
                };
                Embedding.prototype.computeMask = function (inputs, mask) {
                    throw new errors_1.NotImplementedError("computeMask has not been implemented for Embedding yet")
                };
                Embedding.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    if (this.inputLength == null) {
                        return inputShape.concat([this.outputDim])
                    }
                    var inLens = generic_utils.toList(this.inputLength);
                    if (inLens.length !== inputShape.length - 1) {
                        throw new errors_1.ValueError('"inputLength" is ' + this.inputLength + ", but received " + ("input shape has shape " + inputShape))
                    } else {
                        var i = 0;
                        for (var k = 0; k < inLens.length; ++k) {
                            var s1 = inLens[k];
                            var s2 = inputShape[k + 1];
                            if (s1 != null && s2 != null && s1 !== s2) {
                                throw new errors_1.ValueError('"inputLength" is ' + this.inputLength + ", but received " + ("input shape has shape " + inputShape))
                            } else if (s1 == null) {
                                inLens[i] = s2
                            }
                            i++
                        }
                    }
                    return [inputShape[0]].concat(inLens, [this.outputDim])
                };
                Embedding.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        _this.invokeCallHook(inputs, kwargs);
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        if (K.dtype(input) !== "int32") {
                            input = K.cast(input, "int32")
                        }
                        var output = K.gather(_this.embeddings.read(), input.as1D());
                        return output.reshape(generic_utils_1.getExactlyOneShape(_this.computeOutputShape(input.shape)))
                    })
                };
                Embedding.prototype.getConfig = function () {
                    var config = {
                        inputDim: this.inputDim,
                        outputDim: this.outputDim,
                        embeddingsInitializer: initializers_1.serializeInitializer(this.embeddingsInitializer),
                        embeddingsRegularizer: regularizers_1.serializeRegularizer(this.embeddingsRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        embeddingsConstraint: constraints_1.serializeConstraint(this.embeddingsConstraint),
                        maskZero: this.maskZero,
                        inputLength: this.inputLength
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Embedding.className = "Embedding";
                return Embedding
            }(topology_1.Layer);
            exports.Embedding = Embedding;
            tfjs_core_1.serialization.SerializationMap.register(Embedding)
        }, {
            "../backend/tfjs_backend": 158,
            "../constraints": 161,
            "../engine/topology": 163,
            "../errors": 165,
            "../initializers": 168,
            "../regularizers": 185,
            "../utils/generic_utils": 188,
            "@tensorflow/tfjs-core": 50
        }],
        174: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("../backend/tfjs_backend");
            var topology_1 = require("../engine/topology");
            var errors_1 = require("../errors");
            var generic_utils = require("../utils/generic_utils");
            var mathUtils = require("../utils/math_utils");
            var Merge = function (_super) {
                __extends(Merge, _super);

                function Merge(config) {
                    var _this = _super.call(this, config || {}) || this;
                    _this.supportsMasking = true;
                    return _this
                }

                Merge.prototype.mergeFunction = function (inputs) {
                    throw new errors_1.NotImplementedError
                };
                Merge.prototype.computeElementwiseOpOutputShape = function (shape1, shape2) {
                    if (shape1 == null || shape2 == null) {
                        return null
                    } else if (shape1.length < shape2.length) {
                        return this.computeElementwiseOpOutputShape(shape2, shape1)
                    } else if (shape2.length === 0) {
                        return shape1
                    }
                    var outputShape = shape1.slice(0, shape1.length - shape2.length);
                    for (var k = 0; k < shape2.length; ++k) {
                        var i = shape1[shape1.length - shape2.length + k];
                        var j = shape2[k];
                        if (i == null || j == null || i < 0 || j < 0) {
                            outputShape.push(null)
                        } else if (i === 1) {
                            outputShape.push(j)
                        } else if (j === 1) {
                            outputShape.push(i)
                        } else {
                            if (i !== j) {
                                throw new errors_1.ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(shape1) + " " + JSON.stringify(shape2))
                            }
                            outputShape.push(i)
                        }
                    }
                    return outputShape
                };
                Merge.prototype.build = function (inputShape) {
                    if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {
                        inputShape = [generic_utils.getExactlyOneShape(inputShape)]
                    }
                    inputShape = inputShape;
                    if (inputShape.length < 2) {
                        throw new errors_1.ValueError("A merge layer should be called on an Array of at least 2 inputs." + (" Got " + inputShape.length + " input(s)."))
                    }
                    var batchSizes = [];
                    for (var _i = 0, inputShape_1 = inputShape; _i < inputShape_1.length; _i++) {
                        var shape = inputShape_1[_i];
                        if (shape != null && shape[0] !== null) {
                            batchSizes.push(shape[0])
                        }
                    }
                    batchSizes = generic_utils.unique(batchSizes);
                    if (batchSizes.length > 1) {
                        throw new errors_1.ValueError("Can not merge tensors with different batch sizes. " + ("Got tensors with shapes: " + JSON.stringify(inputShape) + "."))
                    }
                    var outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);
                    for (var i = 1; i < inputShape.length; ++i) {
                        var shape = inputShape[i] == null ? null : inputShape[i].slice(1);
                        outputShape = this.computeElementwiseOpOutputShape(outputShape, shape)
                    }
                    var allRanks = inputShape.map(function (shape) {
                        return shape.length
                    });
                    if (inputShape.indexOf(null) === -1 && generic_utils.unique(allRanks).length === 1) {
                        this.reshapeRequired = false
                    } else {
                        this.reshapeRequired = true
                    }
                };
                Merge.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = inputs;
                        if (_this.reshapeRequired) {
                            var reshapedInputs = [];
                            var inputDims = inputs.map(function (input) {
                                return input.rank
                            });
                            if (inputDims.indexOf(null) === -1) {
                                var maxNDim = mathUtils.max(inputDims);
                                for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                                    var x = inputs_1[_i];
                                    var xNDim = x.rank;
                                    for (var k = 0; k < maxNDim - xNDim; ++k) {
                                        x = K.expandDims(x, 1)
                                    }
                                    reshapedInputs.push(x)
                                }
                                return _this.mergeFunction(reshapedInputs)
                            } else {
                                var transposed = false;
                                for (var _a = 0, inputs_2 = inputs; _a < inputs_2.length; _a++) {
                                    var x = inputs_2[_a];
                                    var xNDim = x.rank;
                                    if (xNDim == null) {
                                        var xShape = K.shape(x);
                                        var batchSize = xShape[0];
                                        var newShape = xShape.slice(1).concat([batchSize]);
                                        var xTransposed = x.reshape([batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));
                                        xTransposed = tfc.transpose(xTransposed, [1, 0]);
                                        xTransposed = xTransposed.reshape(newShape);
                                        reshapedInputs.push(xTransposed);
                                        transposed = true
                                    } else if (xNDim > 1) {
                                        var dims = mathUtils.range(1, xNDim).concat([0]);
                                        reshapedInputs.push(tfc.transpose(x, dims));
                                        transposed = true
                                    } else {
                                        reshapedInputs.push(x)
                                    }
                                }
                                var y = _this.mergeFunction(reshapedInputs);
                                var yNDim = y.rank;
                                if (transposed) {
                                    if (yNDim == null) {
                                        var yShape = K.shape(y);
                                        var yNDim_1 = yShape.length;
                                        var batchSize = yShape[yNDim_1 - 1];
                                        var newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));
                                        y = tfc.transpose(y.reshape([-1, batchSize]), [1, 0]).reshape(newShape)
                                    } else if (yNDim > 1) {
                                        var dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));
                                        y = tfc.transpose(y, dims)
                                    }
                                }
                                return y
                            }
                        } else {
                            return _this.mergeFunction(inputs)
                        }
                    })
                };
                Merge.prototype.computeOutputShape = function (inputShape) {
                    inputShape = inputShape;
                    var outputShape;
                    if (inputShape[0] == null) {
                        outputShape = null
                    } else {
                        outputShape = inputShape[0].slice(1)
                    }
                    for (var i = 1; i < inputShape.length; ++i) {
                        var shape = inputShape[i] == null ? null : inputShape[i].slice(1);
                        outputShape = this.computeElementwiseOpOutputShape(outputShape, shape)
                    }
                    var batchSizes = [];
                    for (var _i = 0, inputShape_2 = inputShape; _i < inputShape_2.length; _i++) {
                        var shape = inputShape_2[_i];
                        if (shape != null && shape[0] !== null) {
                            batchSizes.push(shape[0])
                        }
                    }
                    batchSizes = generic_utils.unique(batchSizes);
                    if (batchSizes.length === 1) {
                        outputShape = batchSizes.concat(outputShape)
                    } else {
                        outputShape = [null].concat(outputShape)
                    }
                    return outputShape
                };
                return Merge
            }(topology_1.Layer);
            exports.Merge = Merge;
            var Add = function (_super) {
                __extends(Add, _super);

                function Add(config) {
                    return _super.call(this, config) || this
                }

                Add.prototype.mergeFunction = function (inputs) {
                    return tfjs_core_1.tidy(function () {
                        var output = tfc.zeros(inputs[0].shape);
                        for (var _i = 0, inputs_3 = inputs; _i < inputs_3.length; _i++) {
                            var input = inputs_3[_i];
                            output = tfc.add(output, input)
                        }
                        return output
                    })
                };
                Add.className = "Add";
                return Add
            }(Merge);
            exports.Add = Add;
            tfjs_core_1.serialization.SerializationMap.register(Add);

            function add(config) {
                if (Array.isArray(config)) {
                    var layer = new Add({});
                    return layer.apply(config)
                } else {
                    return new Add(config)
                }
            }

            exports.add = add;
            var Multiply = function (_super) {
                __extends(Multiply, _super);

                function Multiply(config) {
                    return _super.call(this, config) || this
                }

                Multiply.prototype.mergeFunction = function (inputs) {
                    return tfjs_core_1.tidy(function () {
                        var output = tfc.ones(inputs[0].shape);
                        for (var _i = 0, inputs_4 = inputs; _i < inputs_4.length; _i++) {
                            var input = inputs_4[_i];
                            output = tfc.mul(output, input)
                        }
                        return output
                    })
                };
                Multiply.className = "Multiply";
                return Multiply
            }(Merge);
            exports.Multiply = Multiply;
            tfjs_core_1.serialization.SerializationMap.register(Multiply);

            function multiply(config) {
                if (Array.isArray(config)) {
                    var layer = new Multiply({});
                    return layer.apply(config)
                } else {
                    return new Multiply(config)
                }
            }

            exports.multiply = multiply;
            var Average = function (_super) {
                __extends(Average, _super);

                function Average(config) {
                    return _super.call(this, config) || this
                }

                Average.prototype.mergeFunction = function (inputs) {
                    return tfjs_core_1.tidy(function () {
                        var output = tfc.zeros(inputs[0].shape);
                        for (var _i = 0, inputs_5 = inputs; _i < inputs_5.length; _i++) {
                            var input = inputs_5[_i];
                            output = tfc.add(output, input)
                        }
                        return K.scalarTimesArray(K.getScalar(1 / inputs.length), output)
                    })
                };
                Average.className = "Average";
                return Average
            }(Merge);
            exports.Average = Average;
            tfjs_core_1.serialization.SerializationMap.register(Average);

            function average(config) {
                if (Array.isArray(config)) {
                    var layer = new Average({});
                    return layer.apply(config)
                } else {
                    return new Average(config)
                }
            }

            exports.average = average;
            var Maximum = function (_super) {
                __extends(Maximum, _super);

                function Maximum(config) {
                    return _super.call(this, config) || this
                }

                Maximum.prototype.mergeFunction = function (inputs) {
                    return tfjs_core_1.tidy(function () {
                        var output = inputs[0];
                        for (var i = 1; i < inputs.length; ++i) {
                            output = tfc.maximum(output, inputs[i])
                        }
                        return output
                    })
                };
                Maximum.className = "Maximum";
                return Maximum
            }(Merge);
            exports.Maximum = Maximum;
            tfjs_core_1.serialization.SerializationMap.register(Maximum);

            function maximum(config) {
                if (Array.isArray(config)) {
                    var layer = new Maximum({});
                    return layer.apply(config)
                } else {
                    return new Maximum(config)
                }
            }

            exports.maximum = maximum;
            var Minimum = function (_super) {
                __extends(Minimum, _super);

                function Minimum(config) {
                    return _super.call(this, config) || this
                }

                Minimum.prototype.mergeFunction = function (inputs) {
                    return tfjs_core_1.tidy(function () {
                        var output = inputs[0];
                        for (var i = 1; i < inputs.length; ++i) {
                            output = tfc.minimum(output, inputs[i])
                        }
                        return output
                    })
                };
                Minimum.className = "Minimum";
                return Minimum
            }(Merge);
            exports.Minimum = Minimum;
            tfjs_core_1.serialization.SerializationMap.register(Minimum);

            function minimum(config) {
                if (Array.isArray(config)) {
                    var layer = new Minimum({});
                    return layer.apply(config)
                } else {
                    return new Minimum(config)
                }
            }

            exports.minimum = minimum;
            var Concatenate = function (_super) {
                __extends(Concatenate, _super);

                function Concatenate(config) {
                    var _this = _super.call(this, config) || this;
                    _this.DEFAULT_AXIS = -1;
                    if (config == null) {
                        config = {}
                    }
                    _this.axis = config.axis == null ? _this.DEFAULT_AXIS : config.axis;
                    _this.supportsMasking = true;
                    _this.reshapeRequired = false;
                    return _this
                }

                Concatenate.prototype.build = function (inputShape) {
                    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) || inputShape.length === 1) {
                        throw new errors_1.ValueError("A `Concatenate` layer should be called on a list of at least 2 " + "inputs")
                    }
                    inputShape = inputShape;
                    var allNoneShape = true;
                    for (var _i = 0, inputShape_3 = inputShape; _i < inputShape_3.length; _i++) {
                        var shape = inputShape_3[_i];
                        if (shape != null) {
                            allNoneShape = false;
                            break
                        }
                    }
                    if (allNoneShape) {
                        return
                    }
                    var shapeSet = [];
                    for (var i = 0; i < inputShape.length; ++i) {
                        var shapeWithoutConcatAxis = inputShape[i].slice();
                        shapeWithoutConcatAxis.splice(this.axis, 1);
                        var exists = false;
                        for (var _a = 0, shapeSet_1 = shapeSet; _a < shapeSet_1.length; _a++) {
                            var shape = shapeSet_1[_a];
                            if (tfjs_core_1.util.arraysEqual(shape, shapeWithoutConcatAxis)) {
                                exists = true;
                                break
                            }
                        }
                        if (!exists) {
                            shapeSet.push(shapeWithoutConcatAxis)
                        }
                    }
                    if (shapeSet.length > 1) {
                        throw new errors_1.ValueError("A `Concatenate` layer requires inputs with matching shapes " + "except for the concat axis. Got input shapes: " + JSON.stringify(inputShape))
                    }
                };
                Concatenate.prototype.mergeFunction = function (inputs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        return K.concatenate(inputs, _this.axis)
                    })
                };
                Concatenate.prototype.computeOutputShape = function (inputShape) {
                    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {
                        throw new errors_1.ValueError("A `Concatenate` layer should be called on a list of inputs.")
                    }
                    var inputShapes = inputShape;
                    var outputShape = inputShapes[0].slice();
                    var axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;
                    for (var _i = 0, _a = inputShapes.slice(1); _i < _a.length; _i++) {
                        var shape = _a[_i];
                        if (outputShape[axis] == null || shape[axis] == null) {
                            outputShape[axis] = null;
                            break
                        }
                        outputShape[axis] += shape[axis]
                    }
                    return outputShape
                };
                Concatenate.prototype.getConfig = function () {
                    var config = {axis: this.axis};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Concatenate.className = "Concatenate";
                return Concatenate
            }(Merge);
            exports.Concatenate = Concatenate;
            tfjs_core_1.serialization.SerializationMap.register(Concatenate);

            function concatenate(config) {
                if (Array.isArray(config)) {
                    var layer = new Concatenate({});
                    return layer.apply(config)
                } else {
                    return new Concatenate(config)
                }
            }

            exports.concatenate = concatenate
        }, {
            "../backend/tfjs_backend": 158,
            "../engine/topology": 163,
            "../errors": 165,
            "../utils/generic_utils": 188,
            "../utils/math_utils": 189,
            "@tensorflow/tfjs-core": 50
        }],
        175: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("../backend/tfjs_backend");
            var constraints_1 = require("../constraints");
            var topology_1 = require("../engine/topology");
            var errors_1 = require("../errors");
            var initializers_1 = require("../initializers");
            var regularizers_1 = require("../regularizers");
            var generic_utils = require("../utils/generic_utils");
            var math_utils = require("../utils/math_utils");

            function batchNormalization(x, mean, variance, beta, gamma, epsilon) {
                if (epsilon === void 0) {
                    epsilon = .001
                }
                var out;
                if (x.rank === 2) {
                    out = tfc.batchNormalization2d(x, mean, variance, epsilon, gamma, beta)
                } else if (x.rank === 3) {
                    out = tfc.batchNormalization3d(x, mean, variance, epsilon, gamma, beta)
                } else if (x.rank === 4) {
                    out = tfc.batchNormalization4d(x, mean, variance, epsilon, gamma, beta)
                } else {
                    throw new errors_1.NotImplementedError("batchNormalization is not implememnted for array of rank " + x.rank + " " + "yet")
                }
                return out
            }

            exports.batchNormalization = batchNormalization;

            function regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
                if (epsilon === void 0) {
                    epsilon = .001
                }
                return tfjs_core_1.tidy(function () {
                    var meanAndVariance = tfc.moments(x, reductionAxes);
                    var mean = meanAndVariance.mean;
                    var variance = meanAndVariance.variance;
                    var normed = batchNormalization(x, mean, variance, beta, gamma, epsilon);
                    return [normed, mean, variance]
                })
            }

            function broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
                if (epsilon === void 0) {
                    epsilon = .001
                }
                return tfjs_core_1.tidy(function () {
                    var meanAndVariance = tfc.moments(x, reductionAxes);
                    var mean = meanAndVariance.mean;
                    var variance = meanAndVariance.variance;
                    var targetShape = [];
                    for (var _i = 0, _a = math_utils.range(0, x.rank); _i < _a.length; _i++) {
                        var axis = _a[_i];
                        if (reductionAxes.indexOf(axis) !== -1) {
                            targetShape.push(1)
                        } else {
                            targetShape.push(x.shape[axis])
                        }
                    }
                    var broadcastMean = mean.reshape(targetShape);
                    var broadcastVariance = variance.reshape(targetShape);
                    var broadcastGamma = gamma == null ? null : gamma.reshape(targetShape);
                    var broadcastBeta = beta == null ? null : beta.reshape(targetShape);
                    var normed = batchNormalization(x, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon);
                    return [normed, mean, variance]
                })
            }

            function normalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon) {
                if (epsilon === void 0) {
                    epsilon = .001
                }
                if (tfjs_core_1.util.arraysEqual(reductionAxes.slice().sort(), math_utils.range(0, x.rank - 1))) {
                    return regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon)
                } else {
                    return broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon)
                }
            }

            exports.normalizeBatchInTraining = normalizeBatchInTraining;
            var BatchNormalization = function (_super) {
                __extends(BatchNormalization, _super);

                function BatchNormalization(config) {
                    var _this = _super.call(this, config) || this;
                    _this.supportsMasking = true;
                    _this.axis = config.axis == null ? -1 : config.axis;
                    _this.momentum = config.momentum == null ? .99 : config.momentum;
                    _this.epsilon = config.epsilon == null ? .001 : config.epsilon;
                    _this.center = config.center == null ? true : config.center;
                    _this.scale = config.scale == null ? true : config.scale;
                    _this.betaInitializer = initializers_1.getInitializer(config.betaInitializer || "zeros");
                    _this.gammaInitializer = initializers_1.getInitializer(config.gammaInitializer || "ones");
                    _this.movingMeanInitializer = initializers_1.getInitializer(config.movingMeanInitializer || "zeros");
                    _this.movingVarianceInitializer = initializers_1.getInitializer(config.movingVarianceInitializer || "ones");
                    _this.betaConstraint = constraints_1.getConstraint(config.betaConstraint);
                    _this.gammaConstraint = constraints_1.getConstraint(config.gammaConstraint);
                    _this.betaRegularizer = regularizers_1.getRegularizer(config.betaRegularizer);
                    _this.gammaRegularizer = regularizers_1.getRegularizer(config.gammaRegularizer);
                    _this.stepCount = 0;
                    return _this
                }

                BatchNormalization.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var axis = this.axis >= 0 ? this.axis : this.axis + inputShape.length;
                    var dim = inputShape[axis];
                    if (dim == null) {
                        throw new errors_1.ValueError("Axis " + axis + " of input tensor should have a defined dimension but " + "the layer received an input with shape " + (JSON.stringify(inputShape) + "."))
                    }
                    this.inputSpec = [new topology_1.InputSpec({
                        ndim: inputShape.length,
                        axes: (_a = {}, _a[axis] = dim, _a)
                    })];
                    var shape = [dim];
                    if (this.scale) {
                        this.gamma = this.addWeight("gamma", shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint)
                    }
                    if (this.center) {
                        this.beta = this.addWeight("beta", shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint)
                    }
                    this.movingMean = this.addWeight("moving_mean", shape, null, this.movingMeanInitializer, null, false);
                    this.movingVariance = this.addWeight("moving_variance", shape, null, this.movingVarianceInitializer, null, false);
                    this.built = true;
                    var _a
                };
                BatchNormalization.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var training = kwargs["training"] == null ? false : kwargs["training"];
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        var inputShape = K.shape(input);
                        var ndim = inputShape.length;
                        var reductionAxes = math_utils.range(0, ndim);
                        var axis = _this.axis >= 0 ? _this.axis : _this.axis + ndim;
                        reductionAxes.splice(axis, 1);
                        var broadcastShape = generic_utils.pyListRepeat(1, ndim);
                        broadcastShape[axis] = inputShape[axis];
                        var sortedReductionAxes = reductionAxes.slice();
                        sortedReductionAxes.sort();
                        var needsBroadcasting = !tfjs_core_1.util.arraysEqual(sortedReductionAxes, math_utils.range(0, ndim).slice(0, ndim - 1));
                        var normalizeInference = function () {
                            if (needsBroadcasting) {
                                var broadcastMovingMean = _this.movingMean.read().reshape(broadcastShape);
                                var broadcastMovingVariance = _this.movingVariance.read().reshape(broadcastShape);
                                var broadcastBeta = _this.center ? _this.beta.read().reshape(broadcastShape) : null;
                                var broadcastGamma = _this.scale ? _this.gamma.read().reshape(broadcastShape) : null;
                                return batchNormalization(input, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, _this.epsilon)
                            } else {
                                return batchNormalization(input, _this.movingMean.read(), _this.movingVariance.read(), _this.beta == null ? null : _this.beta.read(), _this.gamma == null ? null : _this.gamma.read(), _this.epsilon)
                            }
                        };
                        if (!training) {
                            return normalizeInference()
                        }
                        var _a = normalizeBatchInTraining(input, _this.gamma.read(), _this.beta.read(), reductionAxes, _this.epsilon),
                            normedTraining = _a[0], mean = _a[1], variance = _a[2];
                        var sampleSize = math_utils.arrayProd(reductionAxes.map(function (axis) {
                            return input.shape[axis]
                        }));
                        var varianceDebiased = variance.mul(K.getScalar(sampleSize / (sampleSize - (1 + _this.epsilon))));
                        var updateMovingMeanAndVariance = function () {
                            _this.stepCount++;
                            var newMovingMean = tfc.movingAverage(_this.movingMean.read(), mean, _this.momentum, _this.stepCount);
                            _this.movingMean.write(newMovingMean);
                            var newMovingVariance = tfc.movingAverage(_this.movingVariance.read(), varianceDebiased, _this.momentum, _this.stepCount);
                            _this.movingVariance.write(newMovingVariance)
                        };
                        updateMovingMeanAndVariance();
                        return normedTraining
                    })
                };
                BatchNormalization.prototype.getConfig = function () {
                    var config = {
                        axis: this.axis,
                        momentum: this.momentum,
                        epsilon: this.epsilon,
                        center: this.center,
                        scale: this.scale,
                        betaInitializer: initializers_1.serializeInitializer(this.betaInitializer),
                        gammaInitializer: initializers_1.serializeInitializer(this.gammaInitializer),
                        movingMeanInitializer: initializers_1.serializeInitializer(this.movingMeanInitializer),
                        movingVarianceInitializer: initializers_1.serializeInitializer(this.movingVarianceInitializer),
                        betaRegularizer: regularizers_1.serializeRegularizer(this.betaRegularizer),
                        gammaRegularizer: regularizers_1.serializeRegularizer(this.gammaRegularizer),
                        betaConstraint: constraints_1.serializeConstraint(this.betaConstraint),
                        gammaConstraint: constraints_1.serializeConstraint(this.gammaConstraint)
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                BatchNormalization.className = "BatchNormalization";
                return BatchNormalization
            }(topology_1.Layer);
            exports.BatchNormalization = BatchNormalization;
            tfjs_core_1.serialization.SerializationMap.register(BatchNormalization)
        }, {
            "../backend/tfjs_backend": 158,
            "../constraints": 161,
            "../engine/topology": 163,
            "../errors": 165,
            "../initializers": 168,
            "../regularizers": 185,
            "../utils/generic_utils": 188,
            "../utils/math_utils": 189,
            "@tensorflow/tfjs-core": 50
        }],
        176: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var common_1 = require("../backend/common");
            var topology_1 = require("../engine/topology");
            var errors_1 = require("../errors");
            var generic_utils_1 = require("../utils/generic_utils");

            function temporalPadding(x, padding) {
                return tfjs_core_1.tidy(function () {
                    if (x.rank !== 3) {
                        throw new errors_1.ValueError("temporalPadding expects input tensor to be 3-D, but received a " + (x.rank + "-D tensor."))
                    }
                    if (padding == null) {
                        padding = [1, 1]
                    }
                    if (padding.length !== 2) {
                        throw new errors_1.ValueError("temporalPadding expects input padding pattern to be a length-2 " + ("array, but received a length-" + padding.length + " array."))
                    }
                    var pattern = [[0, 0], padding, [0, 0]];
                    return tfc.pad(x, pattern)
                })
            }

            exports.temporalPadding = temporalPadding;

            function spatial2dPadding(x, padding, dataFormat) {
                return tfjs_core_1.tidy(function () {
                    if (x.rank !== 4) {
                        throw new errors_1.ValueError("temporalPadding expects input tensor to be 4-D, but received a " + (x.rank + "-D tensor."))
                    }
                    if (padding == null) {
                        padding = [[1, 1], [1, 1]]
                    }
                    if (padding.length !== 2 || padding[0].length !== 2 || padding[1].length !== 2) {
                        throw new errors_1.ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, " + "each of which is an Array of two integers.")
                    }
                    if (dataFormat == null) {
                        dataFormat = common_1.imageDataFormat()
                    }
                    if (dataFormat !== "channelsLast" && dataFormat !== "channelsFirst") {
                        throw new errors_1.ValueError("Unknown data format: " + dataFormat + ". " + "Supported data formats are 'channelsLast' and 'channelsFirst.")
                    }
                    var pattern;
                    if (dataFormat === "channelsFirst") {
                        pattern = [[0, 0], [0, 0], padding[0], padding[1]]
                    } else {
                        pattern = [[0, 0], padding[0], padding[1], [0, 0]]
                    }
                    return tfc.pad(x, pattern)
                })
            }

            exports.spatial2dPadding = spatial2dPadding;
            var ZeroPadding2D = function (_super) {
                __extends(ZeroPadding2D, _super);

                function ZeroPadding2D(config) {
                    var _this = this;
                    if (config == null) {
                        config = {}
                    }
                    _this = _super.call(this, config) || this;
                    _this.dataFormat = config.dataFormat == null ? common_1.imageDataFormat() : config.dataFormat;
                    if (config.padding == null) {
                        _this.padding = [[1, 1], [1, 1]]
                    } else if (typeof config.padding === "number") {
                        _this.padding = [[config.padding, config.padding], [config.padding, config.padding]]
                    } else {
                        config.padding = config.padding;
                        if (config.padding.length !== 2) {
                            throw new errors_1.ValueError("ZeroPadding2D expects padding to be a length-2 array, but " + ("received a length-" + config.padding.length + " array."))
                        }
                        var heightPadding = void 0;
                        var widthPadding = void 0;
                        if (typeof config.padding[0] === "number") {
                            heightPadding = [config.padding[0], config.padding[0]];
                            widthPadding = [config.padding[1], config.padding[1]]
                        } else {
                            config.padding = config.padding;
                            if (config.padding[0].length !== 2) {
                                throw new errors_1.ValueError("ZeroPadding2D expects height padding to be a length-2 array, " + ("but received a length-" + config.padding[0].length + " array."))
                            }
                            heightPadding = config.padding[0];
                            if (config.padding[1].length !== 2) {
                                throw new errors_1.ValueError("ZeroPadding2D expects width padding to be a length-2 array, " + ("but received a length-" + config.padding[1].length + " array."))
                            }
                            widthPadding = config.padding[1]
                        }
                        _this.padding = [heightPadding, widthPadding]
                    }
                    _this.inputSpec = [new topology_1.InputSpec({ndim: 4})];
                    return _this
                }

                ZeroPadding2D.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils_1.getExactlyOneShape(inputShape);
                    var rows;
                    var cols;
                    if (this.dataFormat === "channelsFirst") {
                        if (inputShape[2] != null && inputShape[2] >= 0) {
                            rows = inputShape[2] + this.padding[0][0] + this.padding[0][1]
                        } else {
                            rows = null
                        }
                        if (inputShape[3] != null && inputShape[3] >= 0) {
                            cols = inputShape[3] + this.padding[1][0] + this.padding[1][1]
                        } else {
                            cols = null
                        }
                        return [inputShape[0], inputShape[1], rows, cols]
                    } else {
                        if (inputShape[1] != null && inputShape[1] >= 0) {
                            rows = inputShape[1] + this.padding[0][0] + this.padding[0][1]
                        } else {
                            rows = null
                        }
                        if (inputShape[2] != null && inputShape[2] >= 0) {
                            cols = inputShape[2] + this.padding[1][0] + this.padding[1][1]
                        } else {
                            cols = null
                        }
                        return [inputShape[0], rows, cols, inputShape[3]]
                    }
                };
                ZeroPadding2D.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        return spatial2dPadding(generic_utils_1.getExactlyOneTensor(inputs), _this.padding, _this.dataFormat)
                    })
                };
                ZeroPadding2D.prototype.getConfig = function () {
                    var config = {padding: this.padding, dataFormat: this.dataFormat};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                ZeroPadding2D.className = "ZeroPadding2D";
                return ZeroPadding2D
            }(topology_1.Layer);
            exports.ZeroPadding2D = ZeroPadding2D;
            tfjs_core_1.serialization.SerializationMap.register(ZeroPadding2D)
        }, {
            "../backend/common": 157,
            "../engine/topology": 163,
            "../errors": 165,
            "../utils/generic_utils": 188,
            "@tensorflow/tfjs-core": 50
        }],
        177: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var common_1 = require("../backend/common");
            var K = require("../backend/tfjs_backend");
            var common_2 = require("../common");
            var topology_1 = require("../engine/topology");
            var topology_2 = require("../engine/topology");
            var errors_1 = require("../errors");
            var conv_utils_1 = require("../utils/conv_utils");
            var generic_utils = require("../utils/generic_utils");
            var convolutional_1 = require("./convolutional");

            function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {
                return tfjs_core_1.tidy(function () {
                    common_2.checkDataFormat(dataFormat);
                    common_2.checkPoolMode(poolMode);
                    common_2.checkPaddingMode(padding);
                    if (strides == null) {
                        strides = [1, 1]
                    }
                    if (padding == null) {
                        padding = "valid"
                    }
                    if (dataFormat == null) {
                        dataFormat = common_1.imageDataFormat()
                    }
                    if (poolMode == null) {
                        poolMode = "max"
                    }
                    x = convolutional_1.preprocessConv2DInput(x, dataFormat);
                    var y;
                    var paddingString = padding === "same" ? "same" : "valid";
                    if (poolMode === "max") {
                        y = tfc.maxPool(x, poolSize, strides, paddingString)
                    } else {
                        y = tfc.avgPool(x, poolSize, strides, paddingString)
                    }
                    if (dataFormat === "channelsFirst") {
                        y = tfc.transpose(y, [0, 3, 1, 2])
                    }
                    return y
                })
            }

            exports.pool2d = pool2d;
            var Pooling1D = function (_super) {
                __extends(Pooling1D, _super);

                function Pooling1D(config) {
                    var _this = this;
                    if (config.poolSize == null) {
                        config.poolSize = 2
                    }
                    _this = _super.call(this, config) || this;
                    if (typeof config.poolSize === "number") {
                        _this.poolSize = [config.poolSize]
                    } else if (Array.isArray(config.poolSize) && config.poolSize.length === 1 && typeof config.poolSize[0] === "number") {
                        _this.poolSize = config.poolSize
                    } else {
                        throw new errors_1.ValueError("poolSize for 1D convolutional layer must be a number or an " + "Array of a single number, but received " + ("" + JSON.stringify(config.poolSize)))
                    }
                    if (config.strides == null) {
                        _this.strides = _this.poolSize
                    } else {
                        if (typeof config.strides === "number") {
                            _this.strides = [config.strides]
                        } else if (Array.isArray(config.strides) && config.strides.length === 1 && typeof config.strides[0] === "number") {
                            _this.strides = config.strides
                        } else {
                            throw new errors_1.ValueError("strides for 1D convolutional layer must be a number or an " + "Array of a single number, but received " + ("" + JSON.stringify(config.strides)))
                        }
                    }
                    _this.padding = config.padding == null ? "valid" : config.padding;
                    common_2.checkPaddingMode(_this.padding);
                    _this.inputSpec = [new topology_1.InputSpec({ndim: 3})];
                    return _this
                }

                Pooling1D.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var length = conv_utils_1.convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);
                    return [inputShape[0], length, inputShape[2]]
                };
                Pooling1D.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        _this.invokeCallHook(inputs, kwargs);
                        inputs = K.expandDims(generic_utils.getExactlyOneTensor(inputs), 2);
                        var output = _this.poolingFunction(generic_utils.getExactlyOneTensor(inputs), [_this.poolSize[0], 1], [_this.strides[0], 1], _this.padding, "channelsLast");
                        return tfc.squeeze(output, [2])
                    })
                };
                Pooling1D.prototype.getConfig = function () {
                    var config = {poolSize: this.poolSize, padding: this.padding, strides: this.strides};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                return Pooling1D
            }(topology_2.Layer);
            exports.Pooling1D = Pooling1D;
            var MaxPooling1D = function (_super) {
                __extends(MaxPooling1D, _super);

                function MaxPooling1D(config) {
                    return _super.call(this, config) || this
                }

                MaxPooling1D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
                    common_2.checkDataFormat(dataFormat);
                    common_2.checkPaddingMode(padding);
                    return pool2d(inputs, poolSize, strides, padding, dataFormat, "max")
                };
                MaxPooling1D.className = "MaxPooling1D";
                return MaxPooling1D
            }(Pooling1D);
            exports.MaxPooling1D = MaxPooling1D;
            tfjs_core_1.serialization.SerializationMap.register(MaxPooling1D);
            var AveragePooling1D = function (_super) {
                __extends(AveragePooling1D, _super);

                function AveragePooling1D(config) {
                    return _super.call(this, config) || this
                }

                AveragePooling1D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
                    common_2.checkDataFormat(dataFormat);
                    common_2.checkPaddingMode(padding);
                    return pool2d(inputs, poolSize, strides, padding, dataFormat, "avg")
                };
                AveragePooling1D.className = "AveragePooling1D";
                return AveragePooling1D
            }(Pooling1D);
            exports.AveragePooling1D = AveragePooling1D;
            tfjs_core_1.serialization.SerializationMap.register(AveragePooling1D);
            var Pooling2D = function (_super) {
                __extends(Pooling2D, _super);

                function Pooling2D(config) {
                    var _this = this;
                    if (config.poolSize == null) {
                        config.poolSize = [2, 2]
                    }
                    _this = _super.call(this, config) || this;
                    _this.poolSize = Array.isArray(config.poolSize) ? config.poolSize : [config.poolSize, config.poolSize];
                    _this.strides = config.strides == null ? _this.poolSize : config.strides;
                    _this.padding = config.padding == null ? "valid" : config.padding;
                    _this.dataFormat = config.dataFormat == null ? "channelsLast" : config.dataFormat;
                    common_2.checkDataFormat(_this.dataFormat);
                    common_2.checkPaddingMode(_this.padding);
                    _this.inputSpec = [new topology_1.InputSpec({ndim: 4})];
                    return _this
                }

                Pooling2D.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
                    var cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
                    rows = conv_utils_1.convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);
                    cols = conv_utils_1.convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);
                    if (this.dataFormat === "channelsFirst") {
                        return [inputShape[0], inputShape[1], rows, cols]
                    } else {
                        return [inputShape[0], rows, cols, inputShape[3]]
                    }
                };
                Pooling2D.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        _this.invokeCallHook(inputs, kwargs);
                        return _this.poolingFunction(generic_utils.getExactlyOneTensor(inputs), _this.poolSize, _this.strides, _this.padding, _this.dataFormat)
                    })
                };
                Pooling2D.prototype.getConfig = function () {
                    var config = {
                        poolSize: this.poolSize,
                        padding: this.padding,
                        strides: this.strides,
                        dataFormat: this.dataFormat
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                return Pooling2D
            }(topology_2.Layer);
            exports.Pooling2D = Pooling2D;
            var MaxPooling2D = function (_super) {
                __extends(MaxPooling2D, _super);

                function MaxPooling2D(config) {
                    return _super.call(this, config) || this
                }

                MaxPooling2D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
                    common_2.checkDataFormat(dataFormat);
                    common_2.checkPaddingMode(padding);
                    return pool2d(inputs, poolSize, strides, padding, dataFormat, "max")
                };
                MaxPooling2D.className = "MaxPooling2D";
                return MaxPooling2D
            }(Pooling2D);
            exports.MaxPooling2D = MaxPooling2D;
            tfjs_core_1.serialization.SerializationMap.register(MaxPooling2D);
            var AveragePooling2D = function (_super) {
                __extends(AveragePooling2D, _super);

                function AveragePooling2D(config) {
                    return _super.call(this, config) || this
                }

                AveragePooling2D.prototype.poolingFunction = function (inputs, poolSize, strides, padding, dataFormat) {
                    common_2.checkDataFormat(dataFormat);
                    common_2.checkPaddingMode(padding);
                    return pool2d(inputs, poolSize, strides, padding, dataFormat, "avg")
                };
                AveragePooling2D.className = "AveragePooling2D";
                return AveragePooling2D
            }(Pooling2D);
            exports.AveragePooling2D = AveragePooling2D;
            tfjs_core_1.serialization.SerializationMap.register(AveragePooling2D);
            var GlobalPooling1D = function (_super) {
                __extends(GlobalPooling1D, _super);

                function GlobalPooling1D(config) {
                    var _this = _super.call(this, config) || this;
                    _this.inputSpec = [new topology_1.InputSpec({ndim: 3})];
                    return _this
                }

                GlobalPooling1D.prototype.computeOutputShape = function (inputShape) {
                    return [inputShape[0], inputShape[2]]
                };
                GlobalPooling1D.prototype.call = function (inputs, kwargs) {
                    throw new errors_1.NotImplementedError
                };
                return GlobalPooling1D
            }(topology_2.Layer);
            exports.GlobalPooling1D = GlobalPooling1D;
            var GlobalAveragePooling1D = function (_super) {
                __extends(GlobalAveragePooling1D, _super);

                function GlobalAveragePooling1D(config) {
                    return _super.call(this, config) || this
                }

                GlobalAveragePooling1D.prototype.call = function (inputs, kwargs) {
                    return tfjs_core_1.tidy(function () {
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        return tfc.mean(input, 1)
                    })
                };
                GlobalAveragePooling1D.className = "GlobalAveragePooling1D";
                return GlobalAveragePooling1D
            }(GlobalPooling1D);
            exports.GlobalAveragePooling1D = GlobalAveragePooling1D;
            tfjs_core_1.serialization.SerializationMap.register(GlobalAveragePooling1D);
            var GlobalMaxPooling1D = function (_super) {
                __extends(GlobalMaxPooling1D, _super);

                function GlobalMaxPooling1D(config) {
                    return _super.call(this, config) || this
                }

                GlobalMaxPooling1D.prototype.call = function (inputs, kwargs) {
                    return tfjs_core_1.tidy(function () {
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        return tfc.max(input, 1)
                    })
                };
                GlobalMaxPooling1D.className = "GlobalMaxPooling1D";
                return GlobalMaxPooling1D
            }(GlobalPooling1D);
            exports.GlobalMaxPooling1D = GlobalMaxPooling1D;
            tfjs_core_1.serialization.SerializationMap.register(GlobalMaxPooling1D);
            var GlobalPooling2D = function (_super) {
                __extends(GlobalPooling2D, _super);

                function GlobalPooling2D(config) {
                    var _this = _super.call(this, config) || this;
                    _this.dataFormat = config.dataFormat == null ? "channelsLast" : config.dataFormat;
                    common_2.checkDataFormat(_this.dataFormat);
                    _this.inputSpec = [new topology_1.InputSpec({ndim: 4})];
                    return _this
                }

                GlobalPooling2D.prototype.computeOutputShape = function (inputShape) {
                    inputShape = inputShape;
                    if (this.dataFormat === "channelsLast") {
                        return [inputShape[0], inputShape[3]]
                    } else {
                        return [inputShape[0], inputShape[1]]
                    }
                };
                GlobalPooling2D.prototype.call = function (inputs, kwargs) {
                    throw new errors_1.NotImplementedError
                };
                GlobalPooling2D.prototype.getConfig = function () {
                    var config = {dataFormat: this.dataFormat};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                return GlobalPooling2D
            }(topology_2.Layer);
            exports.GlobalPooling2D = GlobalPooling2D;
            var GlobalAveragePooling2D = function (_super) {
                __extends(GlobalAveragePooling2D, _super);

                function GlobalAveragePooling2D() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                GlobalAveragePooling2D.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        if (_this.dataFormat === "channelsLast") {
                            return tfc.mean(input, [1, 2])
                        } else {
                            return tfc.mean(input, [2, 3])
                        }
                    })
                };
                GlobalAveragePooling2D.className = "GlobalAveragePooling2D";
                return GlobalAveragePooling2D
            }(GlobalPooling2D);
            exports.GlobalAveragePooling2D = GlobalAveragePooling2D;
            tfjs_core_1.serialization.SerializationMap.register(GlobalAveragePooling2D);
            var GlobalMaxPooling2D = function (_super) {
                __extends(GlobalMaxPooling2D, _super);

                function GlobalMaxPooling2D() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                GlobalMaxPooling2D.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var input = generic_utils.getExactlyOneTensor(inputs);
                        if (_this.dataFormat === "channelsLast") {
                            return tfc.max(input, [1, 2])
                        } else {
                            return tfc.max(input, [2, 3])
                        }
                    })
                };
                GlobalMaxPooling2D.className = "GlobalMaxPooling2D";
                return GlobalMaxPooling2D
            }(GlobalPooling2D);
            exports.GlobalMaxPooling2D = GlobalMaxPooling2D;
            tfjs_core_1.serialization.SerializationMap.register(GlobalMaxPooling2D)
        }, {
            "../backend/common": 157,
            "../backend/tfjs_backend": 158,
            "../common": 160,
            "../engine/topology": 163,
            "../errors": 165,
            "../utils/conv_utils": 187,
            "../utils/generic_utils": 188,
            "./convolutional": 170,
            "@tensorflow/tfjs-core": 50
        }],
        178: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var activations_1 = require("../activations");
            var K = require("../backend/tfjs_backend");
            var constraints_1 = require("../constraints");
            var topology_1 = require("../engine/topology");
            var topology_2 = require("../engine/topology");
            var errors_1 = require("../errors");
            var initializers_1 = require("../initializers");
            var regularizers_1 = require("../regularizers");
            var types_1 = require("../types");
            var generic_utils = require("../utils/generic_utils");
            var math_utils = require("../utils/math_utils");
            var variables_1 = require("../variables");
            var serialization_1 = require("./serialization");

            function rnn(stepFunction, inputs, initialStates, goBackwards, mask, constants, unroll, inputLength) {
                if (goBackwards === void 0) {
                    goBackwards = false
                }
                if (unroll === void 0) {
                    unroll = false
                }
                var ndim = inputs.shape.length;
                if (ndim < 3) {
                    throw new errors_1.ValueError("Input should be at least 3D, but is " + ndim + "D.")
                }
                var axes = [1, 0].concat(math_utils.range(2, ndim));
                inputs = tfc.transpose(inputs, axes);
                if (mask != null) {
                    throw new errors_1.NotImplementedError("The rnn() function of the deeplearn.js backend does not support " + "masking yet.")
                }
                if (constants != null) {
                    throw new errors_1.NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support " + "constants yet.")
                }
                if (unroll) {
                    console.warn("Backend rnn(): the unroll = true option is not applicable to the " + "imperative deeplearn.js backend.")
                }
                if (goBackwards) {
                    inputs = tfc.reverse(inputs, 0)
                }
                var outputs;
                var lastOutput;
                var states = initialStates;
                var timeSteps = inputs.shape[0];
                for (var t = 0; t < timeSteps; ++t) {
                    var currentInput = K.sliceAlongFirstAxis(inputs, t, 1);
                    currentInput = currentInput.reshape(currentInput.shape.slice(1));
                    var stepOutputs = stepFunction(currentInput, states);
                    lastOutput = stepOutputs[0];
                    if (t === 0) {
                        outputs = lastOutput.reshape([1].concat(lastOutput.shape))
                    } else {
                        outputs = K.concatAlongFirstAxis(outputs, lastOutput.reshape([1].concat(lastOutput.shape)))
                    }
                    states = stepOutputs[1]
                }
                return [lastOutput, tfc.transpose(outputs, [1, 0].concat(math_utils.range(2, outputs.shape.length))), states]
            }

            exports.rnn = rnn;
            var RNN = function (_super) {
                __extends(RNN, _super);

                function RNN(config) {
                    var _this = _super.call(this, config) || this;
                    var cell;
                    if (config.cell == null) {
                        throw new errors_1.ValueError("cell property is missing for the constructor of RNN.")
                    } else if (Array.isArray(config.cell)) {
                        cell = new StackedRNNCells({cells: config.cell})
                    } else {
                        cell = config.cell
                    }
                    if (cell.stateSize == null) {
                        throw new errors_1.ValueError("The RNN cell should have an attribute `stateSize` (tuple of " + "integers, one integer per RNN state).")
                    }
                    _this.cell = cell;
                    _this.returnSequences = config.returnSequences == null ? false : config.returnSequences;
                    _this.returnState = config.returnState == null ? false : config.returnState;
                    _this.goBackwards = config.goBackwards == null ? false : config.goBackwards;
                    _this._stateful = config.stateful == null ? false : config.stateful;
                    _this.unroll = config.unroll == null ? false : config.unroll;
                    _this.supportsMasking = true;
                    _this.inputSpec = [new topology_1.InputSpec({ndim: 3})];
                    _this.stateSpec = null;
                    _this.states = null;
                    _this.numConstants = null;
                    return _this
                }

                RNN.prototype.getStates = function () {
                    if (this.states == null) {
                        var numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
                        return math_utils.range(0, numStates).map(function (x) {
                            return null
                        })
                    } else {
                        return this.states
                    }
                };
                RNN.prototype.setStates = function (states) {
                    this.states = states
                };
                RNN.prototype.computeOutputShape = function (inputShape) {
                    if (generic_utils.isArrayOfShapes(inputShape)) {
                        inputShape = inputShape[0]
                    }
                    inputShape = inputShape;
                    var stateSize = this.cell.stateSize;
                    if (!Array.isArray(stateSize)) {
                        stateSize = [stateSize]
                    }
                    var outputDim = stateSize[0];
                    var outputShape;
                    if (this.returnSequences) {
                        outputShape = [inputShape[0], inputShape[1], outputDim]
                    } else {
                        outputShape = [inputShape[0], outputDim]
                    }
                    if (this.returnState) {
                        var stateShape = [];
                        for (var _i = 0, stateSize_1 = stateSize; _i < stateSize_1.length; _i++) {
                            var dim = stateSize_1[_i];
                            stateShape.push([inputShape[0], dim])
                        }
                        return [outputShape].concat(stateShape)
                    } else {
                        return outputShape
                    }
                };
                RNN.prototype.computeMask = function (inputs, mask) {
                    throw new errors_1.NotImplementedError("computeMask has not been implemented for RNN yet")
                };
                RNN.prototype.build = function (inputShape) {
                    var constantShape = null;
                    if (this.numConstants != null) {
                        throw new errors_1.NotImplementedError("Constants support is not implemented in RNN yet.")
                    }
                    if (generic_utils.isArrayOfShapes(inputShape)) {
                        inputShape = inputShape[0]
                    }
                    inputShape = inputShape;
                    var batchSize = this.stateful ? inputShape[0] : null;
                    var inputDim = inputShape[inputShape.length - 1];
                    this.inputSpec[0] = new topology_1.InputSpec({shape: [batchSize, null, inputDim]});
                    var stepInputShape = [inputShape[0]].concat(inputShape.slice(2));
                    if (constantShape != null) {
                        throw new errors_1.NotImplementedError("Constants support is not implemented in RNN yet.")
                    } else {
                        this.cell.build(stepInputShape)
                    }
                    var stateSize;
                    if (Array.isArray(this.cell.stateSize)) {
                        stateSize = this.cell.stateSize
                    } else {
                        stateSize = [this.cell.stateSize]
                    }
                    if (this.stateSpec != null) {
                        if (!tfjs_core_1.util.arraysEqual(this.stateSpec.map(function (spec) {
                            return spec.shape[spec.shape.length - 1]
                        }), stateSize)) {
                            throw new errors_1.ValueError("An initialState was passed that is not compatible with " + ("cell.stateSize. Received stateSpec=" + this.stateSpec + "; ") + ("However cell.stateSize is " + this.cell.stateSize))
                        }
                    } else {
                        this.stateSpec = stateSize.map(function (dim) {
                            return new topology_1.InputSpec({shape: [null, dim]})
                        })
                    }
                    if (this.stateful) {
                        throw new errors_1.NotImplementedError("stateful RNN layer is not implemented yet")
                    }
                };
                RNN.prototype.resetStates = function (states) {
                    var _this = this;
                    tfjs_core_1.tidy(function () {
                        if (!_this.stateful) {
                            throw new errors_1.AttributeError("Cannot call resetState() on an RNN Layer that is not stateful.")
                        }
                        var batchSize = _this.inputSpec[0].shape[0];
                        if (batchSize == null) {
                            throw new errors_1.ValueError("If an RNN is stateful, it needs to know its batch size. Specify " + "the batch size of your input tensors: \n" + "- If using a Sequential model, specify the batch size by " + "passing a `batchInputShape` option to your first layer.\n" + "- If using the functional API, specify the batch size by " + "passing a `batchShape` option to your Input layer.")
                        }
                        if (_this.states == null) {
                            if (Array.isArray(_this.cell.stateSize)) {
                                _this.states = _this.cell.stateSize.map(function (dim) {
                                    return tfc.zeros([batchSize, dim])
                                })
                            } else {
                                _this.states = [tfc.zeros([batchSize, _this.cell.stateSize])]
                            }
                        } else if (states == null) {
                            if (Array.isArray(_this.cell.stateSize)) {
                                _this.states = _this.cell.stateSize.map(function (dim) {
                                    return tfc.zeros([batchSize, dim])
                                })
                            } else {
                                _this.states[0] = tfc.zeros([batchSize, _this.cell.stateSize])
                            }
                        } else {
                            if (!Array.isArray(states)) {
                                states = [states]
                            }
                            if (states.length !== _this.states.length) {
                                throw new errors_1.ValueError("Layer " + _this.name + " expects " + _this.states.length + " state(s), " + ("but it received " + states.length + " state value(s). Input ") + ("received: " + states))
                            }
                            for (var index = 0; index < _this.states.length; ++index) {
                                var value = states[index];
                                var dim = Array.isArray(_this.cell.stateSize) ? _this.cell.stateSize[index] : _this.cell.stateSize;
                                var expectedShape = [batchSize, dim];
                                if (!tfjs_core_1.util.arraysEqual(value.shape, expectedShape)) {
                                    throw new errors_1.ValueError("State " + index + " is incompatible with layer " + _this.name + ": " + ("expected shape=" + expectedShape + ", received shape=" + value.shape))
                                }
                                _this.states[index] = value
                            }
                        }
                    })
                };
                RNN.prototype.standardizeArgs = function (inputs, initialState, constants) {
                    if (Array.isArray(inputs)) {
                        if (initialState != null || constants != null) {
                            throw new errors_1.ValueError("When inputs is an array, neither initialState or constants " + "should be provided")
                        }
                        if (this.numConstants != null) {
                            constants = inputs.slice(inputs.length - this.numConstants, inputs.length);
                            inputs = inputs.slice(0, inputs.length - this.numConstants)
                        }
                        if (inputs.length > 1) {
                            initialState = inputs.slice(1, inputs.length)
                        }
                        inputs = inputs[0]
                    }

                    function toListOrNull(x) {
                        if (x == null || Array.isArray(x)) {
                            return x
                        } else {
                            return [x]
                        }
                    }

                    initialState = toListOrNull(initialState);
                    constants = toListOrNull(constants);
                    return {inputs: inputs, initialState: initialState, constants: constants}
                };
                RNN.prototype.apply = function (inputs, kwargs) {
                    var initialState = kwargs == null ? null : kwargs["initialState"];
                    var constants = kwargs == null ? null : kwargs["constants"];
                    if (kwargs == null) {
                        kwargs = {}
                    }
                    var standardized = this.standardizeArgs(inputs, initialState, constants);
                    inputs = standardized.inputs;
                    initialState = standardized.initialState;
                    constants = standardized.constants;
                    var additionalInputs = [];
                    var additionalSpecs = [];
                    if (initialState != null) {
                        kwargs["initialState"] = initialState;
                        additionalInputs = additionalInputs.concat(initialState);
                        this.stateSpec = [];
                        for (var _i = 0, initialState_1 = initialState; _i < initialState_1.length; _i++) {
                            var state = initialState_1[_i];
                            this.stateSpec.push(new topology_1.InputSpec({shape: state.shape}))
                        }
                        additionalSpecs = additionalSpecs.concat(this.stateSpec)
                    }
                    if (constants != null) {
                        kwargs["constants"] = constants;
                        additionalInputs = additionalInputs.concat(constants);
                        this.numConstants = constants.length
                    }
                    var isTensor = additionalInputs[0] instanceof types_1.SymbolicTensor;
                    if (isTensor) {
                        var fullInput = [inputs].concat(additionalInputs);
                        var fullInputSpec = this.inputSpec.concat(additionalSpecs);
                        var originalInputSpec = this.inputSpec;
                        this.inputSpec = fullInputSpec;
                        var output = _super.prototype.apply.call(this, fullInput, kwargs);
                        this.inputSpec = originalInputSpec;
                        return output
                    } else {
                        return _super.prototype.apply.call(this, inputs, kwargs)
                    }
                };
                RNN.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var mask = kwargs == null ? null : kwargs["mask"];
                        var training = kwargs == null ? null : kwargs["training"];
                        var initialState = kwargs == null ? null : kwargs["initialState"];
                        inputs = generic_utils.getExactlyOneTensor(inputs);
                        if (initialState == null) {
                            if (_this.stateful) {
                                throw new errors_1.NotImplementedError("stateful RNN layer is not implemented yet.")
                            } else {
                                initialState = _this.getInitialState(inputs)
                            }
                        }
                        if (mask != null) {
                            throw new errors_1.NotImplementedError("Masking is not implemented for RNN yet")
                        }
                        var numStates = Array.isArray(_this.cell.stateSize) ? _this.cell.stateSize.length : 1;
                        if (initialState.length !== numStates) {
                            throw new errors_1.ValueError("RNN Layer has " + numStates + " state(s) but was passed " + (initialState.length + " initial state(s)."))
                        }
                        var inputShape = inputs.shape;
                        var timesteps = inputShape[1];
                        if (_this.unroll) {
                            console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.")
                        }
                        var cellCallKwargs = {training: training};
                        var step = function (inputs, states) {
                            var outputs = _this.cell.call([inputs].concat(states), cellCallKwargs);
                            return [outputs[0], outputs.slice(1)]
                        };
                        var rnnOutputs = rnn(step, inputs, initialState, _this.goBackwards, null, null, _this.unroll, timesteps);
                        var lastOutput = rnnOutputs[0];
                        var outputs = rnnOutputs[1];
                        var states = rnnOutputs[2];
                        if (_this.stateful) {
                            throw new errors_1.NotImplementedError("stateful RNN layer is not implemented yet")
                        }
                        var output = _this.returnSequences ? outputs : lastOutput;
                        if (_this.returnState) {
                            return [output].concat(states)
                        } else {
                            return output
                        }
                    })
                };
                RNN.prototype.getInitialState = function (inputs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var initialState = tfc.zeros(inputs.shape);
                        initialState = tfc.sum(initialState, [1, 2]);
                        initialState = K.expandDims(initialState);
                        if (Array.isArray(_this.cell.stateSize)) {
                            return _this.cell.stateSize.map(function (dim) {
                                return dim > 1 ? K.tile(initialState, [1, dim]) : initialState
                            })
                        } else {
                            return _this.cell.stateSize > 1 ? [K.tile(initialState, [1, _this.cell.stateSize])] : [initialState]
                        }
                    })
                };
                Object.defineProperty(RNN.prototype, "trainableWeights", {
                    get: function () {
                        if (!this.trainable) {
                            return []
                        }
                        return this.cell.trainableWeights
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(RNN.prototype, "nonTrainableWeights", {
                    get: function () {
                        if (!this.trainable) {
                            return this.cell.weights
                        }
                        return this.cell.nonTrainableWeights
                    }, enumerable: true, configurable: true
                });
                RNN.prototype.getConfig = function () {
                    var config = {
                        returnSequences: this.returnSequences,
                        returnState: this.returnState,
                        goBackwards: this.goBackwards,
                        stateful: this.stateful,
                        unroll: this.unroll
                    };
                    if (this.numConstants != null) {
                        config.numConstants = this.numConstants
                    }
                    var cellConfig = this.cell.getConfig();
                    config.cell = {className: this.cell.getClassName(), config: cellConfig};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                RNN.className = "RNN";
                return RNN
            }(topology_2.Layer);
            exports.RNN = RNN;
            tfjs_core_1.serialization.SerializationMap.register(RNN);
            var RNNCell = function (_super) {
                __extends(RNNCell, _super);

                function RNNCell() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                RNNCell = __decorate([tfjs_core_1.doc({heading: "Layers", subheading: "Classes"})], RNNCell);
                return RNNCell
            }(topology_2.Layer);
            exports.RNNCell = RNNCell;
            var SimpleRNNCell = function (_super) {
                __extends(SimpleRNNCell, _super);

                function SimpleRNNCell(config) {
                    var _this = _super.call(this, config) || this;
                    _this.DEFAULT_ACTIVATION = "tanh";
                    _this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
                    _this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
                    _this.DEFAULT_BIAS_INITIALIZER = "zeros";
                    _this.units = config.units;
                    _this.activation = activations_1.getActivation(config.activation == null ? _this.DEFAULT_ACTIVATION : config.activation);
                    _this.useBias = config.useBias == null ? true : config.useBias;
                    _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
                    _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
                    _this.biasInitializer = initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
                    _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
                    _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
                    _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
                    _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
                    _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
                    _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
                    _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
                    _this.recurrentDropout = math_utils.min([1, math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])]);
                    _this.stateSize = _this.units;
                    return _this
                }

                SimpleRNNCell.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    this.kernel = this.addWeight("kernel", [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
                    this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
                    if (this.useBias) {
                        this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)
                    } else {
                        this.bias = null
                    }
                    this.built = true
                };
                SimpleRNNCell.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = inputs;
                        if (inputs.length !== 2) {
                            throw new errors_1.ValueError("SimpleRNNCell expects 2 input Tensors, got " + inputs.length + ".")
                        }
                        var prevOutput = inputs[1];
                        inputs = inputs[0];
                        if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                            throw new errors_1.NotImplementedError("Dropout is not implemented for SimpleRNNCell yet")
                        }
                        var h = K.dot(inputs, _this.kernel.read());
                        if (_this.bias != null) {
                            h = K.biasAdd(h, _this.bias.read())
                        }
                        var output = tfc.add(h, K.dot(prevOutput, _this.recurrentKernel.read()));
                        if (_this.activation != null) {
                            output = _this.activation.apply(output)
                        }
                        return [output, output]
                    })
                };
                SimpleRNNCell.prototype.getConfig = function () {
                    var config = {
                        units: this.units,
                        activation: activations_1.serializeActivation(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
                        recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
                        biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
                        kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
                        recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
                        biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
                        recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
                        biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                SimpleRNNCell.className = "SimpleRNNCell";
                return SimpleRNNCell
            }(RNNCell);
            exports.SimpleRNNCell = SimpleRNNCell;
            tfjs_core_1.serialization.SerializationMap.register(SimpleRNNCell);
            var SimpleRNN = function (_super) {
                __extends(SimpleRNN, _super);

                function SimpleRNN(config) {
                    var _this = this;
                    config.cell = new SimpleRNNCell(config);
                    _this = _super.call(this, config) || this;
                    return _this
                }

                SimpleRNN.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var mask = kwargs == null ? null : kwargs["mask"];
                        var training = kwargs == null ? null : kwargs["training"];
                        var initialState = kwargs == null ? null : kwargs["initialState"];
                        return _super.prototype.call.call(_this, inputs, {
                            mask: mask,
                            training: training,
                            initialState: initialState
                        })
                    })
                };
                Object.defineProperty(SimpleRNN.prototype, "units", {
                    get: function () {
                        return this.cell.units
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "activation", {
                    get: function () {
                        return this.cell.activation
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "useBias", {
                    get: function () {
                        return this.cell.useBias
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "kernelInitializer", {
                    get: function () {
                        return this.cell.kernelInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "recurrentInitializer", {
                    get: function () {
                        return this.cell.recurrentInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "biasInitializer", {
                    get: function () {
                        return this.cell.biasInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "kernelRegularizer", {
                    get: function () {
                        return this.cell.kernelRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "recurrentRegularizer", {
                    get: function () {
                        return this.cell.recurrentRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "biasRegularizer", {
                    get: function () {
                        return this.cell.biasRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "kernelConstraint", {
                    get: function () {
                        return this.cell.kernelConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "recurrentConstraint", {
                    get: function () {
                        return this.cell.recurrentConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "biasConstraint", {
                    get: function () {
                        return this.cell.biasConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "dropout", {
                    get: function () {
                        return this.cell.dropout
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(SimpleRNN.prototype, "recurrentDropout", {
                    get: function () {
                        return this.cell.recurrentDropout
                    }, enumerable: true, configurable: true
                });
                SimpleRNN.prototype.getConfig = function () {
                    var config = {
                        units: this.units,
                        activation: activations_1.serializeActivation(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
                        recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
                        biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
                        kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
                        recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
                        biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
                        recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
                        biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    delete baseConfig["cell"];
                    Object.assign(config, baseConfig);
                    return config
                };
                SimpleRNN.className = "SimpleRNN";
                return SimpleRNN
            }(RNN);
            exports.SimpleRNN = SimpleRNN;
            tfjs_core_1.serialization.SerializationMap.register(SimpleRNN);
            var GRUCell = function (_super) {
                __extends(GRUCell, _super);

                function GRUCell(config) {
                    var _this = _super.call(this, config) || this;
                    _this.DEFAULT_ACTIVATION = "tanh";
                    _this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
                    _this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
                    _this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
                    _this.DEFAULT_BIAS_INITIALIZER = "zeros";
                    _this.units = config.units;
                    _this.activation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_ACTIVATION : config.activation);
                    _this.recurrentActivation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_RECURRENT_ACTIVATION : config.recurrentActivation);
                    _this.useBias = config.useBias == null ? true : config.useBias;
                    _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
                    _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
                    _this.biasInitializer = initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
                    _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
                    _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
                    _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
                    _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
                    _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
                    _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
                    _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
                    _this.recurrentDropout = math_utils.min([1, math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])]);
                    _this.implementation = config.implementation;
                    _this.stateSize = _this.units;
                    return _this
                }

                GRUCell.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var inputDim = inputShape[inputShape.length - 1];
                    this.kernel = this.addWeight("kernel", [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
                    this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
                    if (this.useBias) {
                        this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)
                    } else {
                        this.bias = null
                    }
                    this.built = true
                };
                GRUCell.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                            throw new errors_1.NotImplementedError("Dropout is not implemented for GRUCell yet")
                        }
                        inputs = inputs;
                        if (inputs.length !== 2) {
                            throw new errors_1.ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got " + (inputs.length + "."))
                        }
                        var hTMinus1 = inputs[1];
                        inputs = inputs[0];
                        var z;
                        var r;
                        var hh;
                        if (_this.implementation === 1) {
                            var kernelZ = K.sliceAlongLastAxis(_this.kernel.read(), 0, _this.units);
                            var kernelR = K.sliceAlongLastAxis(_this.kernel.read(), _this.units, _this.units);
                            var kernelH = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 2, _this.units);
                            var recurrentKernelZ = K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, _this.units);
                            var recurrentKernelR = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units, _this.units);
                            var recurrentKernelH = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 2, _this.units);
                            var inputsZ = inputs;
                            var inputsR = inputs;
                            var inputsH = inputs;
                            var xZ = K.dot(inputsZ, kernelZ);
                            var xR = K.dot(inputsR, kernelR);
                            var xH = K.dot(inputsH, kernelH);
                            if (_this.useBias) {
                                var biasZ = K.sliceAlongFirstAxis(_this.bias.read(), 0, _this.units);
                                var biasR = K.sliceAlongFirstAxis(_this.bias.read(), _this.units, _this.units);
                                var biasH = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 2, _this.units);
                                xZ = K.biasAdd(xZ, biasZ);
                                xR = K.biasAdd(xR, biasR);
                                xH = K.biasAdd(xH, biasH)
                            }
                            var hTMinus1Z = hTMinus1;
                            var hTMinus1R = hTMinus1;
                            var hTMinus1H = hTMinus1;
                            z = _this.recurrentActivation.apply(tfc.add(xZ, K.dot(hTMinus1Z, recurrentKernelZ)));
                            r = _this.recurrentActivation.apply(tfc.add(xR, K.dot(hTMinus1R, recurrentKernelR)));
                            hh = _this.activation.apply(tfc.add(xH, K.dot(tfc.mul(r, hTMinus1H), recurrentKernelH)))
                        } else {
                            var matrixX = K.dot(inputs, _this.kernel.read());
                            if (_this.useBias) {
                                matrixX = K.biasAdd(matrixX, _this.bias.read())
                            }
                            var matrixInner = K.dot(hTMinus1, K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, 2 * _this.units));
                            var xZ = K.sliceAlongLastAxis(matrixX, 0, _this.units);
                            var xR = K.sliceAlongLastAxis(matrixX, _this.units, _this.units);
                            var recurrentZ = K.sliceAlongLastAxis(matrixInner, 0, _this.units);
                            var recurrentR = K.sliceAlongLastAxis(matrixInner, _this.units, _this.units);
                            z = _this.recurrentActivation.apply(tfc.add(xZ, recurrentZ));
                            r = _this.recurrentActivation.apply(tfc.add(xR, recurrentR));
                            var xH = K.sliceAlongLastAxis(matrixX, 2 * _this.units, _this.units);
                            var recurrentH = K.dot(tfc.mul(r, hTMinus1), K.sliceAlongLastAxis(_this.recurrentKernel.read(), 2 * _this.units, _this.units));
                            hh = _this.activation.apply(tfc.add(xH, recurrentH))
                        }
                        var h = tfc.add(tfc.mul(z, hTMinus1), tfc.mul(K.scalarPlusArray(K.getScalar(1), tfc.neg(z)), hh));
                        return [h, h]
                    })
                };
                GRUCell.prototype.getConfig = function () {
                    var config = {
                        units: this.units,
                        activation: activations_1.serializeActivation(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
                        recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
                        biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
                        kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
                        recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
                        biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
                        recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
                        biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout,
                        implementation: this.implementation
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                GRUCell.className = "GRUCell";
                return GRUCell
            }(RNNCell);
            exports.GRUCell = GRUCell;
            tfjs_core_1.serialization.SerializationMap.register(GRUCell);
            var GRU = function (_super) {
                __extends(GRU, _super);

                function GRU(config) {
                    var _this = this;
                    if (config.implementation === 0) {
                        console.warn("`implementation=0` has been deprecated, and now defaults to " + "`implementation=1`. Please update your layer call.")
                    }
                    config.cell = new GRUCell(config);
                    _this = _super.call(this, config) || this;
                    return _this
                }

                GRU.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var mask = kwargs == null ? null : kwargs["mask"];
                        var training = kwargs == null ? null : kwargs["training"];
                        var initialState = kwargs == null ? null : kwargs["initialState"];
                        return _super.prototype.call.call(_this, inputs, {
                            mask: mask,
                            training: training,
                            initialState: initialState
                        })
                    })
                };
                Object.defineProperty(GRU.prototype, "units", {
                    get: function () {
                        return this.cell.units
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "activation", {
                    get: function () {
                        return this.cell.activation
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "useBias", {
                    get: function () {
                        return this.cell.useBias
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "kernelInitializer", {
                    get: function () {
                        return this.cell.kernelInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "recurrentInitializer", {
                    get: function () {
                        return this.cell.recurrentInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "biasInitializer", {
                    get: function () {
                        return this.cell.biasInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "kernelRegularizer", {
                    get: function () {
                        return this.cell.kernelRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "recurrentRegularizer", {
                    get: function () {
                        return this.cell.recurrentRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "biasRegularizer", {
                    get: function () {
                        return this.cell.biasRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "kernelConstraint", {
                    get: function () {
                        return this.cell.kernelConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "recurrentConstraint", {
                    get: function () {
                        return this.cell.recurrentConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "biasConstraint", {
                    get: function () {
                        return this.cell.biasConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "dropout", {
                    get: function () {
                        return this.cell.dropout
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "recurrentDropout", {
                    get: function () {
                        return this.cell.recurrentDropout
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(GRU.prototype, "implementation", {
                    get: function () {
                        return this.cell.implementation
                    }, enumerable: true, configurable: true
                });
                GRU.prototype.getConfig = function () {
                    var config = {
                        units: this.units,
                        activation: activations_1.serializeActivation(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
                        recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
                        biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
                        kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
                        recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
                        biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
                        recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
                        biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout,
                        implementation: this.implementation
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    delete baseConfig["cell"];
                    Object.assign(config, baseConfig);
                    return config
                };
                GRU.fromConfig = function (cls, config) {
                    if (config["implmentation"] === 0) {
                        config["implementation"] = 1
                    }
                    return new cls(config)
                };
                GRU.className = "GRU";
                return GRU
            }(RNN);
            exports.GRU = GRU;
            tfjs_core_1.serialization.SerializationMap.register(GRU);
            var LSTMCell = function (_super) {
                __extends(LSTMCell, _super);

                function LSTMCell(config) {
                    var _this = _super.call(this, config) || this;
                    _this.DEFAULT_ACTIVATION = "tanh";
                    _this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
                    _this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
                    _this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
                    _this.DEFAULT_BIAS_INITIALIZER = "zeros";
                    _this.units = config.units;
                    _this.activation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_ACTIVATION : config.activation);
                    _this.recurrentActivation = activations_1.getActivation(config.activation === undefined ? _this.DEFAULT_RECURRENT_ACTIVATION : config.recurrentActivation);
                    _this.useBias = config.useBias == null ? true : config.useBias;
                    _this.kernelInitializer = initializers_1.getInitializer(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);
                    _this.recurrentInitializer = initializers_1.getInitializer(config.recurrentInitializer || _this.DEFAULT_RECURRENT_INITIALIZER);
                    _this.biasInitializer = initializers_1.getInitializer(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);
                    _this.unitForgetBias = config.unitForgetBias;
                    _this.kernelRegularizer = regularizers_1.getRegularizer(config.kernelRegularizer);
                    _this.recurrentRegularizer = regularizers_1.getRegularizer(config.recurrentRegularizer);
                    _this.biasRegularizer = regularizers_1.getRegularizer(config.biasRegularizer);
                    _this.kernelConstraint = constraints_1.getConstraint(config.kernelConstraint);
                    _this.recurrentConstraint = constraints_1.getConstraint(config.recurrentConstraint);
                    _this.biasConstraint = constraints_1.getConstraint(config.biasConstraint);
                    _this.dropout = math_utils.min([1, math_utils.max([0, config.dropout == null ? 0 : config.dropout])]);
                    _this.recurrentDropout = math_utils.min([1, math_utils.max([0, config.recurrentDropout == null ? 0 : config.recurrentDropout])]);
                    _this.implementation = config.implementation;
                    _this.stateSize = [_this.units, _this.units];
                    return _this
                }

                LSTMCell.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var inputDim = inputShape[inputShape.length - 1];
                    this.kernel = this.addWeight("kernel", [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
                    this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
                    var biasInitializer;
                    if (this.useBias) {
                        if (this.unitForgetBias) {
                            var capturedBiasInit_1 = this.biasInitializer;
                            var capturedUnits_1 = this.units;
                            biasInitializer = new (_a = function (_super) {
                                __extends(CustomInit, _super);

                                function CustomInit() {
                                    return _super !== null && _super.apply(this, arguments) || this
                                }

                                CustomInit.prototype.apply = function (shape, dtype) {
                                    var bI = capturedBiasInit_1.apply([capturedUnits_1]);
                                    var bF = (new initializers_1.Ones).apply([capturedUnits_1]);
                                    var bCAndH = capturedBiasInit_1.apply([capturedUnits_1 * 2]);
                                    return K.concatAlongFirstAxis(K.concatAlongFirstAxis(bI, bF), bCAndH)
                                };
                                return CustomInit
                            }(initializers_1.Initializer), _a.className = "CustomInit", _a)
                        } else {
                            biasInitializer = this.biasInitializer
                        }
                        this.bias = this.addWeight("bias", [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint)
                    } else {
                        this.bias = null
                    }
                    this.built = true;
                    var _a
                };
                LSTMCell.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        if (_this.dropout !== 0 || _this.recurrentDropout !== 0) {
                            throw new errors_1.NotImplementedError("Dropout is not implemented for LSTMCell yet")
                        }
                        inputs = inputs;
                        if (inputs.length !== 3) {
                            throw new errors_1.ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got " + (inputs.length + "."))
                        }
                        var hTMinus1 = inputs[1];
                        var cTMinus1 = inputs[2];
                        inputs = inputs[0];
                        var i;
                        var f;
                        var c;
                        var o;
                        if (_this.implementation === 1) {
                            var kernelI = K.sliceAlongLastAxis(_this.kernel.read(), 0, _this.units);
                            var kernelF = K.sliceAlongLastAxis(_this.kernel.read(), _this.units, _this.units);
                            var kernelC = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 2, _this.units);
                            var kernelO = K.sliceAlongLastAxis(_this.kernel.read(), _this.units * 3, _this.units);
                            var recurrentKernelI = K.sliceAlongLastAxis(_this.recurrentKernel.read(), 0, _this.units);
                            var recurrentKernelF = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units, _this.units);
                            var recurrentKernelC = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 2, _this.units);
                            var recurrentKernelO = K.sliceAlongLastAxis(_this.recurrentKernel.read(), _this.units * 3, _this.units);
                            var inputsI = inputs;
                            var inputsF = inputs;
                            var inputsC = inputs;
                            var inputsO = inputs;
                            var xI = K.dot(inputsI, kernelI);
                            var xF = K.dot(inputsF, kernelF);
                            var xC = K.dot(inputsC, kernelC);
                            var xO = K.dot(inputsO, kernelO);
                            if (_this.useBias) {
                                var biasI = K.sliceAlongFirstAxis(_this.bias.read(), 0, _this.units);
                                var biasF = K.sliceAlongFirstAxis(_this.bias.read(), _this.units, _this.units);
                                var biasC = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 2, _this.units);
                                var biasO = K.sliceAlongFirstAxis(_this.bias.read(), _this.units * 3, _this.units);
                                xI = K.biasAdd(xI, biasI);
                                xF = K.biasAdd(xF, biasF);
                                xC = K.biasAdd(xC, biasC);
                                xO = K.biasAdd(xO, biasO)
                            }
                            var hTMinus1I = hTMinus1;
                            var hTMinus1F = hTMinus1;
                            var hTMinus1C = hTMinus1;
                            var hTMinus1O = hTMinus1;
                            i = _this.recurrentActivation.apply(tfc.add(xI, K.dot(hTMinus1I, recurrentKernelI)));
                            f = _this.recurrentActivation.apply(tfc.add(xF, K.dot(hTMinus1F, recurrentKernelF)));
                            c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(tfc.add(xC, K.dot(hTMinus1C, recurrentKernelC)))));
                            o = _this.recurrentActivation.apply(tfc.add(xO, K.dot(hTMinus1O, recurrentKernelO)))
                        } else {
                            var z = K.dot(inputs, _this.kernel.read());
                            z = tfc.add(z, K.dot(hTMinus1, _this.recurrentKernel.read()));
                            if (_this.useBias) {
                                z = K.biasAdd(z, _this.bias.read())
                            }
                            var z0 = K.sliceAlongLastAxis(z, 0, _this.units);
                            var z1 = K.sliceAlongLastAxis(z, _this.units, _this.units);
                            var z2 = K.sliceAlongLastAxis(z, _this.units * 2, _this.units);
                            var z3 = K.sliceAlongLastAxis(z, _this.units * 3, _this.units);
                            i = _this.recurrentActivation.apply(z0);
                            f = _this.recurrentActivation.apply(z1);
                            c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, _this.activation.apply(z2)));
                            o = _this.recurrentActivation.apply(z3)
                        }
                        var h = tfc.mul(o, _this.activation.apply(c));
                        return [h, h, c]
                    })
                };
                LSTMCell.prototype.getConfig = function () {
                    var config = {
                        units: this.units,
                        activation: activations_1.serializeActivation(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
                        recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
                        biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
                        unitForgetBias: this.unitForgetBias,
                        kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
                        recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
                        biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
                        recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
                        biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout,
                        implementation: this.implementation
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                LSTMCell.className = "LSTMCell";
                return LSTMCell
            }(RNNCell);
            exports.LSTMCell = LSTMCell;
            tfjs_core_1.serialization.SerializationMap.register(LSTMCell);
            var LSTM = function (_super) {
                __extends(LSTM, _super);

                function LSTM(config) {
                    var _this = this;
                    if (config.implementation === 0) {
                        console.warn("`implementation=0` has been deprecated, and now defaults to " + "`implementation=1`. Please update your layer call.")
                    }
                    config.cell = new LSTMCell(config);
                    _this = _super.call(this, config) || this;
                    return _this
                }

                LSTM.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var mask = kwargs == null ? null : kwargs["mask"];
                        var training = kwargs == null ? null : kwargs["training"];
                        var initialState = kwargs == null ? null : kwargs["initialState"];
                        return _super.prototype.call.call(_this, inputs, {
                            mask: mask,
                            training: training,
                            initialState: initialState
                        })
                    })
                };
                Object.defineProperty(LSTM.prototype, "units", {
                    get: function () {
                        return this.cell.units
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "activation", {
                    get: function () {
                        return this.cell.activation
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "useBias", {
                    get: function () {
                        return this.cell.useBias
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "kernelInitializer", {
                    get: function () {
                        return this.cell.kernelInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "recurrentInitializer", {
                    get: function () {
                        return this.cell.recurrentInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "biasInitializer", {
                    get: function () {
                        return this.cell.biasInitializer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "unitForgetBias", {
                    get: function () {
                        return this.cell.unitForgetBias
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "kernelRegularizer", {
                    get: function () {
                        return this.cell.kernelRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "recurrentRegularizer", {
                    get: function () {
                        return this.cell.recurrentRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "biasRegularizer", {
                    get: function () {
                        return this.cell.biasRegularizer
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "kernelConstraint", {
                    get: function () {
                        return this.cell.kernelConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "recurrentConstraint", {
                    get: function () {
                        return this.cell.recurrentConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "biasConstraint", {
                    get: function () {
                        return this.cell.biasConstraint
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "dropout", {
                    get: function () {
                        return this.cell.dropout
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "recurrentDropout", {
                    get: function () {
                        return this.cell.recurrentDropout
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(LSTM.prototype, "implementation", {
                    get: function () {
                        return this.cell.implementation
                    }, enumerable: true, configurable: true
                });
                LSTM.prototype.getConfig = function () {
                    var config = {
                        units: this.units,
                        activation: activations_1.serializeActivation(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: initializers_1.serializeInitializer(this.kernelInitializer),
                        recurrentInitializer: initializers_1.serializeInitializer(this.recurrentInitializer),
                        biasInitializer: initializers_1.serializeInitializer(this.biasInitializer),
                        unitForgetBias: this.unitForgetBias,
                        kernelRegularizer: regularizers_1.serializeRegularizer(this.kernelRegularizer),
                        recurrentRegularizer: regularizers_1.serializeRegularizer(this.recurrentRegularizer),
                        biasRegularizer: regularizers_1.serializeRegularizer(this.biasRegularizer),
                        activityRegularizer: regularizers_1.serializeRegularizer(this.activityRegularizer),
                        kernelConstraint: constraints_1.serializeConstraint(this.kernelConstraint),
                        recurrentConstraint: constraints_1.serializeConstraint(this.recurrentConstraint),
                        biasConstraint: constraints_1.serializeConstraint(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout,
                        implementation: this.implementation
                    };
                    var baseConfig = _super.prototype.getConfig.call(this);
                    delete baseConfig["cell"];
                    Object.assign(config, baseConfig);
                    return config
                };
                LSTM.fromConfig = function (cls, config) {
                    if (config["implmentation"] === 0) {
                        config["implementation"] = 1
                    }
                    return new cls(config)
                };
                LSTM.className = "LSTM";
                return LSTM
            }(RNN);
            exports.LSTM = LSTM;
            tfjs_core_1.serialization.SerializationMap.register(LSTM);
            var StackedRNNCells = function (_super) {
                __extends(StackedRNNCells, _super);

                function StackedRNNCells(config) {
                    var _this = _super.call(this, config) || this;
                    _this.cells = config.cells;
                    return _this
                }

                Object.defineProperty(StackedRNNCells.prototype, "stateSize", {
                    get: function () {
                        var stateSize = [];
                        for (var _i = 0, _a = this.cells.slice().reverse(); _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (Array.isArray(cell.stateSize)) {
                                stateSize.push.apply(stateSize, cell.stateSize)
                            } else {
                                stateSize.push(cell.stateSize)
                            }
                        }
                        return stateSize
                    }, enumerable: true, configurable: true
                });
                StackedRNNCells.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = inputs;
                        var states = inputs.slice(1);
                        var nestedStates = [];
                        for (var _i = 0, _a = _this.cells.slice().reverse(); _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (Array.isArray(cell.stateSize)) {
                                nestedStates.push(states.splice(0, cell.stateSize.length))
                            } else {
                                nestedStates.push(states.splice(0, 1))
                            }
                        }
                        nestedStates.reverse();
                        var newNestedStates = [];
                        var callInputs;
                        for (var i = 0; i < _this.cells.length; ++i) {
                            var cell = _this.cells[i];
                            states = nestedStates[i];
                            if (i === 0) {
                                callInputs = [inputs[0]].concat(states)
                            } else {
                                callInputs = [callInputs[0]].concat(states)
                            }
                            callInputs = cell.call(callInputs, kwargs);
                            newNestedStates.push(callInputs.slice(1))
                        }
                        states = [];
                        for (var _b = 0, _c = newNestedStates.slice().reverse(); _b < _c.length; _b++) {
                            var cellStates = _c[_b];
                            states.push.apply(states, cellStates)
                        }
                        return [callInputs[0]].concat(states)
                    })
                };
                StackedRNNCells.prototype.build = function (inputShape) {
                    if (generic_utils.isArrayOfShapes(inputShape)) {
                        inputShape = inputShape[0]
                    }
                    inputShape = inputShape;
                    var outputDim;
                    for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                        var cell = _a[_i];
                        cell.build(inputShape);
                        if (Array.isArray(cell.stateSize)) {
                            outputDim = cell.stateSize[0]
                        } else {
                            outputDim = cell.stateSize
                        }
                        inputShape = [inputShape[0], outputDim]
                    }
                    this.built = true
                };
                StackedRNNCells.prototype.getConfig = function () {
                    var cellConfigs = [];
                    for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                        var cell = _a[_i];
                        cellConfigs.push({className: this.getClassName(), config: cell.getConfig()})
                    }
                    var config = {cells: cellConfigs};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                StackedRNNCells.fromConfig = function (cls, config, customObjects) {
                    if (customObjects === void 0) {
                        customObjects = {}
                    }
                    var cells = [];
                    for (var _i = 0, _a = config["cells"]; _i < _a.length; _i++) {
                        var cellConfig = _a[_i];
                        cells.push(serialization_1.deserialize(cellConfig, customObjects))
                    }
                    return new cls({cells: cells})
                };
                Object.defineProperty(StackedRNNCells.prototype, "trainableWeights", {
                    get: function () {
                        if (!this.trainable) {
                            return []
                        }
                        var weights = [];
                        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            weights.push.apply(weights, cell.trainableWeights)
                        }
                        return weights
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(StackedRNNCells.prototype, "nonTrainableWeights", {
                    get: function () {
                        var weights = [];
                        for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            weights.push.apply(weights, cell.nonTrainableWeights)
                        }
                        if (!this.trainable) {
                            var trainableWeights = [];
                            for (var _b = 0, _c = this.cells; _b < _c.length; _b++) {
                                var cell = _c[_b];
                                trainableWeights.push.apply(trainableWeights, cell.trainableWeights)
                            }
                            return trainableWeights.concat(weights)
                        }
                        return weights
                    }, enumerable: true, configurable: true
                });
                StackedRNNCells.prototype.getWeights = function () {
                    var weights = [];
                    for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                        var cell = _a[_i];
                        weights.push.apply(weights, cell.weights)
                    }
                    return variables_1.batchGetValue(weights)
                };
                StackedRNNCells.prototype.setWeights = function (weights) {
                    var tuples = [];
                    for (var _i = 0, _a = this.cells; _i < _a.length; _i++) {
                        var cell = _a[_i];
                        var numParams = cell.weights.length;
                        var inputWeights = weights.splice(numParams);
                        for (var i = 0; i < cell.weights.length; ++i) {
                            tuples.push([cell.weights[i], inputWeights[i]])
                        }
                    }
                    variables_1.batchSetValue(tuples)
                };
                StackedRNNCells.className = "StackedRNNCells";
                return StackedRNNCells
            }(RNNCell);
            exports.StackedRNNCells = StackedRNNCells;
            tfjs_core_1.serialization.SerializationMap.register(StackedRNNCells)
        }, {
            "../activations": 156,
            "../backend/tfjs_backend": 158,
            "../constraints": 161,
            "../engine/topology": 163,
            "../errors": 165,
            "../initializers": 168,
            "../regularizers": 185,
            "../types": 186,
            "../utils/generic_utils": 188,
            "../utils/math_utils": 189,
            "../variables": 191,
            "./serialization": 179,
            "@tensorflow/tfjs-core": 50
        }],
        179: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var generic_utils_1 = require("../utils/generic_utils");

            function deserialize(config, customObjects) {
                if (customObjects === void 0) {
                    customObjects = {}
                }
                return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, "layer")
            }

            exports.deserialize = deserialize
        }, {"../utils/generic_utils": 188, "@tensorflow/tfjs-core": 50}],
        180: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("../backend/tfjs_backend");
            var topology_1 = require("../engine/topology");
            var errors_1 = require("../errors");
            var generic_utils = require("../utils/generic_utils");
            var recurrent_1 = require("./recurrent");
            var serialization_1 = require("./serialization");
            var Wrapper = function (_super) {
                __extends(Wrapper, _super);

                function Wrapper(config) {
                    var _this = _super.call(this, config) || this;
                    _this.layer = config.layer;
                    return _this
                }

                Wrapper.prototype.build = function (inputShape) {
                    this.built = true
                };
                Object.defineProperty(Wrapper.prototype, "trainable", {
                    get: function () {
                        if (this.layer != null) {
                            return this.layer.trainable
                        } else {
                            return false
                        }
                    }, set: function (value) {
                        if (this.layer != null) {
                            this.layer.trainable = value
                        }
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Wrapper.prototype, "trainableWeights", {
                    get: function () {
                        return this.layer.trainableWeights
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Wrapper.prototype, "nonTrainableWeights", {
                    get: function () {
                        return this.layer.nonTrainableWeights
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Wrapper.prototype, "updates", {
                    get: function () {
                        return this.layer._updates
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Wrapper.prototype, "losses", {
                    get: function () {
                        return this.layer.losses
                    }, enumerable: true, configurable: true
                });
                Wrapper.prototype.getWeights = function () {
                    return this.layer.getWeights()
                };
                Wrapper.prototype.setWeights = function (weights) {
                    this.layer.setWeights(weights)
                };
                Wrapper.prototype.getConfig = function () {
                    var config = {layer: {className: this.layer.getClassName(), config: this.layer.getConfig()}};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Wrapper.fromConfig = function (cls, config, customObjects) {
                    if (customObjects === void 0) {
                        customObjects = {}
                    }
                    var layerConfig = config["layer"];
                    var layer = serialization_1.deserialize(layerConfig, customObjects);
                    delete config["layer"];
                    var newConfig = {layer: layer};
                    Object.assign(newConfig, config);
                    return new cls(newConfig)
                };
                return Wrapper
            }(topology_1.Layer);
            exports.Wrapper = Wrapper;
            var TimeDistributed = function (_super) {
                __extends(TimeDistributed, _super);

                function TimeDistributed(config) {
                    var _this = _super.call(this, config) || this;
                    _this.supportsMasking = true;
                    return _this
                }

                TimeDistributed.prototype.build = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    if (inputShape.length < 3) {
                        throw new errors_1.ValueError("TimeDistributed layer expects an input shape >= 3D, but received " + ("input shape " + JSON.stringify(inputShape)))
                    }
                    this.inputSpec = [{shape: inputShape}];
                    var childInputShape = [inputShape[0]].concat(inputShape.slice(2));
                    if (!this.layer.built) {
                        this.layer.build(childInputShape);
                        this.layer.built = true
                    }
                    _super.prototype.build.call(this, inputShape)
                };
                TimeDistributed.prototype.computeOutputShape = function (inputShape) {
                    inputShape = generic_utils.getExactlyOneShape(inputShape);
                    var childInputShape = [inputShape[0]].concat(inputShape.slice(2));
                    var childOutputShape = this.layer.computeOutputShape(childInputShape);
                    var timesteps = inputShape[1];
                    return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1))
                };
                TimeDistributed.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        inputs = generic_utils.getExactlyOneTensor(inputs);
                        var step = function (inputs, states) {
                            var output = _this.layer.call(inputs, kwargs);
                            return [output, []]
                        };
                        var rnnOutputs = recurrent_1.rnn(step, inputs, [], false, null, null, false, inputs.shape[1]);
                        var y = rnnOutputs[1];
                        return y
                    })
                };
                TimeDistributed.className = "TimeDistributed";
                return TimeDistributed
            }(Wrapper);
            exports.TimeDistributed = TimeDistributed;
            tfjs_core_1.serialization.SerializationMap.register(TimeDistributed);
            exports.VALID_BIDIRECTIONAL_MERGE_MODES = ["sum", "mul", "concat", "ave"];

            function checkBidirectionalMergeMode(value) {
                generic_utils.checkStringTypeUnionValue(exports.VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", value)
            }

            exports.checkBidirectionalMergeMode = checkBidirectionalMergeMode;
            var Bidirectional = function (_super) {
                __extends(Bidirectional, _super);

                function Bidirectional(config) {
                    var _this = _super.call(this, config) || this;
                    _this.forwardLayer = config.layer;
                    var layerConfig = config.layer.getConfig();
                    layerConfig["goBackwards"] = layerConfig["goBackwards"] === true ? false : true;
                    _this.backwardLayer = serialization_1.deserialize({
                        className: config.layer.getClassName(),
                        config: layerConfig
                    });
                    _this.forwardLayer.name = "forward_" + _this.forwardLayer.name;
                    _this.backwardLayer.name = "backward_" + _this.backwardLayer.name;
                    checkBidirectionalMergeMode(config.mergeMode);
                    _this.mergeMode = config.mergeMode;
                    if (config.weights) {
                        throw new errors_1.NotImplementedError("weights support is not implemented for Bidirectional layer yet.")
                    }
                    _this._stateful = config.layer.stateful;
                    _this.returnSequences = config.layer.returnSequences;
                    _this.returnState = config.layer.returnState;
                    _this.supportsMasking = true;
                    _this._trainable = true;
                    _this.inputSpec = config.layer.inputSpec;
                    return _this
                }

                Object.defineProperty(Bidirectional.prototype, "trainable", {
                    get: function () {
                        return this._trainable
                    }, set: function (value) {
                        this._trainable = value;
                        if (this.forwardLayer != null) {
                            this.forwardLayer.trainable = value
                        }
                        if (this.backwardLayer != null) {
                            this.backwardLayer.trainable = value
                        }
                    }, enumerable: true, configurable: true
                });
                Bidirectional.prototype.getWeights = function () {
                    return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())
                };
                Bidirectional.prototype.setWeights = function (weights) {
                    var numWeights = weights.length;
                    var numeightsOver2 = Math.floor(numWeights / 2);
                    this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));
                    this.backwardLayer.setWeights(weights.slice(numeightsOver2))
                };
                Bidirectional.prototype.computeOutputShape = function (inputShape) {
                    var layerShapes = this.forwardLayer.computeOutputShape(inputShape);
                    if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {
                        layerShapes = [layerShapes]
                    }
                    layerShapes = layerShapes;
                    var outputShape;
                    var outputShapes;
                    var stateShape;
                    if (this.returnState) {
                        stateShape = layerShapes.slice(1);
                        outputShape = layerShapes[0]
                    } else {
                        outputShape = layerShapes[0]
                    }
                    outputShape = outputShape;
                    if (this.mergeMode === "concat") {
                        outputShape[outputShape.length - 1] *= 2;
                        outputShapes = [outputShape]
                    } else if (this.mergeMode == null) {
                        outputShapes = [outputShape, outputShape.slice()]
                    } else {
                        outputShapes = [outputShape]
                    }
                    if (this.returnState) {
                        if (this.mergeMode == null) {
                            return outputShapes.concat(stateShape).concat(stateShape.slice())
                        }
                        return [outputShape].concat(stateShape).concat(stateShape.slice())
                    }
                    return generic_utils.singletonOrArray(outputShapes)
                };
                Bidirectional.prototype.apply = function (inputs, kwargs) {
                    var initialState = null;
                    if (kwargs != null) {
                        initialState = kwargs["initialState"]
                    }
                    if (Array.isArray(inputs)) {
                        initialState = inputs.slice(1);
                        inputs = inputs[0]
                    }
                    if (initialState == null || initialState.length === 0) {
                        var applyOutputs = _super.prototype.apply.call(this, inputs, kwargs);
                        return applyOutputs
                    } else {
                        throw new errors_1.NotImplementedError("The support for initial states is not implemented for " + "Bidirectional layers yet.")
                    }
                };
                Bidirectional.prototype.call = function (inputs, kwargs) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        if (kwargs["mask"] != null) {
                            throw new errors_1.NotImplementedError("The support for masking is not implemented for " + "Bidirectional layers yet.")
                        }
                        if (kwargs["initialState"] != null) {
                            throw new errors_1.NotImplementedError("The support for initial states is not implemented for " + "Bidirectional layers yet.")
                        }
                        var y = _this.forwardLayer.call(inputs, kwargs);
                        var yRev = _this.backwardLayer.call(inputs, kwargs);
                        var states;
                        if (_this.returnState) {
                            if (Array.isArray(y)) {
                                states = y.slice(1).concat(yRev.slice(1))
                            } else {
                            }
                            y = y[0];
                            yRev = yRev[0]
                        }
                        if (_this.returnSequences) {
                            yRev = tfc.reverse(yRev, 1)
                        }
                        var output;
                        if (_this.mergeMode === "concat") {
                            output = K.concatenate([y, yRev])
                        } else if (_this.mergeMode === "sum") {
                            output = tfc.add(y, yRev)
                        } else if (_this.mergeMode === "ave") {
                            output = K.scalarTimesArray(K.getScalar(.5), tfc.add(y, yRev))
                        } else if (_this.mergeMode === "mul") {
                            output = tfc.mul(y, yRev)
                        } else if (_this.mergeMode == null) {
                            output = [y, yRev]
                        }
                        if (_this.returnState) {
                            if (_this.mergeMode == null) {
                                return output.concat(states)
                            }
                            return [output].concat(states)
                        }
                        return output
                    })
                };
                Bidirectional.prototype.resetStates = function (states) {
                    this.forwardLayer.resetStates();
                    this.backwardLayer.resetStates()
                };
                Bidirectional.prototype.build = function (inputShape) {
                    var _this = this;
                    K.nameScope(this.forwardLayer.name, function () {
                        _this.forwardLayer.build(inputShape)
                    });
                    K.nameScope(this.backwardLayer.name, function () {
                        _this.backwardLayer.build(inputShape)
                    });
                    this.built = true
                };
                Object.defineProperty(Bidirectional.prototype, "trainableWeights", {
                    get: function () {
                        return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Bidirectional.prototype, "nonTrainableWeights", {
                    get: function () {
                        return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)
                    }, enumerable: true, configurable: true
                });
                Bidirectional.prototype.getConfig = function () {
                    var config = {mergeMode: this.mergeMode};
                    var baseConfig = _super.prototype.getConfig.call(this);
                    Object.assign(config, baseConfig);
                    return config
                };
                Bidirectional.fromConfig = function (cls, config) {
                    var rnnLayer = serialization_1.deserialize(config["layer"]);
                    delete config["layer"];
                    if (config["numConstants"] != null) {
                        throw new errors_1.NotImplementedError("Deserialization of a Bidirectional layer with numConstants " + "present is not supported yet.")
                    }
                    var newConfig = config;
                    newConfig["layer"] = rnnLayer;
                    return new cls(newConfig)
                };
                Bidirectional.className = "Bidirectional";
                return Bidirectional
            }(Wrapper);
            exports.Bidirectional = Bidirectional;
            tfjs_core_1.serialization.SerializationMap.register(Bidirectional)
        }, {
            "../backend/tfjs_backend": 158,
            "../engine/topology": 163,
            "../errors": 165,
            "../utils/generic_utils": 188,
            "./recurrent": 178,
            "./serialization": 179,
            "@tensorflow/tfjs-core": 50
        }],
        181: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var errors_1 = require("./errors");

            function l2Normalize(x, axis) {
                return tfjs_core_1.tidy(function () {
                    var squareSum = tfc.sum(K.square(x), axis, true);
                    var epsilonTensor = K.scalarTimesArray(tfjs_core_1.scalar(K.epsilon()), tfc.onesLike(x));
                    var norm = tfc.sqrt(tfc.maximum(squareSum, epsilonTensor));
                    return tfc.div(x, norm)
                })
            }

            exports.l2Normalize = l2Normalize;

            function meanSquaredError(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    return tfc.mean(K.square(tfc.sub(yPred, yTrue)), -1)
                })
            }

            exports.meanSquaredError = meanSquaredError;

            function meanAbsoluteError(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    return tfc.mean(tfc.abs(tfc.sub(yPred, yTrue)), -1)
                })
            }

            exports.meanAbsoluteError = meanAbsoluteError;

            function meanAbsolutePercentageError(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var diff = tfc.sub(yTrue, yPred);
                    var clippedTrue = tfc.clipByValue(tfc.abs(yTrue), K.epsilon(), Number.MAX_VALUE);
                    var absResult = tfc.abs(tfc.div(diff, clippedTrue));
                    return K.scalarTimesArray(K.getScalar(100), tfc.mean(absResult, -1))
                })
            }

            exports.meanAbsolutePercentageError = meanAbsolutePercentageError;

            function meanSquaredLogarithmicError(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var one = K.getScalar(1);
                    var clippedPred = tfc.clipByValue(yPred, K.epsilon(), Number.MAX_VALUE);
                    var firstLog = tfc.log(K.scalarPlusArray(one, clippedPred));
                    var clippedTrue = tfc.clipByValue(yTrue, K.epsilon(), Number.MAX_VALUE);
                    var secondLog = tfc.log(K.scalarPlusArray(one, clippedTrue));
                    return tfc.mean(K.square(tfc.sub(firstLog, secondLog)), -1)
                })
            }

            exports.meanSquaredLogarithmicError = meanSquaredLogarithmicError;

            function squaredHinge(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var zeroTensor = K.getScalar(0);
                    var one = K.getScalar(1);
                    var maxResult = tfc.maximum(zeroTensor, tfc.sub(one, tfc.mul(yTrue, yPred)));
                    return tfc.mean(K.square(maxResult), -1)
                })
            }

            exports.squaredHinge = squaredHinge;

            function hinge(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var zeroTensor = K.getScalar(0);
                    var one = K.getScalar(1);
                    var maxResult = tfc.maximum(zeroTensor, tfc.sub(one, tfc.mul(yTrue, yPred)));
                    return tfc.mean(maxResult, -1)
                })
            }

            exports.hinge = hinge;

            function categoricalHinge(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var zeroTensor = K.getScalar(0);
                    var one = K.getScalar(1);
                    var pos = tfc.sum(tfc.mul(yTrue, yPred), -1);
                    var neg = tfc.max(tfc.mul(tfc.sub(one, yTrue), yPred), -1);
                    return tfc.maximum(zeroTensor, K.scalarPlusArray(one, tfc.sub(neg, pos)))
                })
            }

            exports.categoricalHinge = categoricalHinge;

            function logcosh(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var log2 = K.getScalar(Math.log(2));
                    var predictionDiff = tfc.sub(yPred, yTrue);
                    var logcoshResult = tfc.sub(tfc.add(predictionDiff, tfc.softplus(K.scalarTimesArray(K.getScalar(-2), predictionDiff))), log2);
                    return tfc.mean(logcoshResult, -1)
                })
            }

            exports.logcosh = logcosh;

            function categoricalCrossentropy(target, output, fromLogits) {
                if (fromLogits === void 0) {
                    fromLogits = false
                }
                return tfjs_core_1.tidy(function () {
                    if (fromLogits) {
                        output = tfc.softmax(output)
                    } else {
                        var outputSum = tfc.sum(output, K.shape(output).length - 1, true);
                        output = tfc.div(output, outputSum)
                    }
                    output = tfc.clipByValue(output, K.epsilon(), 1 - K.epsilon());
                    return tfc.neg(tfc.sum(tfc.mul(target.toFloat(), tfc.log(output)), K.shape(output).length - 1))
                })
            }

            exports.categoricalCrossentropy = categoricalCrossentropy;

            function sparseCategoricalCrossentropy(target, output, fromLogits) {
                if (fromLogits === void 0) {
                    fromLogits = false
                }
                return tfjs_core_1.tidy(function () {
                    var flatTarget = tfc.floor(K.flatten(target)).toInt();
                    var outputShape = K.shape(output);
                    var oneHotTarget = tfc.oneHot(flatTarget, outputShape[outputShape.length - 1]).reshape(outputShape);
                    return categoricalCrossentropy(oneHotTarget, output, fromLogits)
                })
            }

            exports.sparseCategoricalCrossentropy = sparseCategoricalCrossentropy;

            function sigmoidCrossEntropyWithLogits(target, output) {
                return tfjs_core_1.tidy(function () {
                    var maxOutput = tfc.maximum(output, tfc.zerosLike(output));
                    var outputXTarget = tfc.mul(output, target);
                    var sigmoidOutput = tfc.log(tfc.add(K.getScalar(1), tfc.exp(tfc.neg(tfc.abs(output)))));
                    var result = tfc.add(tfc.sub(maxOutput, outputXTarget), sigmoidOutput);
                    return result
                })
            }

            exports.sigmoidCrossEntropyWithLogits = sigmoidCrossEntropyWithLogits;

            function binaryCrossentropy(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var y;
                    y = tfc.clipByValue(yPred, K.epsilon(), 1 - K.epsilon());
                    y = tfc.log(tfc.div(y, tfc.sub(tfc.onesLike(y), y)));
                    return tfc.mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1)
                })
            }

            exports.binaryCrossentropy = binaryCrossentropy;

            function kullbackLeiblerDivergence(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var clippedTrue = tfc.clipByValue(yTrue, K.epsilon(), 1);
                    var clippedPred = tfc.clipByValue(yPred, K.epsilon(), 1);
                    return tfc.sum(tfc.mul(yTrue, tfc.log(tfc.div(clippedTrue, clippedPred))), -1)
                })
            }

            exports.kullbackLeiblerDivergence = kullbackLeiblerDivergence;

            function poisson(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var logPred = tfc.log(K.scalarPlusArray(K.getScalar(K.epsilon()), yPred));
                    return tfc.mean(tfc.sub(yPred, tfc.mul(yTrue, logPred)), -1)
                })
            }

            exports.poisson = poisson;

            function cosineProximity(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var trueNormalized = l2Normalize(yTrue, -1);
                    var predNormalized = l2Normalize(yPred, -1);
                    var trueXPred = tfc.mul(trueNormalized, predNormalized);
                    return tfc.neg(tfc.sum(trueXPred, -1))
                })
            }

            exports.cosineProximity = cosineProximity;
            exports.mse = meanSquaredError;
            exports.MSE = meanSquaredError;
            exports.mae = meanAbsoluteError;
            exports.MAE = meanAbsoluteError;
            exports.mape = meanAbsolutePercentageError;
            exports.MAPE = meanAbsolutePercentageError;
            exports.msle = meanSquaredLogarithmicError;
            exports.MSLE = meanSquaredLogarithmicError;
            exports.kld = kullbackLeiblerDivergence;
            exports.KLD = kullbackLeiblerDivergence;
            exports.cosine = cosineProximity;

            function get(identifierOrFn) {
                var lossesMap = {
                    meanSquaredError: meanSquaredError,
                    meanAbsoluteError: meanAbsoluteError,
                    meanAbsolutePercentageError: meanAbsolutePercentageError,
                    meanSquaredLogarithmicError: meanSquaredLogarithmicError,
                    squaredHinge: squaredHinge,
                    hinge: hinge,
                    categoricalHinge: categoricalHinge,
                    logcosh: logcosh,
                    categoricalCrossentropy: categoricalCrossentropy,
                    sparseCategoricalCrossentropy: sparseCategoricalCrossentropy,
                    binaryCrossentropy: binaryCrossentropy,
                    kullbackLeiblerDivergence: kullbackLeiblerDivergence,
                    poisson: poisson,
                    cosineProximity: cosineProximity
                };
                if (typeof identifierOrFn === "string") {
                    if (identifierOrFn in lossesMap) {
                        return lossesMap[identifierOrFn]
                    }
                    throw new errors_1.ValueError("Unknown loss " + identifierOrFn)
                } else {
                    return identifierOrFn
                }
            }

            exports.get = get
        }, {"./backend/tfjs_backend": 158, "./errors": 165, "@tensorflow/tfjs-core": 50}],
        182: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var errors_1 = require("./errors");
            var losses_1 = require("./losses");
            var losses_2 = require("./losses");

            function binaryAccuracy(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    var threshold = K.scalarTimesArray(K.getScalar(.5), tfc.onesLike(yPred));
                    var yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);
                    return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1)
                })
            }

            exports.binaryAccuracy = binaryAccuracy;

            function categoricalAccuracy(yTrue, yPred) {
                return tfjs_core_1.tidy(function () {
                    return K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), "float32")
                })
            }

            exports.categoricalAccuracy = categoricalAccuracy;

            function binaryCrossentropy(yTrue, yPred) {
                return losses_2.binaryCrossentropy(yTrue, yPred)
            }

            exports.binaryCrossentropy = binaryCrossentropy;

            function sparseCategoricalAccuracy(yTrue, yPred) {
                throw new errors_1.NotImplementedError
            }

            exports.sparseCategoricalAccuracy = sparseCategoricalAccuracy;

            function topKCategoricalAccuracy(yTrue, yPred) {
                throw new errors_1.NotImplementedError
            }

            exports.topKCategoricalAccuracy = topKCategoricalAccuracy;

            function sparseTopKCategoricalAccuracy(yTrue, yPred) {
                throw new errors_1.NotImplementedError
            }

            exports.sparseTopKCategoricalAccuracy = sparseTopKCategoricalAccuracy;
            exports.mse = losses_1.meanSquaredError;
            exports.MSE = losses_1.meanSquaredError;
            exports.mae = losses_1.meanAbsoluteError;
            exports.MAE = losses_1.meanAbsoluteError;
            exports.mape = losses_1.meanAbsolutePercentageError;
            exports.MAPE = losses_1.meanAbsolutePercentageError;
            exports.categoricalCrossentropy = losses_1.categoricalCrossentropy;
            exports.cosine = losses_1.cosineProximity;
            exports.sparseCategoricalCrossentropy = losses_1.sparseCategoricalCrossentropy;

            function get(identifier) {
                var metricsMap = {
                    binaryAccuracy: binaryAccuracy,
                    categoricalAccuracy: categoricalAccuracy,
                    categoricalCrossentropy: exports.categoricalCrossentropy,
                    sparseCategoricalCrossentropy: exports.sparseCategoricalCrossentropy,
                    mse: exports.mse,
                    MSE: exports.MSE,
                    mae: exports.mae,
                    MAE: exports.MAE,
                    mape: exports.mape,
                    MAPE: exports.MAPE,
                    cosine: exports.cosine
                };
                if (typeof identifier === "string" && identifier in metricsMap) {
                    return metricsMap[identifier]
                } else if (typeof identifier !== "string" && identifier != null) {
                    return identifier
                } else {
                    throw new errors_1.ValueError("Unknown metric " + identifier)
                }
            }

            exports.get = get
        }, {"./backend/tfjs_backend": 158, "./errors": 165, "./losses": 181, "@tensorflow/tfjs-core": 50}],
        183: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var topology_1 = require("./engine/topology");
            var training_1 = require("./engine/training");
            var errors_1 = require("./errors");
            var serialization_1 = require("./layers/serialization");
            var generic_utils = require("./utils/generic_utils");
            var serialization_utils_1 = require("./utils/serialization_utils");

            function modelFromJSON(modelAndWeightsConfig, customObjects) {
                return __awaiter(this, void 0, void 0, function () {
                    var modelTopology, tsConfig, model, weightValues, uniqueWeightValues, _i, _a, weight,
                        skipMismatches, isNamedTensorMap;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                modelTopology = modelAndWeightsConfig.modelTopology;
                                if (modelTopology["model_config"] != null) {
                                    modelTopology = modelTopology["model_config"]
                                }
                                tsConfig = serialization_utils_1.convertPythonicToTs(modelTopology);
                                model = serialization_1.deserialize(tsConfig, customObjects);
                                if (!(modelAndWeightsConfig.weightsManifest != null)) return [3, 2];
                                return [4, tfjs_core_1.io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(function (weight) {
                                    return weight.originalName
                                }))];
                            case 1:
                                weightValues = _b.sent();
                                uniqueWeightValues = {};
                                for (_i = 0, _a = model.weights; _i < _a.length; _i++) {
                                    weight = _a[_i];
                                    uniqueWeightValues[weight.originalName] = weightValues[weight.originalName]
                                }
                                skipMismatches = null;
                                isNamedTensorMap = true;
                                model.loadWeights(uniqueWeightValues, skipMismatches, isNamedTensorMap);
                                _b.label = 2;
                            case 2:
                                return [2, model]
                        }
                    })
                })
            }

            exports.modelFromJSON = modelFromJSON;

            function loadModelInternal(pathOrIOHandler) {
                return __awaiter(this, void 0, void 0, function () {
                    var handlers;
                    return __generator(this, function (_a) {
                        if (typeof pathOrIOHandler === "string") {
                            handlers = tfjs_core_1.io.getLoadHandlers(pathOrIOHandler);
                            if (handlers.length === 0) {
                                return [2, loadModelFromPath(pathOrIOHandler)]
                            } else if (handlers.length > 1) {
                                throw new errors_1.ValueError("Found more than one (" + handlers.length + ") load handlers for " + ("URL '" + pathOrIOHandler + "'"))
                            }
                            pathOrIOHandler = handlers[0]
                        }
                        return [2, loadModelFromIOHandler(pathOrIOHandler)]
                    })
                })
            }

            exports.loadModelInternal = loadModelInternal;

            function loadModelFromIOHandler(handler, customObjects) {
                return __awaiter(this, void 0, void 0, function () {
                    var artifacts, model, skipMismatch, isNamedTensorMap;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (handler.load == null) {
                                    throw new errors_1.ValueError("Cannot proceed with model loading because the IOHandler provided " + "does not have the `load` method implemented.")
                                }
                                return [4, handler.load()];
                            case 1:
                                artifacts = _a.sent();
                                model = serialization_1.deserialize(serialization_utils_1.convertPythonicToTs(artifacts.modelTopology), customObjects);
                                if (artifacts.weightData != null) {
                                    if (artifacts.weightSpecs == null) {
                                        throw new errors_1.ValueError("Model artifacts contains weight data, but not weight specs. " + "Therefore loading of weights cannot proceed.")
                                    }
                                    skipMismatch = false;
                                    isNamedTensorMap = true;
                                    model.loadWeights(tfjs_core_1.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs), skipMismatch, isNamedTensorMap)
                                }
                                return [2, model]
                        }
                    })
                })
            }

            exports.loadModelFromIOHandler = loadModelFromIOHandler;

            function loadModelFromPath(modelConfigPath) {
                return __awaiter(this, void 0, void 0, function () {
                    var modelConfigRequest, modelConfig;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                return [4, fetch(modelConfigPath)];
                            case 1:
                                modelConfigRequest = _a.sent();
                                return [4, modelConfigRequest.json()];
                            case 2:
                                modelConfig = _a.sent();
                                if (modelConfig["modelTopology"] == null) {
                                    throw new errors_1.ValueError('Missing field "modelTopology" from model JSON at path' + modelConfigPath)
                                }
                                if (modelConfig["weightsManifest"] == null) {
                                    throw new errors_1.ValueError('Missing field "weightsManifest" from model JSON at path' + modelConfigPath)
                                }
                                modelConfig.pathPrefix = modelConfigPath.substring(0, modelConfigPath.lastIndexOf("/"));
                                return [2, modelFromJSON(modelConfig)]
                        }
                    })
                })
            }

            exports.loadModelFromPath = loadModelFromPath;
            var Sequential = function (_super) {
                __extends(Sequential, _super);

                function Sequential(config) {
                    var _this = _super.call(this, {inputs: [], outputs: []}) || this;
                    config = config || {};
                    _this.trainable = true;
                    _this._updatable = true;
                    _this.built = false;
                    _this.name = config.name != null ? config.name : K.getUid("sequential_");
                    if (config.layers != null) {
                        for (var _i = 0, _a = config.layers; _i < _a.length; _i++) {
                            var layer = _a[_i];
                            _this.add(layer)
                        }
                    }
                    return _this
                }

                Sequential_1 = Sequential;
                Sequential.prototype.add = function (layer) {
                    if (this.outputs.length === 0) {
                        if (layer.inboundNodes.length === 0) {
                            if (layer.batchInputShape == null) {
                                throw new errors_1.ValueError("The first layer in a Sequential model must " + "get an `inputShape` or `batchInputShape` argument.")
                            }
                            var x = topology_1.Input({
                                batchShape: layer.batchInputShape,
                                dtype: layer.dtype,
                                name: layer.name + "_input"
                            });
                            layer.apply(x)
                        }
                        if (layer.inboundNodes.length !== 1) {
                            throw new errors_1.ValueError("A layer added to a Sequential model must not already be " + ("connected somewhere else. Model received layer " + layer.name + " ") + ("which has " + layer.inboundNodes.length + " pre-existing inbound ") + "connections.")
                        }
                        if (layer.inboundNodes[0].outputTensors.length !== 1) {
                            throw new errors_1.ValueError("All layers in a Sequential model " + "should have a single output tensor. " + "For multi-output layers, " + "use the functional API.")
                        }
                        this.outputs = [layer.inboundNodes[0].outputTensors[0]];
                        this.inputs = topology_1.getSourceInputs(this.outputs[0]);
                        new topology_1.Node({
                            outboundLayer: this,
                            inboundLayers: [],
                            nodeIndices: [],
                            tensorIndices: [],
                            inputTensors: this.inputs,
                            outputTensors: this.outputs,
                            inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),
                            outputMasks: [null],
                            inputShapes: this.inputs.map(function (x) {
                                return x.shape
                            }),
                            outputShapes: this.outputs[0].shape
                        })
                    } else {
                        var outputTensor = layer.apply(this.outputs[0]);
                        if (Array.isArray(outputTensor)) {
                            throw new TypeError("All layers in a Sequential model " + "should have a single output tensor. " + "For multi-output layers, " + "use the functional API.")
                        }
                        this.outputs = [outputTensor];
                        this.inboundNodes[0].outputTensors = this.outputs;
                        this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
                    }
                    this.layers.push(layer);
                    this.built = false
                };
                Sequential.prototype.pop = function () {
                    if (this.layers.length === 0) {
                        throw new TypeError("There are no layers in the model.")
                    }
                    this.layers.pop();
                    if (this.layers.length === 0) {
                        this.outputs = [];
                        this.inboundNodes = [];
                        this.outboundNodes = []
                    } else {
                        var lastLayerIndex = this.layers.length - 1;
                        this.layers[lastLayerIndex].outboundNodes = [];
                        this.outputs = [this.layers[lastLayerIndex].output];
                        this.inboundNodes[0].outputTensors = this.outputs;
                        this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
                    }
                };
                Sequential.prototype.call = function (inputs, kwargs) {
                    if (this.model == null) {
                        this.build()
                    }
                    return this.model.call(inputs, kwargs)
                };
                Sequential.prototype.build = function (inputShape) {
                    if (this.inputs.length === 0 || this.outputs.length === 0) {
                        throw new TypeError("Sequential model cannot be built: model is empty." + " Add some layers first.")
                    }
                    this.model = new training_1.Model({
                        inputs: this.inputs,
                        outputs: this.outputs[0],
                        name: this.name + "_model"
                    });
                    this.model.trainable = this.trainable;
                    this.model.updatable = this.updatable;
                    this.supportsMasking = this.model.supportsMasking;
                    this.inputLayers = this.model.inputLayers;
                    this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
                    this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
                    this.outputLayers = this.model.outputLayers;
                    this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
                    this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
                    this.nodesByDepth = this.model.nodesByDepth;
                    this.containerNodes = this.model.containerNodes;
                    this.outputNames = this.model.outputNames;
                    this.inputNames = this.model.inputNames;
                    this.built = true
                };
                Sequential.prototype.setWeights = function (weights) {
                    if (this.model == null) {
                        this.build()
                    }
                    this.model.setWeights(weights)
                };
                Object.defineProperty(Sequential.prototype, "updatable", {
                    get: function () {
                        return this._updatable
                    }, set: function (value) {
                        if (this.built) {
                            this.model.updatable = value
                        }
                        this._updatable = value
                    }, enumerable: true, configurable: true
                });
                Sequential.prototype.evaluate = function (x, y, config) {
                    if (config === void 0) {
                        config = {}
                    }
                    if (!this.built) {
                        throw new errors_1.RuntimeError("The model needs to be compiled before being used.")
                    }
                    return this.model.evaluate(x, y, config)
                };
                Sequential.prototype.predict = function (x, config) {
                    if (config === void 0) {
                        config = {}
                    }
                    if (this.model == null) {
                        this.build()
                    }
                    return this.model.predict(x, config)
                };
                Sequential.prototype.predictOnBatch = function (x) {
                    if (this.model == null) {
                        this.build()
                    }
                    return this.model.predictOnBatch(x)
                };
                Sequential.prototype.compile = function (config) {
                    this.build();
                    this.model.compile(config);
                    this.optimizer = this.model.optimizer;
                    this.loss = this.model.loss;
                    this.metrics = this.model.metrics;
                    this.metricsTensors = this.model.metricsTensors;
                    this.metricsNames = this.model.metricsNames
                };
                Sequential.prototype.fit = function (x, y, config) {
                    if (config === void 0) {
                        config = {}
                    }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (!this.built) {
                                throw new errors_1.RuntimeError("The model needs to be compiled before " + "being used.")
                            }
                            return [2, this.model.fit(x, y, config)]
                        })
                    })
                };
                Sequential.fromConfig = function (cls, config) {
                    var model = new cls({});
                    if (!(model instanceof Sequential_1)) {
                        throw new errors_1.ValueError("Sequential.fromConfig called on non-Sequential input: " + model)
                    }
                    if (!(config instanceof Array)) {
                        throw new errors_1.ValueError("Sequential.fromConfig called without an array of configs")
                    }
                    if (!(config[0].className != null) || config[0]["className"] === "Merge") {
                        throw new errors_1.ValueError("Legacy serialization format not supported yet.")
                    }
                    for (var _i = 0, _a = config; _i < _a.length; _i++) {
                        var conf = _a[_i];
                        var layer = serialization_1.deserialize(conf);
                        model.add(layer)
                    }
                    return model
                };
                Sequential.prototype.getConfig = function () {
                    var config = [];
                    for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
                        var layer = _a[_i];
                        config.push({className: layer.getClassName(), config: layer.getConfig()})
                    }
                    return config
                };
                Sequential.className = "Sequential";
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes"
                })], Sequential.prototype, "add", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes",
                    configParamIndices: [2]
                })], Sequential.prototype, "evaluate", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes",
                    configParamIndices: [1]
                })], Sequential.prototype, "predict", null);
                __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes",
                    configParamIndices: [2]
                })], Sequential.prototype, "fit", null);
                Sequential = Sequential_1 = __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes"
                })], Sequential);
                return Sequential;
                var Sequential_1
            }(training_1.Model);
            exports.Sequential = Sequential;
            tfjs_core_1.serialization.SerializationMap.register(Sequential)
        }, {
            "./backend/tfjs_backend": 158,
            "./engine/topology": 163,
            "./engine/training": 164,
            "./errors": 165,
            "./layers/serialization": 179,
            "./utils/generic_utils": 188,
            "./utils/serialization_utils": 190,
            "@tensorflow/tfjs-core": 50
        }],
        184: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var errors_1 = require("./errors");

            function getOptimizer(identifier) {
                var optimizerMap = {
                    Adagrad: function () {
                        return tfjs_core_1.train.adagrad(.01)
                    }, Adam: function () {
                        return tfjs_core_1.train.adam(.001, .9, .999, K.epsilon())
                    }, RMSProp: function () {
                        return tfjs_core_1.train.rmsprop(.001, .9, null, K.epsilon())
                    }, SGD: function () {
                        return tfjs_core_1.train.sgd(.01)
                    }
                };
                optimizerMap["adagrad"] = optimizerMap["Adagrad"];
                optimizerMap["adam"] = optimizerMap["Adam"];
                optimizerMap["rmsprop"] = optimizerMap["RMSProp"];
                optimizerMap["sgd"] = optimizerMap["SGD"];
                if (identifier in optimizerMap) {
                    return optimizerMap[identifier]()
                }
                throw new errors_1.ValueError("Unknown Optimizer " + identifier)
            }

            exports.getOptimizer = getOptimizer
        }, {"./backend/tfjs_backend": 158, "./errors": 165, "@tensorflow/tfjs-core": 50}],
        185: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var K = require("./backend/tfjs_backend");
            var generic_utils_1 = require("./utils/generic_utils");
            var Regularizer = function (_super) {
                __extends(Regularizer, _super);

                function Regularizer() {
                    return _super !== null && _super.apply(this, arguments) || this
                }

                return Regularizer
            }(tfjs_core_1.serialization.Serializable);
            exports.Regularizer = Regularizer;
            var L1L2 = function (_super) {
                __extends(L1L2, _super);

                function L1L2(config) {
                    var _this = _super.call(this) || this;
                    var l1 = config == null || config.l1 == null ? .01 : config.l1;
                    var l2 = config == null || config.l2 == null ? .01 : config.l2;
                    _this.hasL1 = l1 !== 0;
                    _this.hasL2 = l2 !== 0;
                    _this.l1 = K.getScalar(l1);
                    _this.l2 = K.getScalar(l2);
                    return _this
                }

                L1L2.prototype.apply = function (x) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var regularization = tfjs_core_1.zeros([1]);
                        if (_this.hasL1) {
                            regularization = tfjs_core_1.add(regularization, tfjs_core_1.sum(K.scalarTimesArray(_this.l1, tfjs_core_1.abs(x))))
                        }
                        if (_this.hasL2) {
                            regularization = tfjs_core_1.add(regularization, tfjs_core_1.sum(K.scalarTimesArray(_this.l2, K.square(x))))
                        }
                        return regularization.asScalar()
                    })
                };
                L1L2.prototype.getConfig = function () {
                    return {l1: this.l1.dataSync()[0], l2: this.l2.dataSync()[0]}
                };
                L1L2.fromConfig = function (cls, config) {
                    return new cls({l1: config.l1, l2: config.l2})
                };
                L1L2.className = "L1L2";
                L1L2 = __decorate([tfjs_core_1.doc({heading: "Regularizers", namespace: "regularizers"})], L1L2);
                return L1L2
            }(Regularizer);
            exports.L1L2 = L1L2;
            tfjs_core_1.serialization.SerializationMap.register(L1L2);

            function l1(config) {
                return new L1L2({l1: config != null ? config.l1 : null, l2: 0})
            }

            exports.l1 = l1;

            function l2(config) {
                return new L1L2({l2: config != null ? config.l2 : null, l1: 0})
            }

            exports.l2 = l2;
            exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {l1l2: "L1L2"};

            function serializeRegularizer(constraint) {
                return generic_utils_1.serializeKerasObject(constraint)
            }

            exports.serializeRegularizer = serializeRegularizer;

            function deserializeRegularizer(config, customObjects) {
                if (customObjects === void 0) {
                    customObjects = {}
                }
                return generic_utils_1.deserializeKerasObject(config, tfjs_core_1.serialization.SerializationMap.getMap().classNameMap, customObjects, "regularizer")
            }

            exports.deserializeRegularizer = deserializeRegularizer;

            function getRegularizer(identifier) {
                if (identifier == null) {
                    return null
                }
                if (typeof identifier === "string") {
                    var className = identifier in exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
                    var config = {className: className, config: {}};
                    return deserializeRegularizer(config)
                } else if (identifier instanceof Regularizer) {
                    return identifier
                } else {
                    return deserializeRegularizer(identifier)
                }
            }

            exports.getRegularizer = getRegularizer
        }, {"./backend/tfjs_backend": 158, "./utils/generic_utils": 188, "@tensorflow/tfjs-core": 50}],
        186: [function (require, module, exports) {
            "use strict";
            var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
                var c = arguments.length,
                    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var common_1 = require("./common");
            var _nextUniqueTensorId = 0;

            function getNextUniqueTensorId() {
                return _nextUniqueTensorId++
            }

            exports.getNextUniqueTensorId = getNextUniqueTensorId;
            var SymbolicTensor = function () {
                function SymbolicTensor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {
                    this.dtype = dtype;
                    this.shape = shape;
                    this.sourceLayer = sourceLayer;
                    this.inputs = inputs;
                    this.callArgs = callArgs;
                    this.outputTensorIndex = outputTensorIndex;
                    this.id = getNextUniqueTensorId();
                    if (name != null) {
                        this.originalName = common_1.getScopedTensorName(name);
                        this.name = common_1.getUniqueTensorName(this.originalName)
                    }
                    this.rank = shape.length
                }

                SymbolicTensor = __decorate([tfjs_core_1.doc({
                    heading: "Models",
                    subheading: "Classes"
                })], SymbolicTensor);
                return SymbolicTensor
            }();
            exports.SymbolicTensor = SymbolicTensor
        }, {"./common": 160, "@tensorflow/tfjs-core": 50}],
        187: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var errors_1 = require("../errors");
            var generic_utils_1 = require("./generic_utils");
            var math_utils_1 = require("./math_utils");

            function normalizeArray(value, n, name) {
                if (typeof value === "number") {
                    return generic_utils_1.pyListRepeat(value, n)
                } else {
                    if (value.length !== n) {
                        throw new errors_1.ValueError("The " + name + " argument must be a tuple of " + n + " integers. Received: " + (value.length + " elements."))
                    }
                    for (var i = 0; i < n; ++i) {
                        var singleValue = value[i];
                        if (!math_utils_1.isInteger(singleValue)) {
                            throw new errors_1.ValueError("The " + name + " argument must be a tuple of " + n + " integers. Received: " + (JSON.stringify(value) + " including a non-integer number ") + ("" + singleValue))
                        }
                    }
                    return value
                }
            }

            exports.normalizeArray = normalizeArray;

            function convOutputLength(inputLength, filterSize, padding, stride, dilation) {
                if (dilation === void 0) {
                    dilation = 1
                }
                if (inputLength == null) {
                    return inputLength
                }
                var dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);
                var outputLength;
                if (padding === "same") {
                    outputLength = inputLength
                } else {
                    outputLength = inputLength - dilatedFilterSize + 1
                }
                return Math.floor((outputLength + stride - 1) / stride)
            }

            exports.convOutputLength = convOutputLength;

            function deconvLength(dimSize, strideSize, kernelSize, padding) {
                if (dimSize == null) {
                    return null
                }
                if (padding === "valid") {
                    dimSize = dimSize * strideSize + math_utils_1.max([kernelSize - strideSize, 0])
                } else if (padding === "same") {
                    dimSize = dimSize * strideSize
                } else {
                    throw new errors_1.ValueError("Unsupport padding mode: " + padding + ".")
                }
                return dimSize
            }

            exports.deconvLength = deconvLength
        }, {"../errors": 165, "./generic_utils": 188, "./math_utils": 189}],
        188: [function (require, module, exports) {
            "use strict";
            var __assign = this && this.__assign || Object.assign || function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var errors_1 = require("../errors");

            function pyListRepeat(value, numValues) {
                if (Array.isArray(value)) {
                    var newArray = [];
                    for (var i = 0; i < numValues; i++) {
                        newArray = newArray.concat(value)
                    }
                    return newArray
                } else {
                    var newArray = new Array(numValues);
                    newArray.fill(value);
                    return newArray
                }
            }

            exports.pyListRepeat = pyListRepeat;

            function assert(val, message) {
                if (!val) {
                    throw new errors_1.AssertionError(message)
                }
            }

            exports.assert = assert;

            function count(array, refernce) {
                var counter = 0;
                for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
                    var item = array_1[_i];
                    if (item === refernce) {
                        counter++
                    }
                }
                return counter
            }

            exports.count = count;

            function singletonOrArray(xs) {
                if (xs.length === 1) {
                    return xs[0]
                }
                return xs
            }

            exports.singletonOrArray = singletonOrArray;

            function toList(x) {
                if (Array.isArray(x)) {
                    return x
                }
                return [x]
            }

            exports.toList = toList;

            function objectListUid(objs) {
                var objectList = toList(objs);
                var retVal = "";
                for (var _i = 0, objectList_1 = objectList; _i < objectList_1.length; _i++) {
                    var obj = objectList_1[_i];
                    if (obj.id == null) {
                        throw new errors_1.ValueError("Object " + obj + " passed to objectListUid without an id")
                    }
                    if (retVal !== "") {
                        retVal = retVal + ", "
                    }
                    retVal = retVal + Math.abs(obj.id)
                }
                return retVal
            }

            exports.objectListUid = objectListUid;

            function isArrayOfShapes(x) {
                return Array.isArray(x) && Array.isArray(x[0])
            }

            exports.isArrayOfShapes = isArrayOfShapes;

            function normalizeShapeList(x) {
                if (x.length === 0) {
                    return []
                }
                if (!Array.isArray(x[0])) {
                    return [x]
                }
                return x
            }

            exports.normalizeShapeList = normalizeShapeList;

            function toSnakeCase(name) {
                var intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2");
                var insecure = intermediate.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
                if (insecure[0] !== "_") {
                    return insecure
                }
                return "private" + insecure
            }

            exports.toSnakeCase = toSnakeCase;

            function toCamelCase(identifier) {
                if (identifier.length <= 1) {
                    return identifier
                }
                if (identifier.indexOf("_") === -1) {
                    return identifier
                }
                return identifier.replace(/[_]+(\w|$)/g, function (m, p1) {
                    return p1.toUpperCase()
                })
            }

            exports.toCamelCase = toCamelCase;
            var _GLOBAL_CUSTOM_OBJECTS = {};

            function serializeKerasObject(instance) {
                if (instance === null || instance === undefined) {
                    return null
                }
                return {className: instance.getClassName(), config: instance.getConfig()}
            }

            exports.serializeKerasObject = serializeKerasObject;

            function deserializeKerasObject(identifier, moduleObjects, customObjects, printableModuleName) {
                if (moduleObjects === void 0) {
                    moduleObjects = {}
                }
                if (customObjects === void 0) {
                    customObjects = {}
                }
                if (printableModuleName === void 0) {
                    printableModuleName = "object"
                }
                if (typeof identifier === "string") {
                    var functionName = identifier;
                    var fn = void 0;
                    if (functionName in customObjects) {
                        fn = customObjects[functionName]
                    } else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {
                        fn = _GLOBAL_CUSTOM_OBJECTS[functionName]
                    } else {
                        fn = moduleObjects[functionName];
                        if (fn == null) {
                            throw new errors_1.ValueError("Unknown " + printableModuleName + ": " + identifier)
                        }
                    }
                    return fn
                } else {
                    var config = identifier;
                    if (config.className == null || config.config == null) {
                        throw new errors_1.ValueError(printableModuleName + ": Improper config format: " + (JSON.stringify(config) + ".\n") + "'className' and 'config' must set.")
                    }
                    var className = config.className;
                    var cls = void 0, fromConfig = void 0;
                    if (className in customObjects) {
                        _a = customObjects.get(className), cls = _a[0], fromConfig = _a[1]
                    } else if (className in _GLOBAL_CUSTOM_OBJECTS) {
                        _b = _GLOBAL_CUSTOM_OBJECTS.className, cls = _b[0], fromConfig = _b[1]
                    } else if (className in moduleObjects) {
                        _c = moduleObjects[className], cls = _c[0], fromConfig = _c[1]
                    }
                    if (cls == null) {
                        throw new errors_1.ValueError("Unknown " + printableModuleName + ": " + className)
                    }
                    if (fromConfig != null) {
                        var customObjectsCombined = {};
                        for (var _i = 0, _d = Object.keys(_GLOBAL_CUSTOM_OBJECTS); _i < _d.length; _i++) {
                            var key = _d[_i];
                            customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key]
                        }
                        for (var _e = 0, _f = Object.keys(customObjects); _e < _f.length; _e++) {
                            var key = _f[_e];
                            customObjectsCombined[key] = customObjects[key]
                        }
                        var nestedConfig = config.config;
                        nestedConfig.customObjects = customObjectsCombined;
                        var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
                        for (var _g = 0, _h = Object.keys(customObjects); _g < _h.length; _g++) {
                            var key = _h[_g];
                            _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key]
                        }
                        var returnObj = fromConfig(cls, config.config);
                        _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);
                        return returnObj
                    } else {
                        var backupCustomObjects = __assign({}, _GLOBAL_CUSTOM_OBJECTS);
                        for (var _j = 0, _k = Object.keys(customObjects); _j < _k.length; _j++) {
                            var key = _k[_j];
                            _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key]
                        }
                        var returnObj = new cls(config.config);
                        _GLOBAL_CUSTOM_OBJECTS = __assign({}, backupCustomObjects);
                        return returnObj
                    }
                }
                var _a, _b, _c
            }

            exports.deserializeKerasObject = deserializeKerasObject;

            function getExactlyOneTensor(xs) {
                var x;
                if (Array.isArray(xs)) {
                    if (xs.length !== 1) {
                        throw new errors_1.ValueError("Expected Tensor length to be 1; got " + xs.length)
                    }
                    x = xs[0]
                } else {
                    x = xs
                }
                return x
            }

            exports.getExactlyOneTensor = getExactlyOneTensor;

            function getExactlyOneShape(shapes) {
                if (Array.isArray(shapes) && Array.isArray(shapes[0])) {
                    if (shapes.length === 1) {
                        shapes = shapes;
                        return shapes[0]
                    } else {
                        throw new errors_1.ValueError("Expected exactly 1 Shape; got " + shapes.length)
                    }
                } else {
                    return shapes
                }
            }

            exports.getExactlyOneShape = getExactlyOneShape;

            function numberCompare(a, b) {
                return a < b ? -1 : a > b ? 1 : 0
            }

            exports.numberCompare = numberCompare;

            function reverseNumberCompare(a, b) {
                return -1 * numberCompare(a, b)
            }

            exports.reverseNumberCompare = reverseNumberCompare;

            function stringToDType(dtype) {
                switch (dtype) {
                    case"float32":
                        return "float32";
                    default:
                        throw new errors_1.ValueError("Invalid dtype: " + dtype)
                }
            }

            exports.stringToDType = stringToDType;

            function stringsEqual(xs, ys) {
                if (xs == null || ys == null) {
                    return xs === ys
                }
                if (xs.length !== ys.length) {
                    return false
                }
                for (var i = 0; i < xs.length; ++i) {
                    if (xs[i] !== ys[i]) {
                        return false
                    }
                }
                return true
            }

            exports.stringsEqual = stringsEqual;

            function unique(xs) {
                if (xs == null) {
                    return xs
                }
                var out = [];
                for (var _i = 0, xs_1 = xs; _i < xs_1.length; _i++) {
                    var x = xs_1[_i];
                    if (out.indexOf(x) === -1) {
                        out.push(x)
                    }
                }
                return out
            }

            exports.unique = unique;

            function isObjectEmpty(obj) {
                if (obj == null) {
                    throw new errors_1.ValueError("Invalid value in obj: " + JSON.stringify(obj))
                }
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        return false
                    }
                }
                return true
            }

            exports.isObjectEmpty = isObjectEmpty;

            function checkStringTypeUnionValue(values, label, value) {
                if (value == null) {
                    return
                }
                if (values.indexOf(value) < 0) {
                    throw new errors_1.ValueError(value + " is not a valid " + label + ".  Valid values are " + values + " or null/undefined.")
                }
            }

            exports.checkStringTypeUnionValue = checkStringTypeUnionValue
        }, {"../errors": 165}],
        189: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var errors_1 = require("../errors");

            function isInteger(x) {
                return x === parseInt(x.toString(), 10)
            }

            exports.isInteger = isInteger;

            function arrayProd(array, begin, end) {
                if (begin == null) {
                    begin = 0
                }
                if (end == null) {
                    end = array.length
                }
                var prod = 1;
                for (var i = begin; i < end; ++i) {
                    prod *= array[i]
                }
                return prod
            }

            exports.arrayProd = arrayProd;

            function toArray1D(array) {
                array = Array.isArray(array) ? new Float32Array(array) : array;
                return tfjs_core_1.tensor1d(array)
            }

            function min(array) {
                return tfc.min(toArray1D(array)).dataSync()[0]
            }

            exports.min = min;

            function max(array) {
                return tfc.max(toArray1D(array)).dataSync()[0]
            }

            exports.max = max;

            function sum(array) {
                return tfc.sum(toArray1D(array)).dataSync()[0]
            }

            exports.sum = sum;

            function mean(array) {
                return sum(array) / array.length
            }

            exports.mean = mean;

            function variance(array) {
                var demeaned = tfc.sub(toArray1D(array), tfjs_core_1.scalar(mean(array)));
                var sumSquare = tfc.sum(tfc.mulStrict(demeaned, demeaned)).dataSync()[0];
                return sumSquare / array.length
            }

            exports.variance = variance;

            function median(array) {
                var arraySorted = array.slice().sort(function (a, b) {
                    return a - b
                });
                var lowIdx = Math.floor((arraySorted.length - 1) / 2);
                var highIdx = Math.ceil((arraySorted.length - 1) / 2);
                if (lowIdx === highIdx) {
                    return arraySorted[lowIdx]
                }
                return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2
            }

            exports.median = median;

            function range(begin, end) {
                if (end < begin) {
                    throw new errors_1.ValueError("end (" + end + ") < begin (" + begin + ") is forbidden.")
                }
                var out = [];
                for (var i = begin; i < end; ++i) {
                    out.push(i)
                }
                return out
            }

            exports.range = range
        }, {"../errors": 165, "@tensorflow/tfjs-core": 50}],
        190: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var generic_utils = require("../utils/generic_utils");

            function isArrayItemInputOrOutputName(key, index, value) {
                return (key === "inboundNodes" || key === "outputLayers" || key === "inputLayers") && index === 0 && typeof value === "string"
            }

            function convertPythonicToTs(pythonicConfig, key) {
                if (pythonicConfig === null) {
                    return null
                } else if (typeof pythonicConfig === "string") {
                    return generic_utils.toCamelCase(pythonicConfig)
                } else if (typeof pythonicConfig === "number" || typeof pythonicConfig === "boolean") {
                    return pythonicConfig
                } else if (pythonicConfig instanceof Array) {
                    var tsArray = [];
                    var arrayLength = pythonicConfig.length;
                    for (var i = 0; i < arrayLength; ++i) {
                        var item = pythonicConfig[i];
                        if (isArrayItemInputOrOutputName(key, i, item)) {
                            tsArray.push(item)
                        } else {
                            tsArray.push(convertPythonicToTs(item, key))
                        }
                    }
                    return tsArray
                } else {
                    var tsDict = {};
                    for (var _i = 0, _a = Object.keys(pythonicConfig); _i < _a.length; _i++) {
                        var pythonicKey = _a[_i];
                        var pythonicValue = pythonicConfig[pythonicKey];
                        if (pythonicKey === "name" && typeof pythonicValue === "string") {
                            tsDict[pythonicKey] = pythonicValue
                        } else {
                            var tsKey = generic_utils.toCamelCase(pythonicKey);
                            tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey)
                        }
                    }
                    return tsDict
                }
            }

            exports.convertPythonicToTs = convertPythonicToTs;

            function convertTsToPythonic(tsConfig, key) {
                if (tsConfig === null || tsConfig === undefined) {
                    return null
                } else if (typeof tsConfig === "string") {
                    return generic_utils.toSnakeCase(tsConfig)
                } else if (typeof tsConfig === "number" || typeof tsConfig === "boolean") {
                    return tsConfig
                } else if (tsConfig instanceof Array) {
                    var pyArray = [];
                    var arrayLength = tsConfig.length;
                    for (var i = 0; i < arrayLength; ++i) {
                        var item = tsConfig[i];
                        if (isArrayItemInputOrOutputName(key, i, item)) {
                            pyArray.push(item)
                        } else {
                            pyArray.push(convertTsToPythonic(item, key))
                        }
                    }
                    return pyArray
                } else {
                    var pyDict = {};
                    for (var _i = 0, _a = Object.keys(tsConfig); _i < _a.length; _i++) {
                        var tsKey = _a[_i];
                        var tsValue = tsConfig[tsKey];
                        var pyKey = generic_utils.toSnakeCase(tsKey);
                        if ((tsKey === "name" || tsKey === "className") && typeof tsValue === "string") {
                            pyDict[pyKey] = tsValue
                        } else {
                            pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey)
                        }
                    }
                    return pyDict
                }
            }

            exports.convertTsToPythonic = convertTsToPythonic
        }, {"../utils/generic_utils": 188}],
        191: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfc = require("@tensorflow/tfjs-core");
            var tfjs_backend_1 = require("./backend/tfjs_backend");
            var common_1 = require("./common");
            var errors_1 = require("./errors");
            var types_1 = require("./types");
            var DEFAULT_VARIABLE_NAME_PREFIX = "Variable";
            var LayerVariable = function () {
                function LayerVariable(val, dtype, name, trainable, constraint) {
                    if (dtype === void 0) {
                        dtype = "float32"
                    }
                    if (name === void 0) {
                        name = DEFAULT_VARIABLE_NAME_PREFIX
                    }
                    if (trainable === void 0) {
                        trainable = true
                    }
                    if (constraint === void 0) {
                        constraint = null
                    }
                    this.dtype = dtype == null ? "float32" : dtype;
                    this.shape = val.shape;
                    this.id = types_1.getNextUniqueTensorId();
                    name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;
                    this.originalName = common_1.getScopedTensorName(name);
                    this.name = common_1.getUniqueTensorName(this.originalName);
                    this.trainable = trainable;
                    this.constraint = constraint;
                    this.val = tfc.variable(val, this.trainable, this.name, this.dtype)
                }

                LayerVariable.prototype.read = function () {
                    return this.val
                };
                LayerVariable.prototype.write = function (newVal) {
                    checkShapesMatch(this.val, newVal);
                    this.val.assign(newVal);
                    if (this.constraint != null) {
                        this.val.assign(this.constraint.apply(this.val))
                    }
                    return this
                };
                return LayerVariable
            }();
            exports.LayerVariable = LayerVariable;

            function checkShapesMatch(x, y) {
                if (x.shape.toString() !== y.shape.toString()) {
                    throw new Error("Shape mismatch: " + JSON.stringify(x.shape) + " vs. " + JSON.stringify(y.shape))
                }
            }

            function variable(x, dtype, name, constraint) {
                return new LayerVariable(x, dtype, name, true, constraint)
            }

            exports.variable = variable;

            function zerosVariable(shape, dtype, name) {
                return new LayerVariable(tfc.zeros(shape), dtype, name)
            }

            exports.zerosVariable = zerosVariable;

            function zerosLike(x, dtype, name) {
                return new LayerVariable(tfc.zerosLike(x), dtype, name)
            }

            exports.zerosLike = zerosLike;

            function onesVariable(shape, dtype, name) {
                var allocated = tfc.ones(shape);
                return new LayerVariable(allocated, dtype, name)
            }

            exports.onesVariable = onesVariable;

            function onesLike(x, dtype, name) {
                var allocated = tfc.onesLike(x);
                return new LayerVariable(allocated, dtype, name)
            }

            exports.onesLike = onesLike;

            function eyeVariable(size, dtype, name) {
                return new LayerVariable(tfc.eye(size), dtype, name)
            }

            exports.eyeVariable = eyeVariable;

            function randomUniformVariable(shape, minval, maxval, dtype, seed, name) {
                if (name === void 0) {
                    name = "randomUniform"
                }
                return new LayerVariable(tfc.randomUniform(shape, minval, maxval, dtype), dtype, name)
            }

            exports.randomUniformVariable = randomUniformVariable;

            function truncatedNormalVariable(shape, mean, stddev, dtype, seed, name) {
                if (mean === void 0) {
                    mean = 0
                }
                if (stddev === void 0) {
                    stddev = 1
                }
                if (name === void 0) {
                    name = "truncatedNormal"
                }
                if (dtype === "bool") {
                    throw new errors_1.NotImplementedError("randomNormal does not support dType bool.")
                }
                return new LayerVariable(tfc.truncatedNormal(shape, mean, stddev, dtype, seed), dtype, name)
            }

            exports.truncatedNormalVariable = truncatedNormalVariable;

            function randomNormalVariable(shape, mean, stddev, dtype, seed, name) {
                if (mean === void 0) {
                    mean = 0
                }
                if (stddev === void 0) {
                    stddev = 1
                }
                if (name === void 0) {
                    name = "randomNormal"
                }
                if (dtype === "bool") {
                    throw new errors_1.NotImplementedError("randomNormalVariable does not support dType bool.")
                }
                return new LayerVariable(tfjs_backend_1.randomNormal(shape, mean, stddev, dtype, seed), dtype, name)
            }

            exports.randomNormalVariable = randomNormalVariable;

            function update(x, xNew) {
                return x.write(xNew)
            }

            exports.update = update;

            function updateAdd(x, increment) {
                return x.write(tfc.add(x.read(), increment))
            }

            exports.updateAdd = updateAdd;

            function updateSub(x, decrement) {
                return x.write(tfc.sub(x.read(), decrement))
            }

            exports.updateSub = updateSub;

            function batchGetValue(xs) {
                return xs.map(function (x) {
                    return x.read()
                })
            }

            exports.batchGetValue = batchGetValue;

            function batchSetValue(variablesAndValues) {
                variablesAndValues.map(function (variableAndValue) {
                    var variable = variableAndValue[0];
                    variable.write(variableAndValue[1])
                })
            }

            exports.batchSetValue = batchSetValue
        }, {
            "./backend/tfjs_backend": 158,
            "./common": 160,
            "./errors": 165,
            "./types": 186,
            "@tensorflow/tfjs-core": 50
        }],
        192: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var version = "0.6.2";
            exports.version = version
        }, {}],
        193: [function (require, module, exports) {
            "use strict";

            function __export(m) {
                for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p]
            }

            Object.defineProperty(exports, "__esModule", {value: true});
            __export(require("@tensorflow/tfjs-core"));
            __export(require("@tensorflow/tfjs-layers"));
            __export(require("@tensorflow/tfjs-converter"));
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var tfjs_layers_1 = require("@tensorflow/tfjs-layers");
            var tfjs_converter_1 = require("@tensorflow/tfjs-converter");
            var version_1 = require("./version");
            exports.version = {
                "tfjs-core": tfjs_core_1.version_core,
                "tfjs-layers": tfjs_layers_1.version_layers,
                "tfjs-converter": tfjs_converter_1.version_converter,
                tfjs: version_1.version
            }
        }, {
            "./version": 194,
            "@tensorflow/tfjs-converter": 12,
            "@tensorflow/tfjs-core": 50,
            "@tensorflow/tfjs-layers": 167
        }],
        194: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var version = "0.11.2";
            exports.version = version
        }, {}],
        195: [function (require, module, exports) {
        }, {}],
        196: [function (require, module, exports) {
            (function (global) {
                (function () {
                    var undefined;
                    var VERSION = "4.17.10";
                    var LARGE_ARRAY_SIZE = 200;
                    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
                        FUNC_ERROR_TEXT = "Expected a function";
                    var HASH_UNDEFINED = "__lodash_hash_undefined__";
                    var MAX_MEMOIZE_SIZE = 500;
                    var PLACEHOLDER = "__lodash_placeholder__";
                    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
                    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8,
                        WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64,
                        WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
                    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
                    var HOT_COUNT = 800, HOT_SPAN = 16;
                    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
                    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292,
                        NAN = 0 / 0;
                    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
                    var wrapFlags = [["ary", WRAP_ARY_FLAG], ["bind", WRAP_BIND_FLAG], ["bindKey", WRAP_BIND_KEY_FLAG], ["curry", WRAP_CURRY_FLAG], ["curryRight", WRAP_CURRY_RIGHT_FLAG], ["flip", WRAP_FLIP_FLAG], ["partial", WRAP_PARTIAL_FLAG], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG], ["rearg", WRAP_REARG_FLAG]];
                    var argsTag = "[object Arguments]", arrayTag = "[object Array]",
                        asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]",
                        domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]",
                        genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]",
                        nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]",
                        proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]",
                        stringTag = "[object String]", symbolTag = "[object Symbol]",
                        undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]",
                        weakSetTag = "[object WeakSet]";
                    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]",
                        float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]",
                        int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]",
                        int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]",
                        uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]",
                        uint32Tag = "[object Uint32Array]";
                    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g,
                        reHasEscapedHtml = RegExp(reEscapedHtml.source),
                        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
                    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g,
                        reInterpolate = /<%=([\s\S]+?)%>/g;
                    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/,
                        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
                    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
                    var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/;
                    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
                    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
                    var reEscapeChar = /\\(\\)?/g;
                    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                    var reFlags = /\w*$/;
                    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
                    var reIsBinary = /^0b[01]+$/i;
                    var reIsHostCtor = /^\[object .+?Constructor\]$/;
                    var reIsOctal = /^0o[0-7]+$/i;
                    var reIsUint = /^(?:0|[1-9]\d*)$/;
                    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
                    var reNoMatch = /($^)/;
                    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
                    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f",
                        reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff",
                        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
                        rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
                        rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
                        rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
                        rsPunctuationRange = "\\u2000-\\u206f",
                        rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                        rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f",
                        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
                    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]",
                        rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]",
                        rsLower = "[" + rsLowerRange + "]",
                        rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]",
                        rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
                        rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                        rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]",
                        rsZWJ = "\\u200d";
                    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
                        rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
                        rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
                        rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?",
                        rsOptVar = "[" + rsVarRange + "]?",
                        rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*",
                        rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                        rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                        rsSeq = rsOptVar + reOptMod + rsOptJoin,
                        rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
                        rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
                    var reApos = RegExp(rsApos, "g");
                    var reComboMark = RegExp(rsCombo, "g");
                    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
                    var reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");
                    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
                    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
                    var contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"];
                    var templateCounter = -1;
                    var typedArrayTags = {};
                    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
                    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
                    var cloneableTags = {};
                    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
                    var deburredLetters = {
                        "": "A",
                        "": "A",
                        "": "A",
                        "": "A",
                        "": "A",
                        "": "A",
                        "": "a",
                        "": "a",
                        "": "a",
                        "": "a",
                        "": "a",
                        "": "a",
                        "": "C",
                        "": "c",
                        "": "D",
                        "": "d",
                        "": "E",
                        "": "E",
                        "": "E",
                        "": "E",
                        "": "e",
                        "": "e",
                        "": "e",
                        "": "e",
                        "": "I",
                        "": "I",
                        "": "I",
                        "": "I",
                        "": "i",
                        "": "i",
                        "": "i",
                        "": "i",
                        "": "N",
                        "": "n",
                        "": "O",
                        "": "O",
                        "": "O",
                        "": "O",
                        "": "O",
                        "": "O",
                        "": "o",
                        "": "o",
                        "": "o",
                        "": "o",
                        "": "o",
                        "": "o",
                        "": "U",
                        "": "U",
                        "": "U",
                        "": "U",
                        "": "u",
                        "": "u",
                        "": "u",
                        "": "u",
                        "": "Y",
                        "": "y",
                        "": "y",
                        "": "Ae",
                        "": "ae",
                        "": "Th",
                        "": "th",
                        "": "ss",
                        "": "A",
                        "": "A",
                        "": "A",
                        "": "a",
                        "": "a",
                        "": "a",
                        "": "C",
                        "": "C",
                        "": "C",
                        "": "C",
                        "": "c",
                        "": "c",
                        "": "c",
                        "": "c",
                        "": "D",
                        "": "D",
                        "": "d",
                        "": "d",
                        "": "E",
                        "": "E",
                        "": "E",
                        "": "E",
                        "": "E",
                        "": "e",
                        "": "e",
                        "": "e",
                        "": "e",
                        "": "e",
                        "": "G",
                        "": "G",
                        "": "G",
                        "": "G",
                        "": "g",
                        "": "g",
                        "": "g",
                        "": "g",
                        "": "H",
                        "": "H",
                        "": "h",
                        "": "h",
                        "": "I",
                        "": "I",
                        "": "I",
                        "": "I",
                        "": "I",
                        "": "i",
                        "": "i",
                        "": "i",
                        "": "i",
                        "": "i",
                        "": "J",
                        "": "j",
                        "": "K",
                        "": "k",
                        "": "k",
                        "": "L",
                        "": "L",
                        "": "L",
                        "": "L",
                        "": "L",
                        "": "l",
                        "": "l",
                        "": "l",
                        "": "l",
                        "": "l",
                        "": "N",
                        "": "N",
                        "": "N",
                        "": "N",
                        "": "n",
                        "": "n",
                        "": "n",
                        "": "n",
                        "": "O",
                        "": "O",
                        "": "O",
                        "": "o",
                        "": "o",
                        "": "o",
                        "": "R",
                        "": "R",
                        "": "R",
                        "": "r",
                        "": "r",
                        "": "r",
                        "": "S",
                        "": "S",
                        "": "S",
                        "": "S",
                        "": "s",
                        "": "s",
                        "": "s",
                        "": "s",
                        "": "T",
                        "": "T",
                        "": "T",
                        "": "t",
                        "": "t",
                        "": "t",
                        "": "U",
                        "": "U",
                        "": "U",
                        "": "U",
                        "": "U",
                        "": "U",
                        "": "u",
                        "": "u",
                        "": "u",
                        "": "u",
                        "": "u",
                        "": "u",
                        "": "W",
                        "": "w",
                        "": "Y",
                        "": "y",
                        "": "Y",
                        "": "Z",
                        "": "Z",
                        "": "Z",
                        "": "z",
                        "": "z",
                        "": "z",
                        "": "IJ",
                        "": "ij",
                        "": "Oe",
                        "": "oe",
                        "": "'n",
                        "": "s"
                    };
                    var htmlEscapes = {"&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"};
                    var htmlUnescapes = {"&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'"};
                    var stringEscapes = {
                        "\\": "\\",
                        "'": "'",
                        "\n": "n",
                        "\r": "r",
                        "\u2028": "u2028",
                        "\u2029": "u2029"
                    };
                    var freeParseFloat = parseFloat, freeParseInt = parseInt;
                    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
                    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
                    var root = freeGlobal || freeSelf || Function("return this")();
                    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
                    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
                    var moduleExports = freeModule && freeModule.exports === freeExports;
                    var freeProcess = moduleExports && freeGlobal.process;
                    var nodeUtil = function () {
                        try {
                            var types = freeModule && freeModule.require && freeModule.require("util").types;
                            if (types) {
                                return types
                            }
                            return freeProcess && freeProcess.binding && freeProcess.binding("util")
                        } catch (e) {
                        }
                    }();
                    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
                        nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap,
                        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet,
                        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

                    function apply(func, thisArg, args) {
                        switch (args.length) {
                            case 0:
                                return func.call(thisArg);
                            case 1:
                                return func.call(thisArg, args[0]);
                            case 2:
                                return func.call(thisArg, args[0], args[1]);
                            case 3:
                                return func.call(thisArg, args[0], args[1], args[2])
                        }
                        return func.apply(thisArg, args)
                    }

                    function arrayAggregator(array, setter, iteratee, accumulator) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            var value = array[index];
                            setter(accumulator, value, iteratee(value), array)
                        }
                        return accumulator
                    }

                    function arrayEach(array, iteratee) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            if (iteratee(array[index], index, array) === false) {
                                break
                            }
                        }
                        return array
                    }

                    function arrayEachRight(array, iteratee) {
                        var length = array == null ? 0 : array.length;
                        while (length--) {
                            if (iteratee(array[length], length, array) === false) {
                                break
                            }
                        }
                        return array
                    }

                    function arrayEvery(array, predicate) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            if (!predicate(array[index], index, array)) {
                                return false
                            }
                        }
                        return true
                    }

                    function arrayFilter(array, predicate) {
                        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result[resIndex++] = value
                            }
                        }
                        return result
                    }

                    function arrayIncludes(array, value) {
                        var length = array == null ? 0 : array.length;
                        return !!length && baseIndexOf(array, value, 0) > -1
                    }

                    function arrayIncludesWith(array, value, comparator) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            if (comparator(value, array[index])) {
                                return true
                            }
                        }
                        return false
                    }

                    function arrayMap(array, iteratee) {
                        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                        while (++index < length) {
                            result[index] = iteratee(array[index], index, array)
                        }
                        return result
                    }

                    function arrayPush(array, values) {
                        var index = -1, length = values.length, offset = array.length;
                        while (++index < length) {
                            array[offset + index] = values[index]
                        }
                        return array
                    }

                    function arrayReduce(array, iteratee, accumulator, initAccum) {
                        var index = -1, length = array == null ? 0 : array.length;
                        if (initAccum && length) {
                            accumulator = array[++index]
                        }
                        while (++index < length) {
                            accumulator = iteratee(accumulator, array[index], index, array)
                        }
                        return accumulator
                    }

                    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                        var length = array == null ? 0 : array.length;
                        if (initAccum && length) {
                            accumulator = array[--length]
                        }
                        while (length--) {
                            accumulator = iteratee(accumulator, array[length], length, array)
                        }
                        return accumulator
                    }

                    function arraySome(array, predicate) {
                        var index = -1, length = array == null ? 0 : array.length;
                        while (++index < length) {
                            if (predicate(array[index], index, array)) {
                                return true
                            }
                        }
                        return false
                    }

                    var asciiSize = baseProperty("length");

                    function asciiToArray(string) {
                        return string.split("")
                    }

                    function asciiWords(string) {
                        return string.match(reAsciiWord) || []
                    }

                    function baseFindKey(collection, predicate, eachFunc) {
                        var result;
                        eachFunc(collection, function (value, key, collection) {
                            if (predicate(value, key, collection)) {
                                result = key;
                                return false
                            }
                        });
                        return result
                    }

                    function baseFindIndex(array, predicate, fromIndex, fromRight) {
                        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                        while (fromRight ? index-- : ++index < length) {
                            if (predicate(array[index], index, array)) {
                                return index
                            }
                        }
                        return -1
                    }

                    function baseIndexOf(array, value, fromIndex) {
                        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)
                    }

                    function baseIndexOfWith(array, value, fromIndex, comparator) {
                        var index = fromIndex - 1, length = array.length;
                        while (++index < length) {
                            if (comparator(array[index], value)) {
                                return index
                            }
                        }
                        return -1
                    }

                    function baseIsNaN(value) {
                        return value !== value
                    }

                    function baseMean(array, iteratee) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseSum(array, iteratee) / length : NAN
                    }

                    function baseProperty(key) {
                        return function (object) {
                            return object == null ? undefined : object[key]
                        }
                    }

                    function basePropertyOf(object) {
                        return function (key) {
                            return object == null ? undefined : object[key]
                        }
                    }

                    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                        eachFunc(collection, function (value, index, collection) {
                            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection)
                        });
                        return accumulator
                    }

                    function baseSortBy(array, comparer) {
                        var length = array.length;
                        array.sort(comparer);
                        while (length--) {
                            array[length] = array[length].value
                        }
                        return array
                    }

                    function baseSum(array, iteratee) {
                        var result, index = -1, length = array.length;
                        while (++index < length) {
                            var current = iteratee(array[index]);
                            if (current !== undefined) {
                                result = result === undefined ? current : result + current
                            }
                        }
                        return result
                    }

                    function baseTimes(n, iteratee) {
                        var index = -1, result = Array(n);
                        while (++index < n) {
                            result[index] = iteratee(index)
                        }
                        return result
                    }

                    function baseToPairs(object, props) {
                        return arrayMap(props, function (key) {
                            return [key, object[key]]
                        })
                    }

                    function baseUnary(func) {
                        return function (value) {
                            return func(value)
                        }
                    }

                    function baseValues(object, props) {
                        return arrayMap(props, function (key) {
                            return object[key]
                        })
                    }

                    function cacheHas(cache, key) {
                        return cache.has(key)
                    }

                    function charsStartIndex(strSymbols, chrSymbols) {
                        var index = -1, length = strSymbols.length;
                        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                        }
                        return index
                    }

                    function charsEndIndex(strSymbols, chrSymbols) {
                        var index = strSymbols.length;
                        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                        }
                        return index
                    }

                    function countHolders(array, placeholder) {
                        var length = array.length, result = 0;
                        while (length--) {
                            if (array[length] === placeholder) {
                                ++result
                            }
                        }
                        return result
                    }

                    var deburrLetter = basePropertyOf(deburredLetters);
                    var escapeHtmlChar = basePropertyOf(htmlEscapes);

                    function escapeStringChar(chr) {
                        return "\\" + stringEscapes[chr]
                    }

                    function getValue(object, key) {
                        return object == null ? undefined : object[key]
                    }

                    function hasUnicode(string) {
                        return reHasUnicode.test(string)
                    }

                    function hasUnicodeWord(string) {
                        return reHasUnicodeWord.test(string)
                    }

                    function iteratorToArray(iterator) {
                        var data, result = [];
                        while (!(data = iterator.next()).done) {
                            result.push(data.value)
                        }
                        return result
                    }

                    function mapToArray(map) {
                        var index = -1, result = Array(map.size);
                        map.forEach(function (value, key) {
                            result[++index] = [key, value]
                        });
                        return result
                    }

                    function overArg(func, transform) {
                        return function (arg) {
                            return func(transform(arg))
                        }
                    }

                    function replaceHolders(array, placeholder) {
                        var index = -1, length = array.length, resIndex = 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value === placeholder || value === PLACEHOLDER) {
                                array[index] = PLACEHOLDER;
                                result[resIndex++] = index
                            }
                        }
                        return result
                    }

                    function safeGet(object, key) {
                        return key == "__proto__" ? undefined : object[key]
                    }

                    function setToArray(set) {
                        var index = -1, result = Array(set.size);
                        set.forEach(function (value) {
                            result[++index] = value
                        });
                        return result
                    }

                    function setToPairs(set) {
                        var index = -1, result = Array(set.size);
                        set.forEach(function (value) {
                            result[++index] = [value, value]
                        });
                        return result
                    }

                    function strictIndexOf(array, value, fromIndex) {
                        var index = fromIndex - 1, length = array.length;
                        while (++index < length) {
                            if (array[index] === value) {
                                return index
                            }
                        }
                        return -1
                    }

                    function strictLastIndexOf(array, value, fromIndex) {
                        var index = fromIndex + 1;
                        while (index--) {
                            if (array[index] === value) {
                                return index
                            }
                        }
                        return index
                    }

                    function stringSize(string) {
                        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string)
                    }

                    function stringToArray(string) {
                        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string)
                    }

                    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

                    function unicodeSize(string) {
                        var result = reUnicode.lastIndex = 0;
                        while (reUnicode.test(string)) {
                            ++result
                        }
                        return result
                    }

                    function unicodeToArray(string) {
                        return string.match(reUnicode) || []
                    }

                    function unicodeWords(string) {
                        return string.match(reUnicodeWord) || []
                    }

                    var runInContext = function runInContext(context) {
                        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                        var Array = context.Array, Date = context.Date, Error = context.Error,
                            Function = context.Function, Math = context.Math, Object = context.Object,
                            RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                        var arrayProto = Array.prototype, funcProto = Function.prototype,
                            objectProto = Object.prototype;
                        var coreJsData = context["__core-js_shared__"];
                        var funcToString = funcProto.toString;
                        var hasOwnProperty = objectProto.hasOwnProperty;
                        var idCounter = 0;
                        var maskSrcKey = function () {
                            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                            return uid ? "Symbol(src)_1." + uid : ""
                        }();
                        var nativeObjectToString = objectProto.toString;
                        var objectCtorString = funcToString.call(Object);
                        var oldDash = root._;
                        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                        var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol,
                            Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
                            getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create,
                            propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice,
                            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
                            symIterator = Symbol ? Symbol.iterator : undefined,
                            symToStringTag = Symbol ? Symbol.toStringTag : undefined;
                        var defineProperty = function () {
                            try {
                                var func = getNative(Object, "defineProperty");
                                func({}, "", {});
                                return func
                            } catch (e) {
                            }
                        }();
                        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
                            ctxNow = Date && Date.now !== root.Date.now && Date.now,
                            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                        var nativeCeil = Math.ceil, nativeFloor = Math.floor,
                            nativeGetSymbols = Object.getOwnPropertySymbols,
                            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite,
                            nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object),
                            nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now,
                            nativeParseInt = context.parseInt, nativeRandom = Math.random,
                            nativeReverse = arrayProto.reverse;
                        var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"),
                            Promise = getNative(context, "Promise"), Set = getNative(context, "Set"),
                            WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create");
                        var metaMap = WeakMap && new WeakMap;
                        var realNames = {};
                        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map),
                            promiseCtorString = toSource(Promise), setCtorString = toSource(Set),
                            weakMapCtorString = toSource(WeakMap);
                        var symbolProto = Symbol ? Symbol.prototype : undefined,
                            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
                            symbolToString = symbolProto ? symbolProto.toString : undefined;

                        function lodash(value) {
                            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                                if (value instanceof LodashWrapper) {
                                    return value
                                }
                                if (hasOwnProperty.call(value, "__wrapped__")) {
                                    return wrapperClone(value)
                                }
                            }
                            return new LodashWrapper(value)
                        }

                        var baseCreate = function () {
                            function object() {
                            }

                            return function (proto) {
                                if (!isObject(proto)) {
                                    return {}
                                }
                                if (objectCreate) {
                                    return objectCreate(proto)
                                }
                                object.prototype = proto;
                                var result = new object;
                                object.prototype = undefined;
                                return result
                            }
                        }();

                        function baseLodash() {
                        }

                        function LodashWrapper(value, chainAll) {
                            this.__wrapped__ = value;
                            this.__actions__ = [];
                            this.__chain__ = !!chainAll;
                            this.__index__ = 0;
                            this.__values__ = undefined
                        }

                        lodash.templateSettings = {
                            escape: reEscape,
                            evaluate: reEvaluate,
                            interpolate: reInterpolate,
                            variable: "",
                            imports: {_: lodash}
                        };
                        lodash.prototype = baseLodash.prototype;
                        lodash.prototype.constructor = lodash;
                        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                        LodashWrapper.prototype.constructor = LodashWrapper;

                        function LazyWrapper(value) {
                            this.__wrapped__ = value;
                            this.__actions__ = [];
                            this.__dir__ = 1;
                            this.__filtered__ = false;
                            this.__iteratees__ = [];
                            this.__takeCount__ = MAX_ARRAY_LENGTH;
                            this.__views__ = []
                        }

                        function lazyClone() {
                            var result = new LazyWrapper(this.__wrapped__);
                            result.__actions__ = copyArray(this.__actions__);
                            result.__dir__ = this.__dir__;
                            result.__filtered__ = this.__filtered__;
                            result.__iteratees__ = copyArray(this.__iteratees__);
                            result.__takeCount__ = this.__takeCount__;
                            result.__views__ = copyArray(this.__views__);
                            return result
                        }

                        function lazyReverse() {
                            if (this.__filtered__) {
                                var result = new LazyWrapper(this);
                                result.__dir__ = -1;
                                result.__filtered__ = true
                            } else {
                                result = this.clone();
                                result.__dir__ *= -1
                            }
                            return result
                        }

                        function lazyValue() {
                            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array),
                                isRight = dir < 0, arrLength = isArr ? array.length : 0,
                                view = getView(0, arrLength, this.__views__), start = view.start, end = view.end,
                                length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__,
                                iterLength = iteratees.length, resIndex = 0,
                                takeCount = nativeMin(length, this.__takeCount__);
                            if (!isArr || !isRight && arrLength == length && takeCount == length) {
                                return baseWrapperValue(array, this.__actions__)
                            }
                            var result = [];
                            outer:while (length-- && resIndex < takeCount) {
                                index += dir;
                                var iterIndex = -1, value = array[index];
                                while (++iterIndex < iterLength) {
                                    var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type,
                                        computed = iteratee(value);
                                    if (type == LAZY_MAP_FLAG) {
                                        value = computed
                                    } else if (!computed) {
                                        if (type == LAZY_FILTER_FLAG) {
                                            continue outer
                                        } else {
                                            break outer
                                        }
                                    }
                                }
                                result[resIndex++] = value
                            }
                            return result
                        }

                        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                        LazyWrapper.prototype.constructor = LazyWrapper;

                        function Hash(entries) {
                            var index = -1, length = entries == null ? 0 : entries.length;
                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1])
                            }
                        }

                        function hashClear() {
                            this.__data__ = nativeCreate ? nativeCreate(null) : {};
                            this.size = 0
                        }

                        function hashDelete(key) {
                            var result = this.has(key) && delete this.__data__[key];
                            this.size -= result ? 1 : 0;
                            return result
                        }

                        function hashGet(key) {
                            var data = this.__data__;
                            if (nativeCreate) {
                                var result = data[key];
                                return result === HASH_UNDEFINED ? undefined : result
                            }
                            return hasOwnProperty.call(data, key) ? data[key] : undefined
                        }

                        function hashHas(key) {
                            var data = this.__data__;
                            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key)
                        }

                        function hashSet(key, value) {
                            var data = this.__data__;
                            this.size += this.has(key) ? 0 : 1;
                            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
                            return this
                        }

                        Hash.prototype.clear = hashClear;
                        Hash.prototype["delete"] = hashDelete;
                        Hash.prototype.get = hashGet;
                        Hash.prototype.has = hashHas;
                        Hash.prototype.set = hashSet;

                        function ListCache(entries) {
                            var index = -1, length = entries == null ? 0 : entries.length;
                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1])
                            }
                        }

                        function listCacheClear() {
                            this.__data__ = [];
                            this.size = 0
                        }

                        function listCacheDelete(key) {
                            var data = this.__data__, index = assocIndexOf(data, key);
                            if (index < 0) {
                                return false
                            }
                            var lastIndex = data.length - 1;
                            if (index == lastIndex) {
                                data.pop()
                            } else {
                                splice.call(data, index, 1)
                            }
                            --this.size;
                            return true
                        }

                        function listCacheGet(key) {
                            var data = this.__data__, index = assocIndexOf(data, key);
                            return index < 0 ? undefined : data[index][1]
                        }

                        function listCacheHas(key) {
                            return assocIndexOf(this.__data__, key) > -1
                        }

                        function listCacheSet(key, value) {
                            var data = this.__data__, index = assocIndexOf(data, key);
                            if (index < 0) {
                                ++this.size;
                                data.push([key, value])
                            } else {
                                data[index][1] = value
                            }
                            return this
                        }

                        ListCache.prototype.clear = listCacheClear;
                        ListCache.prototype["delete"] = listCacheDelete;
                        ListCache.prototype.get = listCacheGet;
                        ListCache.prototype.has = listCacheHas;
                        ListCache.prototype.set = listCacheSet;

                        function MapCache(entries) {
                            var index = -1, length = entries == null ? 0 : entries.length;
                            this.clear();
                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1])
                            }
                        }

                        function mapCacheClear() {
                            this.size = 0;
                            this.__data__ = {hash: new Hash, map: new (Map || ListCache), string: new Hash}
                        }

                        function mapCacheDelete(key) {
                            var result = getMapData(this, key)["delete"](key);
                            this.size -= result ? 1 : 0;
                            return result
                        }

                        function mapCacheGet(key) {
                            return getMapData(this, key).get(key)
                        }

                        function mapCacheHas(key) {
                            return getMapData(this, key).has(key)
                        }

                        function mapCacheSet(key, value) {
                            var data = getMapData(this, key), size = data.size;
                            data.set(key, value);
                            this.size += data.size == size ? 0 : 1;
                            return this
                        }

                        MapCache.prototype.clear = mapCacheClear;
                        MapCache.prototype["delete"] = mapCacheDelete;
                        MapCache.prototype.get = mapCacheGet;
                        MapCache.prototype.has = mapCacheHas;
                        MapCache.prototype.set = mapCacheSet;

                        function SetCache(values) {
                            var index = -1, length = values == null ? 0 : values.length;
                            this.__data__ = new MapCache;
                            while (++index < length) {
                                this.add(values[index])
                            }
                        }

                        function setCacheAdd(value) {
                            this.__data__.set(value, HASH_UNDEFINED);
                            return this
                        }

                        function setCacheHas(value) {
                            return this.__data__.has(value)
                        }

                        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                        SetCache.prototype.has = setCacheHas;

                        function Stack(entries) {
                            var data = this.__data__ = new ListCache(entries);
                            this.size = data.size
                        }

                        function stackClear() {
                            this.__data__ = new ListCache;
                            this.size = 0
                        }

                        function stackDelete(key) {
                            var data = this.__data__, result = data["delete"](key);
                            this.size = data.size;
                            return result
                        }

                        function stackGet(key) {
                            return this.__data__.get(key)
                        }

                        function stackHas(key) {
                            return this.__data__.has(key)
                        }

                        function stackSet(key, value) {
                            var data = this.__data__;
                            if (data instanceof ListCache) {
                                var pairs = data.__data__;
                                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                                    pairs.push([key, value]);
                                    this.size = ++data.size;
                                    return this
                                }
                                data = this.__data__ = new MapCache(pairs)
                            }
                            data.set(key, value);
                            this.size = data.size;
                            return this
                        }

                        Stack.prototype.clear = stackClear;
                        Stack.prototype["delete"] = stackDelete;
                        Stack.prototype.get = stackGet;
                        Stack.prototype.has = stackHas;
                        Stack.prototype.set = stackSet;

                        function arrayLikeKeys(value, inherited) {
                            var isArr = isArray(value), isArg = !isArr && isArguments(value),
                                isBuff = !isArr && !isArg && isBuffer(value),
                                isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                                skipIndexes = isArr || isArg || isBuff || isType,
                                result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                            for (var key in value) {
                                if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                                    result.push(key)
                                }
                            }
                            return result
                        }

                        function arraySample(array) {
                            var length = array.length;
                            return length ? array[baseRandom(0, length - 1)] : undefined
                        }

                        function arraySampleSize(array, n) {
                            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length))
                        }

                        function arrayShuffle(array) {
                            return shuffleSelf(copyArray(array))
                        }

                        function assignMergeValue(object, key, value) {
                            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
                                baseAssignValue(object, key, value)
                            }
                        }

                        function assignValue(object, key, value) {
                            var objValue = object[key];
                            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
                                baseAssignValue(object, key, value)
                            }
                        }

                        function assocIndexOf(array, key) {
                            var length = array.length;
                            while (length--) {
                                if (eq(array[length][0], key)) {
                                    return length
                                }
                            }
                            return -1
                        }

                        function baseAggregator(collection, setter, iteratee, accumulator) {
                            baseEach(collection, function (value, key, collection) {
                                setter(accumulator, value, iteratee(value), collection)
                            });
                            return accumulator
                        }

                        function baseAssign(object, source) {
                            return object && copyObject(source, keys(source), object)
                        }

                        function baseAssignIn(object, source) {
                            return object && copyObject(source, keysIn(source), object)
                        }

                        function baseAssignValue(object, key, value) {
                            if (key == "__proto__" && defineProperty) {
                                defineProperty(object, key, {
                                    configurable: true,
                                    enumerable: true,
                                    value: value,
                                    writable: true
                                })
                            } else {
                                object[key] = value
                            }
                        }

                        function baseAt(object, paths) {
                            var index = -1, length = paths.length, result = Array(length), skip = object == null;
                            while (++index < length) {
                                result[index] = skip ? undefined : get(object, paths[index])
                            }
                            return result
                        }

                        function baseClamp(number, lower, upper) {
                            if (number === number) {
                                if (upper !== undefined) {
                                    number = number <= upper ? number : upper
                                }
                                if (lower !== undefined) {
                                    number = number >= lower ? number : lower
                                }
                            }
                            return number
                        }

                        function baseClone(value, bitmask, customizer, key, object, stack) {
                            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG,
                                isFull = bitmask & CLONE_SYMBOLS_FLAG;
                            if (customizer) {
                                result = object ? customizer(value, key, object, stack) : customizer(value)
                            }
                            if (result !== undefined) {
                                return result
                            }
                            if (!isObject(value)) {
                                return value
                            }
                            var isArr = isArray(value);
                            if (isArr) {
                                result = initCloneArray(value);
                                if (!isDeep) {
                                    return copyArray(value, result)
                                }
                            } else {
                                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                                if (isBuffer(value)) {
                                    return cloneBuffer(value, isDeep)
                                }
                                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                                    result = isFlat || isFunc ? {} : initCloneObject(value);
                                    if (!isDeep) {
                                        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value))
                                    }
                                } else {
                                    if (!cloneableTags[tag]) {
                                        return object ? value : {}
                                    }
                                    result = initCloneByTag(value, tag, isDeep)
                                }
                            }
                            stack || (stack = new Stack);
                            var stacked = stack.get(value);
                            if (stacked) {
                                return stacked
                            }
                            stack.set(value, result);
                            if (isSet(value)) {
                                value.forEach(function (subValue) {
                                    result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
                                });
                                return result
                            }
                            if (isMap(value)) {
                                value.forEach(function (subValue, key) {
                                    result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
                                });
                                return result
                            }
                            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                            var props = isArr ? undefined : keysFunc(value);
                            arrayEach(props || value, function (subValue, key) {
                                if (props) {
                                    key = subValue;
                                    subValue = value[key]
                                }
                                assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
                            });
                            return result
                        }

                        function baseConforms(source) {
                            var props = keys(source);
                            return function (object) {
                                return baseConformsTo(object, source, props)
                            }
                        }

                        function baseConformsTo(object, source, props) {
                            var length = props.length;
                            if (object == null) {
                                return !length
                            }
                            object = Object(object);
                            while (length--) {
                                var key = props[length], predicate = source[key], value = object[key];
                                if (value === undefined && !(key in object) || !predicate(value)) {
                                    return false
                                }
                            }
                            return true
                        }

                        function baseDelay(func, wait, args) {
                            if (typeof func != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            return setTimeout(function () {
                                func.apply(undefined, args)
                            }, wait)
                        }

                        function baseDifference(array, values, iteratee, comparator) {
                            var index = -1, includes = arrayIncludes, isCommon = true, length = array.length,
                                result = [], valuesLength = values.length;
                            if (!length) {
                                return result
                            }
                            if (iteratee) {
                                values = arrayMap(values, baseUnary(iteratee))
                            }
                            if (comparator) {
                                includes = arrayIncludesWith;
                                isCommon = false
                            } else if (values.length >= LARGE_ARRAY_SIZE) {
                                includes = cacheHas;
                                isCommon = false;
                                values = new SetCache(values)
                            }
                            outer:while (++index < length) {
                                var value = array[index], computed = iteratee == null ? value : iteratee(value);
                                value = comparator || value !== 0 ? value : 0;
                                if (isCommon && computed === computed) {
                                    var valuesIndex = valuesLength;
                                    while (valuesIndex--) {
                                        if (values[valuesIndex] === computed) {
                                            continue outer
                                        }
                                    }
                                    result.push(value)
                                } else if (!includes(values, computed, comparator)) {
                                    result.push(value)
                                }
                            }
                            return result
                        }

                        var baseEach = createBaseEach(baseForOwn);
                        var baseEachRight = createBaseEach(baseForOwnRight, true);

                        function baseEvery(collection, predicate) {
                            var result = true;
                            baseEach(collection, function (value, index, collection) {
                                result = !!predicate(value, index, collection);
                                return result
                            });
                            return result
                        }

                        function baseExtremum(array, iteratee, comparator) {
                            var index = -1, length = array.length;
                            while (++index < length) {
                                var value = array[index], current = iteratee(value);
                                if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                                    var computed = current, result = value
                                }
                            }
                            return result
                        }

                        function baseFill(array, value, start, end) {
                            var length = array.length;
                            start = toInteger(start);
                            if (start < 0) {
                                start = -start > length ? 0 : length + start
                            }
                            end = end === undefined || end > length ? length : toInteger(end);
                            if (end < 0) {
                                end += length
                            }
                            end = start > end ? 0 : toLength(end);
                            while (start < end) {
                                array[start++] = value
                            }
                            return array
                        }

                        function baseFilter(collection, predicate) {
                            var result = [];
                            baseEach(collection, function (value, index, collection) {
                                if (predicate(value, index, collection)) {
                                    result.push(value)
                                }
                            });
                            return result
                        }

                        function baseFlatten(array, depth, predicate, isStrict, result) {
                            var index = -1, length = array.length;
                            predicate || (predicate = isFlattenable);
                            result || (result = []);
                            while (++index < length) {
                                var value = array[index];
                                if (depth > 0 && predicate(value)) {
                                    if (depth > 1) {
                                        baseFlatten(value, depth - 1, predicate, isStrict, result)
                                    } else {
                                        arrayPush(result, value)
                                    }
                                } else if (!isStrict) {
                                    result[result.length] = value
                                }
                            }
                            return result
                        }

                        var baseFor = createBaseFor();
                        var baseForRight = createBaseFor(true);

                        function baseForOwn(object, iteratee) {
                            return object && baseFor(object, iteratee, keys)
                        }

                        function baseForOwnRight(object, iteratee) {
                            return object && baseForRight(object, iteratee, keys)
                        }

                        function baseFunctions(object, props) {
                            return arrayFilter(props, function (key) {
                                return isFunction(object[key])
                            })
                        }

                        function baseGet(object, path) {
                            path = castPath(path, object);
                            var index = 0, length = path.length;
                            while (object != null && index < length) {
                                object = object[toKey(path[index++])]
                            }
                            return index && index == length ? object : undefined
                        }

                        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                            var result = keysFunc(object);
                            return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
                        }

                        function baseGetTag(value) {
                            if (value == null) {
                                return value === undefined ? undefinedTag : nullTag
                            }
                            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value)
                        }

                        function baseGt(value, other) {
                            return value > other
                        }

                        function baseHas(object, key) {
                            return object != null && hasOwnProperty.call(object, key)
                        }

                        function baseHasIn(object, key) {
                            return object != null && key in Object(object)
                        }

                        function baseInRange(number, start, end) {
                            return number >= nativeMin(start, end) && number < nativeMax(start, end)
                        }

                        function baseIntersection(arrays, iteratee, comparator) {
                            var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length,
                                othLength = arrays.length, othIndex = othLength, caches = Array(othLength),
                                maxLength = Infinity, result = [];
                            while (othIndex--) {
                                var array = arrays[othIndex];
                                if (othIndex && iteratee) {
                                    array = arrayMap(array, baseUnary(iteratee))
                                }
                                maxLength = nativeMin(array.length, maxLength);
                                caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined
                            }
                            array = arrays[0];
                            var index = -1, seen = caches[0];
                            outer:while (++index < length && result.length < maxLength) {
                                var value = array[index], computed = iteratee ? iteratee(value) : value;
                                value = comparator || value !== 0 ? value : 0;
                                if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                                    othIndex = othLength;
                                    while (--othIndex) {
                                        var cache = caches[othIndex];
                                        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                                            continue outer
                                        }
                                    }
                                    if (seen) {
                                        seen.push(computed)
                                    }
                                    result.push(value)
                                }
                            }
                            return result
                        }

                        function baseInverter(object, setter, iteratee, accumulator) {
                            baseForOwn(object, function (value, key, object) {
                                setter(accumulator, iteratee(value), key, object)
                            });
                            return accumulator
                        }

                        function baseInvoke(object, path, args) {
                            path = castPath(path, object);
                            object = parent(object, path);
                            var func = object == null ? object : object[toKey(last(path))];
                            return func == null ? undefined : apply(func, object, args)
                        }

                        function baseIsArguments(value) {
                            return isObjectLike(value) && baseGetTag(value) == argsTag
                        }

                        function baseIsArrayBuffer(value) {
                            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag
                        }

                        function baseIsDate(value) {
                            return isObjectLike(value) && baseGetTag(value) == dateTag
                        }

                        function baseIsEqual(value, other, bitmask, customizer, stack) {
                            if (value === other) {
                                return true
                            }
                            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                                return value !== value && other !== other
                            }
                            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack)
                        }

                        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                            var objIsArr = isArray(object), othIsArr = isArray(other),
                                objTag = objIsArr ? arrayTag : getTag(object),
                                othTag = othIsArr ? arrayTag : getTag(other);
                            objTag = objTag == argsTag ? objectTag : objTag;
                            othTag = othTag == argsTag ? objectTag : othTag;
                            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag,
                                isSameTag = objTag == othTag;
                            if (isSameTag && isBuffer(object)) {
                                if (!isBuffer(other)) {
                                    return false
                                }
                                objIsArr = true;
                                objIsObj = false
                            }
                            if (isSameTag && !objIsObj) {
                                stack || (stack = new Stack);
                                return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack)
                            }
                            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                                var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"),
                                    othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                                if (objIsWrapped || othIsWrapped) {
                                    var objUnwrapped = objIsWrapped ? object.value() : object,
                                        othUnwrapped = othIsWrapped ? other.value() : other;
                                    stack || (stack = new Stack);
                                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)
                                }
                            }
                            if (!isSameTag) {
                                return false
                            }
                            stack || (stack = new Stack);
                            return equalObjects(object, other, bitmask, customizer, equalFunc, stack)
                        }

                        function baseIsMap(value) {
                            return isObjectLike(value) && getTag(value) == mapTag
                        }

                        function baseIsMatch(object, source, matchData, customizer) {
                            var index = matchData.length, length = index, noCustomizer = !customizer;
                            if (object == null) {
                                return !length
                            }
                            object = Object(object);
                            while (index--) {
                                var data = matchData[index];
                                if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                                    return false
                                }
                            }
                            while (++index < length) {
                                data = matchData[index];
                                var key = data[0], objValue = object[key], srcValue = data[1];
                                if (noCustomizer && data[2]) {
                                    if (objValue === undefined && !(key in object)) {
                                        return false
                                    }
                                } else {
                                    var stack = new Stack;
                                    if (customizer) {
                                        var result = customizer(objValue, srcValue, key, object, source, stack)
                                    }
                                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                                        return false
                                    }
                                }
                            }
                            return true
                        }

                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false
                            }
                            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                            return pattern.test(toSource(value))
                        }

                        function baseIsRegExp(value) {
                            return isObjectLike(value) && baseGetTag(value) == regexpTag
                        }

                        function baseIsSet(value) {
                            return isObjectLike(value) && getTag(value) == setTag
                        }

                        function baseIsTypedArray(value) {
                            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]
                        }

                        function baseIteratee(value) {
                            if (typeof value == "function") {
                                return value
                            }
                            if (value == null) {
                                return identity
                            }
                            if (typeof value == "object") {
                                return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value)
                            }
                            return property(value)
                        }

                        function baseKeys(object) {
                            if (!isPrototype(object)) {
                                return nativeKeys(object)
                            }
                            var result = [];
                            for (var key in Object(object)) {
                                if (hasOwnProperty.call(object, key) && key != "constructor") {
                                    result.push(key)
                                }
                            }
                            return result
                        }

                        function baseKeysIn(object) {
                            if (!isObject(object)) {
                                return nativeKeysIn(object)
                            }
                            var isProto = isPrototype(object), result = [];
                            for (var key in object) {
                                if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                                    result.push(key)
                                }
                            }
                            return result
                        }

                        function baseLt(value, other) {
                            return value < other
                        }

                        function baseMap(collection, iteratee) {
                            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                            baseEach(collection, function (value, key, collection) {
                                result[++index] = iteratee(value, key, collection)
                            });
                            return result
                        }

                        function baseMatches(source) {
                            var matchData = getMatchData(source);
                            if (matchData.length == 1 && matchData[0][2]) {
                                return matchesStrictComparable(matchData[0][0], matchData[0][1])
                            }
                            return function (object) {
                                return object === source || baseIsMatch(object, source, matchData)
                            }
                        }

                        function baseMatchesProperty(path, srcValue) {
                            if (isKey(path) && isStrictComparable(srcValue)) {
                                return matchesStrictComparable(toKey(path), srcValue)
                            }
                            return function (object) {
                                var objValue = get(object, path);
                                return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
                            }
                        }

                        function baseMerge(object, source, srcIndex, customizer, stack) {
                            if (object === source) {
                                return
                            }
                            baseFor(source, function (srcValue, key) {
                                if (isObject(srcValue)) {
                                    stack || (stack = new Stack);
                                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack)
                                } else {
                                    var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
                                    if (newValue === undefined) {
                                        newValue = srcValue
                                    }
                                    assignMergeValue(object, key, newValue)
                                }
                            }, keysIn)
                        }

                        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                            var objValue = safeGet(object, key), srcValue = safeGet(source, key),
                                stacked = stack.get(srcValue);
                            if (stacked) {
                                assignMergeValue(object, key, stacked);
                                return
                            }
                            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
                            var isCommon = newValue === undefined;
                            if (isCommon) {
                                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue),
                                    isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                                newValue = srcValue;
                                if (isArr || isBuff || isTyped) {
                                    if (isArray(objValue)) {
                                        newValue = objValue
                                    } else if (isArrayLikeObject(objValue)) {
                                        newValue = copyArray(objValue)
                                    } else if (isBuff) {
                                        isCommon = false;
                                        newValue = cloneBuffer(srcValue, true)
                                    } else if (isTyped) {
                                        isCommon = false;
                                        newValue = cloneTypedArray(srcValue, true)
                                    } else {
                                        newValue = []
                                    }
                                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                    newValue = objValue;
                                    if (isArguments(objValue)) {
                                        newValue = toPlainObject(objValue)
                                    } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
                                        newValue = initCloneObject(srcValue)
                                    }
                                } else {
                                    isCommon = false
                                }
                            }
                            if (isCommon) {
                                stack.set(srcValue, newValue);
                                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                                stack["delete"](srcValue)
                            }
                            assignMergeValue(object, key, newValue)
                        }

                        function baseNth(array, n) {
                            var length = array.length;
                            if (!length) {
                                return
                            }
                            n += n < 0 ? length : 0;
                            return isIndex(n, length) ? array[n] : undefined
                        }

                        function baseOrderBy(collection, iteratees, orders) {
                            var index = -1;
                            iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
                            var result = baseMap(collection, function (value, key, collection) {
                                var criteria = arrayMap(iteratees, function (iteratee) {
                                    return iteratee(value)
                                });
                                return {criteria: criteria, index: ++index, value: value}
                            });
                            return baseSortBy(result, function (object, other) {
                                return compareMultiple(object, other, orders)
                            })
                        }

                        function basePick(object, paths) {
                            return basePickBy(object, paths, function (value, path) {
                                return hasIn(object, path)
                            })
                        }

                        function basePickBy(object, paths, predicate) {
                            var index = -1, length = paths.length, result = {};
                            while (++index < length) {
                                var path = paths[index], value = baseGet(object, path);
                                if (predicate(value, path)) {
                                    baseSet(result, castPath(path, object), value)
                                }
                            }
                            return result
                        }

                        function basePropertyDeep(path) {
                            return function (object) {
                                return baseGet(object, path)
                            }
                        }

                        function basePullAll(array, values, iteratee, comparator) {
                            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1,
                                length = values.length, seen = array;
                            if (array === values) {
                                values = copyArray(values)
                            }
                            if (iteratee) {
                                seen = arrayMap(array, baseUnary(iteratee))
                            }
                            while (++index < length) {
                                var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                                while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                                    if (seen !== array) {
                                        splice.call(seen, fromIndex, 1)
                                    }
                                    splice.call(array, fromIndex, 1)
                                }
                            }
                            return array
                        }

                        function basePullAt(array, indexes) {
                            var length = array ? indexes.length : 0, lastIndex = length - 1;
                            while (length--) {
                                var index = indexes[length];
                                if (length == lastIndex || index !== previous) {
                                    var previous = index;
                                    if (isIndex(index)) {
                                        splice.call(array, index, 1)
                                    } else {
                                        baseUnset(array, index)
                                    }
                                }
                            }
                            return array
                        }

                        function baseRandom(lower, upper) {
                            return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
                        }

                        function baseRange(start, end, step, fromRight) {
                            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                                result = Array(length);
                            while (length--) {
                                result[fromRight ? length : ++index] = start;
                                start += step
                            }
                            return result
                        }

                        function baseRepeat(string, n) {
                            var result = "";
                            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                                return result
                            }
                            do {
                                if (n % 2) {
                                    result += string
                                }
                                n = nativeFloor(n / 2);
                                if (n) {
                                    string += string
                                }
                            } while (n);
                            return result
                        }

                        function baseRest(func, start) {
                            return setToString(overRest(func, start, identity), func + "")
                        }

                        function baseSample(collection) {
                            return arraySample(values(collection))
                        }

                        function baseSampleSize(collection, n) {
                            var array = values(collection);
                            return shuffleSelf(array, baseClamp(n, 0, array.length))
                        }

                        function baseSet(object, path, value, customizer) {
                            if (!isObject(object)) {
                                return object
                            }
                            path = castPath(path, object);
                            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                            while (nested != null && ++index < length) {
                                var key = toKey(path[index]), newValue = value;
                                if (index != lastIndex) {
                                    var objValue = nested[key];
                                    newValue = customizer ? customizer(objValue, key, nested) : undefined;
                                    if (newValue === undefined) {
                                        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {}
                                    }
                                }
                                assignValue(nested, key, newValue);
                                nested = nested[key]
                            }
                            return object
                        }

                        var baseSetData = !metaMap ? identity : function (func, data) {
                            metaMap.set(func, data);
                            return func
                        };
                        var baseSetToString = !defineProperty ? identity : function (func, string) {
                            return defineProperty(func, "toString", {
                                configurable: true,
                                enumerable: false,
                                value: constant(string),
                                writable: true
                            })
                        };

                        function baseShuffle(collection) {
                            return shuffleSelf(values(collection))
                        }

                        function baseSlice(array, start, end) {
                            var index = -1, length = array.length;
                            if (start < 0) {
                                start = -start > length ? 0 : length + start
                            }
                            end = end > length ? length : end;
                            if (end < 0) {
                                end += length
                            }
                            length = start > end ? 0 : end - start >>> 0;
                            start >>>= 0;
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = array[index + start]
                            }
                            return result
                        }

                        function baseSome(collection, predicate) {
                            var result;
                            baseEach(collection, function (value, index, collection) {
                                result = predicate(value, index, collection);
                                return !result
                            });
                            return !!result
                        }

                        function baseSortedIndex(array, value, retHighest) {
                            var low = 0, high = array == null ? low : array.length;
                            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                                while (low < high) {
                                    var mid = low + high >>> 1, computed = array[mid];
                                    if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                                        low = mid + 1
                                    } else {
                                        high = mid
                                    }
                                }
                                return high
                            }
                            return baseSortedIndexBy(array, value, identity, retHighest)
                        }

                        function baseSortedIndexBy(array, value, iteratee, retHighest) {
                            value = iteratee(value);
                            var low = 0, high = array == null ? 0 : array.length, valIsNaN = value !== value,
                                valIsNull = value === null, valIsSymbol = isSymbol(value),
                                valIsUndefined = value === undefined;
                            while (low < high) {
                                var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]),
                                    othIsDefined = computed !== undefined, othIsNull = computed === null,
                                    othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                                if (valIsNaN) {
                                    var setLow = retHighest || othIsReflexive
                                } else if (valIsUndefined) {
                                    setLow = othIsReflexive && (retHighest || othIsDefined)
                                } else if (valIsNull) {
                                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull)
                                } else if (valIsSymbol) {
                                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol)
                                } else if (othIsNull || othIsSymbol) {
                                    setLow = false
                                } else {
                                    setLow = retHighest ? computed <= value : computed < value
                                }
                                if (setLow) {
                                    low = mid + 1
                                } else {
                                    high = mid
                                }
                            }
                            return nativeMin(high, MAX_ARRAY_INDEX)
                        }

                        function baseSortedUniq(array, iteratee) {
                            var index = -1, length = array.length, resIndex = 0, result = [];
                            while (++index < length) {
                                var value = array[index], computed = iteratee ? iteratee(value) : value;
                                if (!index || !eq(computed, seen)) {
                                    var seen = computed;
                                    result[resIndex++] = value === 0 ? 0 : value
                                }
                            }
                            return result
                        }

                        function baseToNumber(value) {
                            if (typeof value == "number") {
                                return value
                            }
                            if (isSymbol(value)) {
                                return NAN
                            }
                            return +value
                        }

                        function baseToString(value) {
                            if (typeof value == "string") {
                                return value
                            }
                            if (isArray(value)) {
                                return arrayMap(value, baseToString) + ""
                            }
                            if (isSymbol(value)) {
                                return symbolToString ? symbolToString.call(value) : ""
                            }
                            var result = value + "";
                            return result == "0" && 1 / value == -INFINITY ? "-0" : result
                        }

                        function baseUniq(array, iteratee, comparator) {
                            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true,
                                result = [], seen = result;
                            if (comparator) {
                                isCommon = false;
                                includes = arrayIncludesWith
                            } else if (length >= LARGE_ARRAY_SIZE) {
                                var set = iteratee ? null : createSet(array);
                                if (set) {
                                    return setToArray(set)
                                }
                                isCommon = false;
                                includes = cacheHas;
                                seen = new SetCache
                            } else {
                                seen = iteratee ? [] : result
                            }
                            outer:while (++index < length) {
                                var value = array[index], computed = iteratee ? iteratee(value) : value;
                                value = comparator || value !== 0 ? value : 0;
                                if (isCommon && computed === computed) {
                                    var seenIndex = seen.length;
                                    while (seenIndex--) {
                                        if (seen[seenIndex] === computed) {
                                            continue outer
                                        }
                                    }
                                    if (iteratee) {
                                        seen.push(computed)
                                    }
                                    result.push(value)
                                } else if (!includes(seen, computed, comparator)) {
                                    if (seen !== result) {
                                        seen.push(computed)
                                    }
                                    result.push(value)
                                }
                            }
                            return result
                        }

                        function baseUnset(object, path) {
                            path = castPath(path, object);
                            object = parent(object, path);
                            return object == null || delete object[toKey(last(path))]
                        }

                        function baseUpdate(object, path, updater, customizer) {
                            return baseSet(object, path, updater(baseGet(object, path)), customizer)
                        }

                        function baseWhile(array, predicate, isDrop, fromRight) {
                            var length = array.length, index = fromRight ? length : -1;
                            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                            }
                            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
                        }

                        function baseWrapperValue(value, actions) {
                            var result = value;
                            if (result instanceof LazyWrapper) {
                                result = result.value()
                            }
                            return arrayReduce(actions, function (result, action) {
                                return action.func.apply(action.thisArg, arrayPush([result], action.args))
                            }, result)
                        }

                        function baseXor(arrays, iteratee, comparator) {
                            var length = arrays.length;
                            if (length < 2) {
                                return length ? baseUniq(arrays[0]) : []
                            }
                            var index = -1, result = Array(length);
                            while (++index < length) {
                                var array = arrays[index], othIndex = -1;
                                while (++othIndex < length) {
                                    if (othIndex != index) {
                                        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator)
                                    }
                                }
                            }
                            return baseUniq(baseFlatten(result, 1), iteratee, comparator)
                        }

                        function baseZipObject(props, values, assignFunc) {
                            var index = -1, length = props.length, valsLength = values.length, result = {};
                            while (++index < length) {
                                var value = index < valsLength ? values[index] : undefined;
                                assignFunc(result, props[index], value)
                            }
                            return result
                        }

                        function castArrayLikeObject(value) {
                            return isArrayLikeObject(value) ? value : []
                        }

                        function castFunction(value) {
                            return typeof value == "function" ? value : identity
                        }

                        function castPath(value, object) {
                            if (isArray(value)) {
                                return value
                            }
                            return isKey(value, object) ? [value] : stringToPath(toString(value))
                        }

                        var castRest = baseRest;

                        function castSlice(array, start, end) {
                            var length = array.length;
                            end = end === undefined ? length : end;
                            return !start && end >= length ? array : baseSlice(array, start, end)
                        }

                        var clearTimeout = ctxClearTimeout || function (id) {
                            return root.clearTimeout(id)
                        };

                        function cloneBuffer(buffer, isDeep) {
                            if (isDeep) {
                                return buffer.slice()
                            }
                            var length = buffer.length,
                                result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                            buffer.copy(result);
                            return result
                        }

                        function cloneArrayBuffer(arrayBuffer) {
                            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                            return result
                        }

                        function cloneDataView(dataView, isDeep) {
                            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
                        }

                        function cloneRegExp(regexp) {
                            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                            result.lastIndex = regexp.lastIndex;
                            return result
                        }

                        function cloneSymbol(symbol) {
                            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
                        }

                        function cloneTypedArray(typedArray, isDeep) {
                            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)
                        }

                        function compareAscending(value, other) {
                            if (value !== other) {
                                var valIsDefined = value !== undefined, valIsNull = value === null,
                                    valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                                var othIsDefined = other !== undefined, othIsNull = other === null,
                                    othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                                if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                                    return 1
                                }
                                if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                                    return -1
                                }
                            }
                            return 0
                        }

                        function compareMultiple(object, other, orders) {
                            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria,
                                length = objCriteria.length, ordersLength = orders.length;
                            while (++index < length) {
                                var result = compareAscending(objCriteria[index], othCriteria[index]);
                                if (result) {
                                    if (index >= ordersLength) {
                                        return result
                                    }
                                    var order = orders[index];
                                    return result * (order == "desc" ? -1 : 1)
                                }
                            }
                            return object.index - other.index
                        }

                        function composeArgs(args, partials, holders, isCurried) {
                            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length,
                                leftIndex = -1, leftLength = partials.length,
                                rangeLength = nativeMax(argsLength - holdersLength, 0),
                                result = Array(leftLength + rangeLength), isUncurried = !isCurried;
                            while (++leftIndex < leftLength) {
                                result[leftIndex] = partials[leftIndex]
                            }
                            while (++argsIndex < holdersLength) {
                                if (isUncurried || argsIndex < argsLength) {
                                    result[holders[argsIndex]] = args[argsIndex]
                                }
                            }
                            while (rangeLength--) {
                                result[leftIndex++] = args[argsIndex++]
                            }
                            return result
                        }

                        function composeArgsRight(args, partials, holders, isCurried) {
                            var argsIndex = -1, argsLength = args.length, holdersIndex = -1,
                                holdersLength = holders.length, rightIndex = -1, rightLength = partials.length,
                                rangeLength = nativeMax(argsLength - holdersLength, 0),
                                result = Array(rangeLength + rightLength), isUncurried = !isCurried;
                            while (++argsIndex < rangeLength) {
                                result[argsIndex] = args[argsIndex]
                            }
                            var offset = argsIndex;
                            while (++rightIndex < rightLength) {
                                result[offset + rightIndex] = partials[rightIndex]
                            }
                            while (++holdersIndex < holdersLength) {
                                if (isUncurried || argsIndex < argsLength) {
                                    result[offset + holders[holdersIndex]] = args[argsIndex++]
                                }
                            }
                            return result
                        }

                        function copyArray(source, array) {
                            var index = -1, length = source.length;
                            array || (array = Array(length));
                            while (++index < length) {
                                array[index] = source[index]
                            }
                            return array
                        }

                        function copyObject(source, props, object, customizer) {
                            var isNew = !object;
                            object || (object = {});
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                                if (newValue === undefined) {
                                    newValue = source[key]
                                }
                                if (isNew) {
                                    baseAssignValue(object, key, newValue)
                                } else {
                                    assignValue(object, key, newValue)
                                }
                            }
                            return object
                        }

                        function copySymbols(source, object) {
                            return copyObject(source, getSymbols(source), object)
                        }

                        function copySymbolsIn(source, object) {
                            return copyObject(source, getSymbolsIn(source), object)
                        }

                        function createAggregator(setter, initializer) {
                            return function (collection, iteratee) {
                                var func = isArray(collection) ? arrayAggregator : baseAggregator,
                                    accumulator = initializer ? initializer() : {};
                                return func(collection, setter, getIteratee(iteratee, 2), accumulator)
                            }
                        }

                        function createAssigner(assigner) {
                            return baseRest(function (object, sources) {
                                var index = -1, length = sources.length,
                                    customizer = length > 1 ? sources[length - 1] : undefined,
                                    guard = length > 2 ? sources[2] : undefined;
                                customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
                                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                    customizer = length < 3 ? undefined : customizer;
                                    length = 1
                                }
                                object = Object(object);
                                while (++index < length) {
                                    var source = sources[index];
                                    if (source) {
                                        assigner(object, source, index, customizer)
                                    }
                                }
                                return object
                            })
                        }

                        function createBaseEach(eachFunc, fromRight) {
                            return function (collection, iteratee) {
                                if (collection == null) {
                                    return collection
                                }
                                if (!isArrayLike(collection)) {
                                    return eachFunc(collection, iteratee)
                                }
                                var length = collection.length, index = fromRight ? length : -1,
                                    iterable = Object(collection);
                                while (fromRight ? index-- : ++index < length) {
                                    if (iteratee(iterable[index], index, iterable) === false) {
                                        break
                                    }
                                }
                                return collection
                            }
                        }

                        function createBaseFor(fromRight) {
                            return function (object, iteratee, keysFunc) {
                                var index = -1, iterable = Object(object), props = keysFunc(object),
                                    length = props.length;
                                while (length--) {
                                    var key = props[fromRight ? length : ++index];
                                    if (iteratee(iterable[key], key, iterable) === false) {
                                        break
                                    }
                                }
                                return object
                            }
                        }

                        function createBind(func, bitmask, thisArg) {
                            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);

                            function wrapper() {
                                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                                return fn.apply(isBind ? thisArg : this, arguments)
                            }

                            return wrapper
                        }

                        function createCaseFirst(methodName) {
                            return function (string) {
                                string = toString(string);
                                var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
                                var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                                var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                                return chr[methodName]() + trailing
                            }
                        }

                        function createCompounder(callback) {
                            return function (string) {
                                return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "")
                            }
                        }

                        function createCtor(Ctor) {
                            return function () {
                                var args = arguments;
                                switch (args.length) {
                                    case 0:
                                        return new Ctor;
                                    case 1:
                                        return new Ctor(args[0]);
                                    case 2:
                                        return new Ctor(args[0], args[1]);
                                    case 3:
                                        return new Ctor(args[0], args[1], args[2]);
                                    case 4:
                                        return new Ctor(args[0], args[1], args[2], args[3]);
                                    case 5:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                    case 6:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                    case 7:
                                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
                                }
                                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding
                            }
                        }

                        function createCurry(func, bitmask, arity) {
                            var Ctor = createCtor(func);

                            function wrapper() {
                                var length = arguments.length, args = Array(length), index = length,
                                    placeholder = getHolder(wrapper);
                                while (index--) {
                                    args[index] = arguments[index]
                                }
                                var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                                length -= holders.length;
                                if (length < arity) {
                                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length)
                                }
                                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                                return apply(fn, this, args)
                            }

                            return wrapper
                        }

                        function createFind(findIndexFunc) {
                            return function (collection, predicate, fromIndex) {
                                var iterable = Object(collection);
                                if (!isArrayLike(collection)) {
                                    var iteratee = getIteratee(predicate, 3);
                                    collection = keys(collection);
                                    predicate = function (key) {
                                        return iteratee(iterable[key], key, iterable)
                                    }
                                }
                                var index = findIndexFunc(collection, predicate, fromIndex);
                                return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined
                            }
                        }

                        function createFlow(fromRight) {
                            return flatRest(function (funcs) {
                                var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                                if (fromRight) {
                                    funcs.reverse()
                                }
                                while (index--) {
                                    var func = funcs[index];
                                    if (typeof func != "function") {
                                        throw new TypeError(FUNC_ERROR_TEXT)
                                    }
                                    if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                                        var wrapper = new LodashWrapper([], true)
                                    }
                                }
                                index = wrapper ? index : length;
                                while (++index < length) {
                                    func = funcs[index];
                                    var funcName = getFuncName(func),
                                        data = funcName == "wrapper" ? getData(func) : undefined;
                                    if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3])
                                    } else {
                                        wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func)
                                    }
                                }
                                return function () {
                                    var args = arguments, value = args[0];
                                    if (wrapper && args.length == 1 && isArray(value)) {
                                        return wrapper.plant(value).value()
                                    }
                                    var index = 0, result = length ? funcs[index].apply(this, args) : value;
                                    while (++index < length) {
                                        result = funcs[index].call(this, result)
                                    }
                                    return result
                                }
                            })
                        }

                        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG,
                                isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                                isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                                isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);

                            function wrapper() {
                                var length = arguments.length, args = Array(length), index = length;
                                while (index--) {
                                    args[index] = arguments[index]
                                }
                                if (isCurried) {
                                    var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder)
                                }
                                if (partials) {
                                    args = composeArgs(args, partials, holders, isCurried)
                                }
                                if (partialsRight) {
                                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried)
                                }
                                length -= holdersCount;
                                if (isCurried && length < arity) {
                                    var newHolders = replaceHolders(args, placeholder);
                                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length)
                                }
                                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                                length = args.length;
                                if (argPos) {
                                    args = reorder(args, argPos)
                                } else if (isFlip && length > 1) {
                                    args.reverse()
                                }
                                if (isAry && ary < length) {
                                    args.length = ary
                                }
                                if (this && this !== root && this instanceof wrapper) {
                                    fn = Ctor || createCtor(fn)
                                }
                                return fn.apply(thisBinding, args)
                            }

                            return wrapper
                        }

                        function createInverter(setter, toIteratee) {
                            return function (object, iteratee) {
                                return baseInverter(object, setter, toIteratee(iteratee), {})
                            }
                        }

                        function createMathOperation(operator, defaultValue) {
                            return function (value, other) {
                                var result;
                                if (value === undefined && other === undefined) {
                                    return defaultValue
                                }
                                if (value !== undefined) {
                                    result = value
                                }
                                if (other !== undefined) {
                                    if (result === undefined) {
                                        return other
                                    }
                                    if (typeof value == "string" || typeof other == "string") {
                                        value = baseToString(value);
                                        other = baseToString(other)
                                    } else {
                                        value = baseToNumber(value);
                                        other = baseToNumber(other)
                                    }
                                    result = operator(value, other)
                                }
                                return result
                            }
                        }

                        function createOver(arrayFunc) {
                            return flatRest(function (iteratees) {
                                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                                return baseRest(function (args) {
                                    var thisArg = this;
                                    return arrayFunc(iteratees, function (iteratee) {
                                        return apply(iteratee, thisArg, args)
                                    })
                                })
                            })
                        }

                        function createPadding(length, chars) {
                            chars = chars === undefined ? " " : baseToString(chars);
                            var charsLength = chars.length;
                            if (charsLength < 2) {
                                return charsLength ? baseRepeat(chars, length) : chars
                            }
                            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length)
                        }

                        function createPartial(func, bitmask, thisArg, partials) {
                            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);

                            function wrapper() {
                                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1,
                                    leftLength = partials.length, args = Array(leftLength + argsLength),
                                    fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                                while (++leftIndex < leftLength) {
                                    args[leftIndex] = partials[leftIndex]
                                }
                                while (argsLength--) {
                                    args[leftIndex++] = arguments[++argsIndex]
                                }
                                return apply(fn, isBind ? thisArg : this, args)
                            }

                            return wrapper
                        }

                        function createRange(fromRight) {
                            return function (start, end, step) {
                                if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                                    end = step = undefined
                                }
                                start = toFinite(start);
                                if (end === undefined) {
                                    end = start;
                                    start = 0
                                } else {
                                    end = toFinite(end)
                                }
                                step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
                                return baseRange(start, end, step, fromRight)
                            }
                        }

                        function createRelationalOperation(operator) {
                            return function (value, other) {
                                if (!(typeof value == "string" && typeof other == "string")) {
                                    value = toNumber(value);
                                    other = toNumber(other)
                                }
                                return operator(value, other)
                            }
                        }

                        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined,
                                newHoldersRight = isCurry ? undefined : holders,
                                newPartials = isCurry ? partials : undefined,
                                newPartialsRight = isCurry ? undefined : partials;
                            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                                bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG)
                            }
                            var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
                            var result = wrapFunc.apply(undefined, newData);
                            if (isLaziable(func)) {
                                setData(result, newData)
                            }
                            result.placeholder = placeholder;
                            return setWrapToString(result, func, bitmask)
                        }

                        function createRound(methodName) {
                            var func = Math[methodName];
                            return function (number, precision) {
                                number = toNumber(number);
                                precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                                if (precision) {
                                    var pair = (toString(number) + "e").split("e"),
                                        value = func(pair[0] + "e" + (+pair[1] + precision));
                                    pair = (toString(value) + "e").split("e");
                                    return +(pair[0] + "e" + (+pair[1] - precision))
                                }
                                return func(number)
                            }
                        }

                        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
                            return new Set(values)
                        };

                        function createToPairs(keysFunc) {
                            return function (object) {
                                var tag = getTag(object);
                                if (tag == mapTag) {
                                    return mapToArray(object)
                                }
                                if (tag == setTag) {
                                    return setToPairs(object)
                                }
                                return baseToPairs(object, keysFunc(object))
                            }
                        }

                        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                            if (!isBindKey && typeof func != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            var length = partials ? partials.length : 0;
                            if (!length) {
                                bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                                partials = holders = undefined
                            }
                            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
                            arity = arity === undefined ? arity : toInteger(arity);
                            length -= holders ? holders.length : 0;
                            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                                var partialsRight = partials, holdersRight = holders;
                                partials = holders = undefined
                            }
                            var data = isBindKey ? undefined : getData(func);
                            var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
                            if (data) {
                                mergeData(newData, data)
                            }
                            func = newData[0];
                            bitmask = newData[1];
                            thisArg = newData[2];
                            partials = newData[3];
                            holders = newData[4];
                            arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                                bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)
                            }
                            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                                var result = createBind(func, bitmask, thisArg)
                            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                                result = createCurry(func, bitmask, arity)
                            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                                result = createPartial(func, bitmask, thisArg, partials)
                            } else {
                                result = createHybrid.apply(undefined, newData)
                            }
                            var setter = data ? baseSetData : setData;
                            return setWrapToString(setter(result, newData), func, bitmask)
                        }

                        function customDefaultsAssignIn(objValue, srcValue, key, object) {
                            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                                return srcValue
                            }
                            return objValue
                        }

                        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                            if (isObject(objValue) && isObject(srcValue)) {
                                stack.set(srcValue, objValue);
                                baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
                                stack["delete"](srcValue)
                            }
                            return objValue
                        }

                        function customOmitClone(value) {
                            return isPlainObject(value) ? undefined : value
                        }

                        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length,
                                othLength = other.length;
                            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                                return false
                            }
                            var stacked = stack.get(array);
                            if (stacked && stack.get(other)) {
                                return stacked == other
                            }
                            var index = -1, result = true,
                                seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
                            stack.set(array, other);
                            stack.set(other, array);
                            while (++index < arrLength) {
                                var arrValue = array[index], othValue = other[index];
                                if (customizer) {
                                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack)
                                }
                                if (compared !== undefined) {
                                    if (compared) {
                                        continue
                                    }
                                    result = false;
                                    break
                                }
                                if (seen) {
                                    if (!arraySome(other, function (othValue, othIndex) {
                                        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                            return seen.push(othIndex)
                                        }
                                    })) {
                                        result = false;
                                        break
                                    }
                                } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                    result = false;
                                    break
                                }
                            }
                            stack["delete"](array);
                            stack["delete"](other);
                            return result
                        }

                        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                            switch (tag) {
                                case dataViewTag:
                                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                                        return false
                                    }
                                    object = object.buffer;
                                    other = other.buffer;
                                case arrayBufferTag:
                                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                                        return false
                                    }
                                    return true;
                                case boolTag:
                                case dateTag:
                                case numberTag:
                                    return eq(+object, +other);
                                case errorTag:
                                    return object.name == other.name && object.message == other.message;
                                case regexpTag:
                                case stringTag:
                                    return object == other + "";
                                case mapTag:
                                    var convert = mapToArray;
                                case setTag:
                                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                                    convert || (convert = setToArray);
                                    if (object.size != other.size && !isPartial) {
                                        return false
                                    }
                                    var stacked = stack.get(object);
                                    if (stacked) {
                                        return stacked == other
                                    }
                                    bitmask |= COMPARE_UNORDERED_FLAG;
                                    stack.set(object, other);
                                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                                    stack["delete"](object);
                                    return result;
                                case symbolTag:
                                    if (symbolValueOf) {
                                        return symbolValueOf.call(object) == symbolValueOf.call(other)
                                    }
                            }
                            return false
                        }

                        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object),
                                objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                            if (objLength != othLength && !isPartial) {
                                return false
                            }
                            var index = objLength;
                            while (index--) {
                                var key = objProps[index];
                                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                                    return false
                                }
                            }
                            var stacked = stack.get(object);
                            if (stacked && stack.get(other)) {
                                return stacked == other
                            }
                            var result = true;
                            stack.set(object, other);
                            stack.set(other, object);
                            var skipCtor = isPartial;
                            while (++index < objLength) {
                                key = objProps[index];
                                var objValue = object[key], othValue = other[key];
                                if (customizer) {
                                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack)
                                }
                                if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                                    result = false;
                                    break
                                }
                                skipCtor || (skipCtor = key == "constructor")
                            }
                            if (result && !skipCtor) {
                                var objCtor = object.constructor, othCtor = other.constructor;
                                if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                                    result = false
                                }
                            }
                            stack["delete"](object);
                            stack["delete"](other);
                            return result
                        }

                        function flatRest(func) {
                            return setToString(overRest(func, undefined, flatten), func + "")
                        }

                        function getAllKeys(object) {
                            return baseGetAllKeys(object, keys, getSymbols)
                        }

                        function getAllKeysIn(object) {
                            return baseGetAllKeys(object, keysIn, getSymbolsIn)
                        }

                        var getData = !metaMap ? noop : function (func) {
                            return metaMap.get(func)
                        };

                        function getFuncName(func) {
                            var result = func.name + "", array = realNames[result],
                                length = hasOwnProperty.call(realNames, result) ? array.length : 0;
                            while (length--) {
                                var data = array[length], otherFunc = data.func;
                                if (otherFunc == null || otherFunc == func) {
                                    return data.name
                                }
                            }
                            return result
                        }

                        function getHolder(func) {
                            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
                            return object.placeholder
                        }

                        function getIteratee() {
                            var result = lodash.iteratee || iteratee;
                            result = result === iteratee ? baseIteratee : result;
                            return arguments.length ? result(arguments[0], arguments[1]) : result
                        }

                        function getMapData(map, key) {
                            var data = map.__data__;
                            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map
                        }

                        function getMatchData(object) {
                            var result = keys(object), length = result.length;
                            while (length--) {
                                var key = result[length], value = object[key];
                                result[length] = [key, value, isStrictComparable(value)]
                            }
                            return result
                        }

                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined
                        }

                        function getRawTag(value) {
                            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                            try {
                                value[symToStringTag] = undefined;
                                var unmasked = true
                            } catch (e) {
                            }
                            var result = nativeObjectToString.call(value);
                            if (unmasked) {
                                if (isOwn) {
                                    value[symToStringTag] = tag
                                } else {
                                    delete value[symToStringTag]
                                }
                            }
                            return result
                        }

                        var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
                            if (object == null) {
                                return []
                            }
                            object = Object(object);
                            return arrayFilter(nativeGetSymbols(object), function (symbol) {
                                return propertyIsEnumerable.call(object, symbol)
                            })
                        };
                        var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
                            var result = [];
                            while (object) {
                                arrayPush(result, getSymbols(object));
                                object = getPrototype(object)
                            }
                            return result
                        };
                        var getTag = baseGetTag;
                        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) {
                            getTag = function (value) {
                                var result = baseGetTag(value),
                                    Ctor = result == objectTag ? value.constructor : undefined,
                                    ctorString = Ctor ? toSource(Ctor) : "";
                                if (ctorString) {
                                    switch (ctorString) {
                                        case dataViewCtorString:
                                            return dataViewTag;
                                        case mapCtorString:
                                            return mapTag;
                                        case promiseCtorString:
                                            return promiseTag;
                                        case setCtorString:
                                            return setTag;
                                        case weakMapCtorString:
                                            return weakMapTag
                                    }
                                }
                                return result
                            }
                        }

                        function getView(start, end, transforms) {
                            var index = -1, length = transforms.length;
                            while (++index < length) {
                                var data = transforms[index], size = data.size;
                                switch (data.type) {
                                    case"drop":
                                        start += size;
                                        break;
                                    case"dropRight":
                                        end -= size;
                                        break;
                                    case"take":
                                        end = nativeMin(end, start + size);
                                        break;
                                    case"takeRight":
                                        start = nativeMax(start, end - size);
                                        break
                                }
                            }
                            return {start: start, end: end}
                        }

                        function getWrapDetails(source) {
                            var match = source.match(reWrapDetails);
                            return match ? match[1].split(reSplitDetails) : []
                        }

                        function hasPath(object, path, hasFunc) {
                            path = castPath(path, object);
                            var index = -1, length = path.length, result = false;
                            while (++index < length) {
                                var key = toKey(path[index]);
                                if (!(result = object != null && hasFunc(object, key))) {
                                    break
                                }
                                object = object[key]
                            }
                            if (result || ++index != length) {
                                return result
                            }
                            length = object == null ? 0 : object.length;
                            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object))
                        }

                        function initCloneArray(array) {
                            var length = array.length, result = new array.constructor(length);
                            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                                result.index = array.index;
                                result.input = array.input
                            }
                            return result
                        }

                        function initCloneObject(object) {
                            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {}
                        }

                        function initCloneByTag(object, tag, isDeep) {
                            var Ctor = object.constructor;
                            switch (tag) {
                                case arrayBufferTag:
                                    return cloneArrayBuffer(object);
                                case boolTag:
                                case dateTag:
                                    return new Ctor(+object);
                                case dataViewTag:
                                    return cloneDataView(object, isDeep);
                                case float32Tag:
                                case float64Tag:
                                case int8Tag:
                                case int16Tag:
                                case int32Tag:
                                case uint8Tag:
                                case uint8ClampedTag:
                                case uint16Tag:
                                case uint32Tag:
                                    return cloneTypedArray(object, isDeep);
                                case mapTag:
                                    return new Ctor;
                                case numberTag:
                                case stringTag:
                                    return new Ctor(object);
                                case regexpTag:
                                    return cloneRegExp(object);
                                case setTag:
                                    return new Ctor;
                                case symbolTag:
                                    return cloneSymbol(object)
                            }
                        }

                        function insertWrapDetails(source, details) {
                            var length = details.length;
                            if (!length) {
                                return source
                            }
                            var lastIndex = length - 1;
                            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                            details = details.join(length > 2 ? ", " : " ");
                            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n")
                        }

                        function isFlattenable(value) {
                            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol])
                        }

                        function isIndex(value, length) {
                            var type = typeof value;
                            length = length == null ? MAX_SAFE_INTEGER : length;
                            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length)
                        }

                        function isIterateeCall(value, index, object) {
                            if (!isObject(object)) {
                                return false
                            }
                            var type = typeof index;
                            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                                return eq(object[index], value)
                            }
                            return false
                        }

                        function isKey(value, object) {
                            if (isArray(value)) {
                                return false
                            }
                            var type = typeof value;
                            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                                return true
                            }
                            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object)
                        }

                        function isKeyable(value) {
                            var type = typeof value;
                            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null
                        }

                        function isLaziable(func) {
                            var funcName = getFuncName(func), other = lodash[funcName];
                            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                                return false
                            }
                            if (func === other) {
                                return true
                            }
                            var data = getData(other);
                            return !!data && func === data[0]
                        }

                        function isMasked(func) {
                            return !!maskSrcKey && maskSrcKey in func
                        }

                        var isMaskable = coreJsData ? isFunction : stubFalse;

                        function isPrototype(value) {
                            var Ctor = value && value.constructor,
                                proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                            return value === proto
                        }

                        function isStrictComparable(value) {
                            return value === value && !isObject(value)
                        }

                        function matchesStrictComparable(key, srcValue) {
                            return function (object) {
                                if (object == null) {
                                    return false
                                }
                                return object[key] === srcValue && (srcValue !== undefined || key in Object(object))
                            }
                        }

                        function memoizeCapped(func) {
                            var result = memoize(func, function (key) {
                                if (cache.size === MAX_MEMOIZE_SIZE) {
                                    cache.clear()
                                }
                                return key
                            });
                            var cache = result.cache;
                            return result
                        }

                        function mergeData(data, source) {
                            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask,
                                isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                            if (!(isCommon || isCombo)) {
                                return data
                            }
                            if (srcBitmask & WRAP_BIND_FLAG) {
                                data[2] = source[2];
                                newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG
                            }
                            var value = source[3];
                            if (value) {
                                var partials = data[3];
                                data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]
                            }
                            value = source[5];
                            if (value) {
                                partials = data[5];
                                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]
                            }
                            value = source[7];
                            if (value) {
                                data[7] = value
                            }
                            if (srcBitmask & WRAP_ARY_FLAG) {
                                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8])
                            }
                            if (data[9] == null) {
                                data[9] = source[9]
                            }
                            data[0] = source[0];
                            data[1] = newBitmask;
                            return data
                        }

                        function nativeKeysIn(object) {
                            var result = [];
                            if (object != null) {
                                for (var key in Object(object)) {
                                    result.push(key)
                                }
                            }
                            return result
                        }

                        function objectToString(value) {
                            return nativeObjectToString.call(value)
                        }

                        function overRest(func, start, transform) {
                            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
                            return function () {
                                var args = arguments, index = -1, length = nativeMax(args.length - start, 0),
                                    array = Array(length);
                                while (++index < length) {
                                    array[index] = args[start + index]
                                }
                                index = -1;
                                var otherArgs = Array(start + 1);
                                while (++index < start) {
                                    otherArgs[index] = args[index]
                                }
                                otherArgs[start] = transform(array);
                                return apply(func, this, otherArgs)
                            }
                        }

                        function parent(object, path) {
                            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1))
                        }

                        function reorder(array, indexes) {
                            var arrLength = array.length, length = nativeMin(indexes.length, arrLength),
                                oldArray = copyArray(array);
                            while (length--) {
                                var index = indexes[length];
                                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
                            }
                            return array
                        }

                        var setData = shortOut(baseSetData);
                        var setTimeout = ctxSetTimeout || function (func, wait) {
                            return root.setTimeout(func, wait)
                        };
                        var setToString = shortOut(baseSetToString);

                        function setWrapToString(wrapper, reference, bitmask) {
                            var source = reference + "";
                            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
                        }

                        function shortOut(func) {
                            var count = 0, lastCalled = 0;
                            return function () {
                                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                                lastCalled = stamp;
                                if (remaining > 0) {
                                    if (++count >= HOT_COUNT) {
                                        return arguments[0]
                                    }
                                } else {
                                    count = 0
                                }
                                return func.apply(undefined, arguments)
                            }
                        }

                        function shuffleSelf(array, size) {
                            var index = -1, length = array.length, lastIndex = length - 1;
                            size = size === undefined ? length : size;
                            while (++index < size) {
                                var rand = baseRandom(index, lastIndex), value = array[rand];
                                array[rand] = array[index];
                                array[index] = value
                            }
                            array.length = size;
                            return array
                        }

                        var stringToPath = memoizeCapped(function (string) {
                            var result = [];
                            if (string.charCodeAt(0) === 46) {
                                result.push("")
                            }
                            string.replace(rePropName, function (match, number, quote, subString) {
                                result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match)
                            });
                            return result
                        });

                        function toKey(value) {
                            if (typeof value == "string" || isSymbol(value)) {
                                return value
                            }
                            var result = value + "";
                            return result == "0" && 1 / value == -INFINITY ? "-0" : result
                        }

                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func)
                                } catch (e) {
                                }
                                try {
                                    return func + ""
                                } catch (e) {
                                }
                            }
                            return ""
                        }

                        function updateWrapDetails(details, bitmask) {
                            arrayEach(wrapFlags, function (pair) {
                                var value = "_." + pair[0];
                                if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                                    details.push(value)
                                }
                            });
                            return details.sort()
                        }

                        function wrapperClone(wrapper) {
                            if (wrapper instanceof LazyWrapper) {
                                return wrapper.clone()
                            }
                            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                            result.__actions__ = copyArray(wrapper.__actions__);
                            result.__index__ = wrapper.__index__;
                            result.__values__ = wrapper.__values__;
                            return result
                        }

                        function chunk(array, size, guard) {
                            if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
                                size = 1
                            } else {
                                size = nativeMax(toInteger(size), 0)
                            }
                            var length = array == null ? 0 : array.length;
                            if (!length || size < 1) {
                                return []
                            }
                            var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
                            while (index < length) {
                                result[resIndex++] = baseSlice(array, index, index += size)
                            }
                            return result
                        }

                        function compact(array) {
                            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                            while (++index < length) {
                                var value = array[index];
                                if (value) {
                                    result[resIndex++] = value
                                }
                            }
                            return result
                        }

                        function concat() {
                            var length = arguments.length;
                            if (!length) {
                                return []
                            }
                            var args = Array(length - 1), array = arguments[0], index = length;
                            while (index--) {
                                args[index - 1] = arguments[index]
                            }
                            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1))
                        }

                        var difference = baseRest(function (array, values) {
                            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []
                        });
                        var differenceBy = baseRest(function (array, values) {
                            var iteratee = last(values);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined
                            }
                            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : []
                        });
                        var differenceWith = baseRest(function (array, values) {
                            var comparator = last(values);
                            if (isArrayLikeObject(comparator)) {
                                comparator = undefined
                            }
                            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : []
                        });

                        function drop(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return []
                            }
                            n = guard || n === undefined ? 1 : toInteger(n);
                            return baseSlice(array, n < 0 ? 0 : n, length)
                        }

                        function dropRight(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return []
                            }
                            n = guard || n === undefined ? 1 : toInteger(n);
                            n = length - n;
                            return baseSlice(array, 0, n < 0 ? 0 : n)
                        }

                        function dropRightWhile(array, predicate) {
                            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : []
                        }

                        function dropWhile(array, predicate) {
                            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : []
                        }

                        function fill(array, value, start, end) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return []
                            }
                            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                                start = 0;
                                end = length
                            }
                            return baseFill(array, value, start, end)
                        }

                        function findIndex(array, predicate, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1
                            }
                            var index = fromIndex == null ? 0 : toInteger(fromIndex);
                            if (index < 0) {
                                index = nativeMax(length + index, 0)
                            }
                            return baseFindIndex(array, getIteratee(predicate, 3), index)
                        }

                        function findLastIndex(array, predicate, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1
                            }
                            var index = length - 1;
                            if (fromIndex !== undefined) {
                                index = toInteger(fromIndex);
                                index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)
                            }
                            return baseFindIndex(array, getIteratee(predicate, 3), index, true)
                        }

                        function flatten(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseFlatten(array, 1) : []
                        }

                        function flattenDeep(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseFlatten(array, INFINITY) : []
                        }

                        function flattenDepth(array, depth) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return []
                            }
                            depth = depth === undefined ? 1 : toInteger(depth);
                            return baseFlatten(array, depth)
                        }

                        function fromPairs(pairs) {
                            var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
                            while (++index < length) {
                                var pair = pairs[index];
                                result[pair[0]] = pair[1]
                            }
                            return result
                        }

                        function head(array) {
                            return array && array.length ? array[0] : undefined
                        }

                        function indexOf(array, value, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1
                            }
                            var index = fromIndex == null ? 0 : toInteger(fromIndex);
                            if (index < 0) {
                                index = nativeMax(length + index, 0)
                            }
                            return baseIndexOf(array, value, index)
                        }

                        function initial(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseSlice(array, 0, -1) : []
                        }

                        var intersection = baseRest(function (arrays) {
                            var mapped = arrayMap(arrays, castArrayLikeObject);
                            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : []
                        });
                        var intersectionBy = baseRest(function (arrays) {
                            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                            if (iteratee === last(mapped)) {
                                iteratee = undefined
                            } else {
                                mapped.pop()
                            }
                            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : []
                        });
                        var intersectionWith = baseRest(function (arrays) {
                            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                            comparator = typeof comparator == "function" ? comparator : undefined;
                            if (comparator) {
                                mapped.pop()
                            }
                            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : []
                        });

                        function join(array, separator) {
                            return array == null ? "" : nativeJoin.call(array, separator)
                        }

                        function last(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? array[length - 1] : undefined
                        }

                        function lastIndexOf(array, value, fromIndex) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return -1
                            }
                            var index = length;
                            if (fromIndex !== undefined) {
                                index = toInteger(fromIndex);
                                index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)
                            }
                            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true)
                        }

                        function nth(array, n) {
                            return array && array.length ? baseNth(array, toInteger(n)) : undefined
                        }

                        var pull = baseRest(pullAll);

                        function pullAll(array, values) {
                            return array && array.length && values && values.length ? basePullAll(array, values) : array
                        }

                        function pullAllBy(array, values, iteratee) {
                            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array
                        }

                        function pullAllWith(array, values, comparator) {
                            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array
                        }

                        var pullAt = flatRest(function (array, indexes) {
                            var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
                            basePullAt(array, arrayMap(indexes, function (index) {
                                return isIndex(index, length) ? +index : index
                            }).sort(compareAscending));
                            return result
                        });

                        function remove(array, predicate) {
                            var result = [];
                            if (!(array && array.length)) {
                                return result
                            }
                            var index = -1, indexes = [], length = array.length;
                            predicate = getIteratee(predicate, 3);
                            while (++index < length) {
                                var value = array[index];
                                if (predicate(value, index, array)) {
                                    result.push(value);
                                    indexes.push(index)
                                }
                            }
                            basePullAt(array, indexes);
                            return result
                        }

                        function reverse(array) {
                            return array == null ? array : nativeReverse.call(array)
                        }

                        function slice(array, start, end) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return []
                            }
                            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                                start = 0;
                                end = length
                            } else {
                                start = start == null ? 0 : toInteger(start);
                                end = end === undefined ? length : toInteger(end)
                            }
                            return baseSlice(array, start, end)
                        }

                        function sortedIndex(array, value) {
                            return baseSortedIndex(array, value)
                        }

                        function sortedIndexBy(array, value, iteratee) {
                            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2))
                        }

                        function sortedIndexOf(array, value) {
                            var length = array == null ? 0 : array.length;
                            if (length) {
                                var index = baseSortedIndex(array, value);
                                if (index < length && eq(array[index], value)) {
                                    return index
                                }
                            }
                            return -1
                        }

                        function sortedLastIndex(array, value) {
                            return baseSortedIndex(array, value, true)
                        }

                        function sortedLastIndexBy(array, value, iteratee) {
                            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true)
                        }

                        function sortedLastIndexOf(array, value) {
                            var length = array == null ? 0 : array.length;
                            if (length) {
                                var index = baseSortedIndex(array, value, true) - 1;
                                if (eq(array[index], value)) {
                                    return index
                                }
                            }
                            return -1
                        }

                        function sortedUniq(array) {
                            return array && array.length ? baseSortedUniq(array) : []
                        }

                        function sortedUniqBy(array, iteratee) {
                            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : []
                        }

                        function tail(array) {
                            var length = array == null ? 0 : array.length;
                            return length ? baseSlice(array, 1, length) : []
                        }

                        function take(array, n, guard) {
                            if (!(array && array.length)) {
                                return []
                            }
                            n = guard || n === undefined ? 1 : toInteger(n);
                            return baseSlice(array, 0, n < 0 ? 0 : n)
                        }

                        function takeRight(array, n, guard) {
                            var length = array == null ? 0 : array.length;
                            if (!length) {
                                return []
                            }
                            n = guard || n === undefined ? 1 : toInteger(n);
                            n = length - n;
                            return baseSlice(array, n < 0 ? 0 : n, length)
                        }

                        function takeRightWhile(array, predicate) {
                            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : []
                        }

                        function takeWhile(array, predicate) {
                            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : []
                        }

                        var union = baseRest(function (arrays) {
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true))
                        });
                        var unionBy = baseRest(function (arrays) {
                            var iteratee = last(arrays);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined
                            }
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
                        });
                        var unionWith = baseRest(function (arrays) {
                            var comparator = last(arrays);
                            comparator = typeof comparator == "function" ? comparator : undefined;
                            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator)
                        });

                        function uniq(array) {
                            return array && array.length ? baseUniq(array) : []
                        }

                        function uniqBy(array, iteratee) {
                            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : []
                        }

                        function uniqWith(array, comparator) {
                            comparator = typeof comparator == "function" ? comparator : undefined;
                            return array && array.length ? baseUniq(array, undefined, comparator) : []
                        }

                        function unzip(array) {
                            if (!(array && array.length)) {
                                return []
                            }
                            var length = 0;
                            array = arrayFilter(array, function (group) {
                                if (isArrayLikeObject(group)) {
                                    length = nativeMax(group.length, length);
                                    return true
                                }
                            });
                            return baseTimes(length, function (index) {
                                return arrayMap(array, baseProperty(index))
                            })
                        }

                        function unzipWith(array, iteratee) {
                            if (!(array && array.length)) {
                                return []
                            }
                            var result = unzip(array);
                            if (iteratee == null) {
                                return result
                            }
                            return arrayMap(result, function (group) {
                                return apply(iteratee, undefined, group)
                            })
                        }

                        var without = baseRest(function (array, values) {
                            return isArrayLikeObject(array) ? baseDifference(array, values) : []
                        });
                        var xor = baseRest(function (arrays) {
                            return baseXor(arrayFilter(arrays, isArrayLikeObject))
                        });
                        var xorBy = baseRest(function (arrays) {
                            var iteratee = last(arrays);
                            if (isArrayLikeObject(iteratee)) {
                                iteratee = undefined
                            }
                            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2))
                        });
                        var xorWith = baseRest(function (arrays) {
                            var comparator = last(arrays);
                            comparator = typeof comparator == "function" ? comparator : undefined;
                            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator)
                        });
                        var zip = baseRest(unzip);

                        function zipObject(props, values) {
                            return baseZipObject(props || [], values || [], assignValue)
                        }

                        function zipObjectDeep(props, values) {
                            return baseZipObject(props || [], values || [], baseSet)
                        }

                        var zipWith = baseRest(function (arrays) {
                            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
                            iteratee = typeof iteratee == "function" ? (arrays.pop(), iteratee) : undefined;
                            return unzipWith(arrays, iteratee)
                        });

                        function chain(value) {
                            var result = lodash(value);
                            result.__chain__ = true;
                            return result
                        }

                        function tap(value, interceptor) {
                            interceptor(value);
                            return value
                        }

                        function thru(value, interceptor) {
                            return interceptor(value)
                        }

                        var wrapperAt = flatRest(function (paths) {
                            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__,
                                interceptor = function (object) {
                                    return baseAt(object, paths)
                                };
                            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                                return this.thru(interceptor)
                            }
                            value = value.slice(start, +start + (length ? 1 : 0));
                            value.__actions__.push({func: thru, args: [interceptor], thisArg: undefined});
                            return new LodashWrapper(value, this.__chain__).thru(function (array) {
                                if (length && !array.length) {
                                    array.push(undefined)
                                }
                                return array
                            })
                        });

                        function wrapperChain() {
                            return chain(this)
                        }

                        function wrapperCommit() {
                            return new LodashWrapper(this.value(), this.__chain__)
                        }

                        function wrapperNext() {
                            if (this.__values__ === undefined) {
                                this.__values__ = toArray(this.value())
                            }
                            var done = this.__index__ >= this.__values__.length,
                                value = done ? undefined : this.__values__[this.__index__++];
                            return {done: done, value: value}
                        }

                        function wrapperToIterator() {
                            return this
                        }

                        function wrapperPlant(value) {
                            var result, parent = this;
                            while (parent instanceof baseLodash) {
                                var clone = wrapperClone(parent);
                                clone.__index__ = 0;
                                clone.__values__ = undefined;
                                if (result) {
                                    previous.__wrapped__ = clone
                                } else {
                                    result = clone
                                }
                                var previous = clone;
                                parent = parent.__wrapped__
                            }
                            previous.__wrapped__ = value;
                            return result
                        }

                        function wrapperReverse() {
                            var value = this.__wrapped__;
                            if (value instanceof LazyWrapper) {
                                var wrapped = value;
                                if (this.__actions__.length) {
                                    wrapped = new LazyWrapper(this)
                                }
                                wrapped = wrapped.reverse();
                                wrapped.__actions__.push({func: thru, args: [reverse], thisArg: undefined});
                                return new LodashWrapper(wrapped, this.__chain__)
                            }
                            return this.thru(reverse)
                        }

                        function wrapperValue() {
                            return baseWrapperValue(this.__wrapped__, this.__actions__)
                        }

                        var countBy = createAggregator(function (result, value, key) {
                            if (hasOwnProperty.call(result, key)) {
                                ++result[key]
                            } else {
                                baseAssignValue(result, key, 1)
                            }
                        });

                        function every(collection, predicate, guard) {
                            var func = isArray(collection) ? arrayEvery : baseEvery;
                            if (guard && isIterateeCall(collection, predicate, guard)) {
                                predicate = undefined
                            }
                            return func(collection, getIteratee(predicate, 3))
                        }

                        function filter(collection, predicate) {
                            var func = isArray(collection) ? arrayFilter : baseFilter;
                            return func(collection, getIteratee(predicate, 3))
                        }

                        var find = createFind(findIndex);
                        var findLast = createFind(findLastIndex);

                        function flatMap(collection, iteratee) {
                            return baseFlatten(map(collection, iteratee), 1)
                        }

                        function flatMapDeep(collection, iteratee) {
                            return baseFlatten(map(collection, iteratee), INFINITY)
                        }

                        function flatMapDepth(collection, iteratee, depth) {
                            depth = depth === undefined ? 1 : toInteger(depth);
                            return baseFlatten(map(collection, iteratee), depth)
                        }

                        function forEach(collection, iteratee) {
                            var func = isArray(collection) ? arrayEach : baseEach;
                            return func(collection, getIteratee(iteratee, 3))
                        }

                        function forEachRight(collection, iteratee) {
                            var func = isArray(collection) ? arrayEachRight : baseEachRight;
                            return func(collection, getIteratee(iteratee, 3))
                        }

                        var groupBy = createAggregator(function (result, value, key) {
                            if (hasOwnProperty.call(result, key)) {
                                result[key].push(value)
                            } else {
                                baseAssignValue(result, key, [value])
                            }
                        });

                        function includes(collection, value, fromIndex, guard) {
                            collection = isArrayLike(collection) ? collection : values(collection);
                            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                            var length = collection.length;
                            if (fromIndex < 0) {
                                fromIndex = nativeMax(length + fromIndex, 0)
                            }
                            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1
                        }

                        var invokeMap = baseRest(function (collection, path, args) {
                            var index = -1, isFunc = typeof path == "function",
                                result = isArrayLike(collection) ? Array(collection.length) : [];
                            baseEach(collection, function (value) {
                                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args)
                            });
                            return result
                        });
                        var keyBy = createAggregator(function (result, value, key) {
                            baseAssignValue(result, key, value)
                        });

                        function map(collection, iteratee) {
                            var func = isArray(collection) ? arrayMap : baseMap;
                            return func(collection, getIteratee(iteratee, 3))
                        }

                        function orderBy(collection, iteratees, orders, guard) {
                            if (collection == null) {
                                return []
                            }
                            if (!isArray(iteratees)) {
                                iteratees = iteratees == null ? [] : [iteratees]
                            }
                            orders = guard ? undefined : orders;
                            if (!isArray(orders)) {
                                orders = orders == null ? [] : [orders]
                            }
                            return baseOrderBy(collection, iteratees, orders)
                        }

                        var partition = createAggregator(function (result, value, key) {
                            result[key ? 0 : 1].push(value)
                        }, function () {
                            return [[], []]
                        });

                        function reduce(collection, iteratee, accumulator) {
                            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach)
                        }

                        function reduceRight(collection, iteratee, accumulator) {
                            var func = isArray(collection) ? arrayReduceRight : baseReduce,
                                initAccum = arguments.length < 3;
                            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight)
                        }

                        function reject(collection, predicate) {
                            var func = isArray(collection) ? arrayFilter : baseFilter;
                            return func(collection, negate(getIteratee(predicate, 3)))
                        }

                        function sample(collection) {
                            var func = isArray(collection) ? arraySample : baseSample;
                            return func(collection)
                        }

                        function sampleSize(collection, n, guard) {
                            if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
                                n = 1
                            } else {
                                n = toInteger(n)
                            }
                            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                            return func(collection, n)
                        }

                        function shuffle(collection) {
                            var func = isArray(collection) ? arrayShuffle : baseShuffle;
                            return func(collection)
                        }

                        function size(collection) {
                            if (collection == null) {
                                return 0
                            }
                            if (isArrayLike(collection)) {
                                return isString(collection) ? stringSize(collection) : collection.length
                            }
                            var tag = getTag(collection);
                            if (tag == mapTag || tag == setTag) {
                                return collection.size
                            }
                            return baseKeys(collection).length
                        }

                        function some(collection, predicate, guard) {
                            var func = isArray(collection) ? arraySome : baseSome;
                            if (guard && isIterateeCall(collection, predicate, guard)) {
                                predicate = undefined
                            }
                            return func(collection, getIteratee(predicate, 3))
                        }

                        var sortBy = baseRest(function (collection, iteratees) {
                            if (collection == null) {
                                return []
                            }
                            var length = iteratees.length;
                            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                                iteratees = []
                            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                                iteratees = [iteratees[0]]
                            }
                            return baseOrderBy(collection, baseFlatten(iteratees, 1), [])
                        });
                        var now = ctxNow || function () {
                            return root.Date.now()
                        };

                        function after(n, func) {
                            if (typeof func != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            n = toInteger(n);
                            return function () {
                                if (--n < 1) {
                                    return func.apply(this, arguments)
                                }
                            }
                        }

                        function ary(func, n, guard) {
                            n = guard ? undefined : n;
                            n = func && n == null ? func.length : n;
                            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n)
                        }

                        function before(n, func) {
                            var result;
                            if (typeof func != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            n = toInteger(n);
                            return function () {
                                if (--n > 0) {
                                    result = func.apply(this, arguments)
                                }
                                if (n <= 1) {
                                    func = undefined
                                }
                                return result
                            }
                        }

                        var bind = baseRest(function (func, thisArg, partials) {
                            var bitmask = WRAP_BIND_FLAG;
                            if (partials.length) {
                                var holders = replaceHolders(partials, getHolder(bind));
                                bitmask |= WRAP_PARTIAL_FLAG
                            }
                            return createWrap(func, bitmask, thisArg, partials, holders)
                        });
                        var bindKey = baseRest(function (object, key, partials) {
                            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                            if (partials.length) {
                                var holders = replaceHolders(partials, getHolder(bindKey));
                                bitmask |= WRAP_PARTIAL_FLAG
                            }
                            return createWrap(key, bitmask, object, partials, holders)
                        });

                        function curry(func, arity, guard) {
                            arity = guard ? undefined : arity;
                            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curry.placeholder;
                            return result
                        }

                        function curryRight(func, arity, guard) {
                            arity = guard ? undefined : arity;
                            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curryRight.placeholder;
                            return result
                        }

                        function debounce(func, wait, options) {
                            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0,
                                leading = false, maxing = false, trailing = true;
                            if (typeof func != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            wait = toNumber(wait) || 0;
                            if (isObject(options)) {
                                leading = !!options.leading;
                                maxing = "maxWait" in options;
                                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                                trailing = "trailing" in options ? !!options.trailing : trailing
                            }

                            function invokeFunc(time) {
                                var args = lastArgs, thisArg = lastThis;
                                lastArgs = lastThis = undefined;
                                lastInvokeTime = time;
                                result = func.apply(thisArg, args);
                                return result
                            }

                            function leadingEdge(time) {
                                lastInvokeTime = time;
                                timerId = setTimeout(timerExpired, wait);
                                return leading ? invokeFunc(time) : result
                            }

                            function remainingWait(time) {
                                var timeSinceLastCall = time - lastCallTime,
                                    timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                                return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting
                            }

                            function shouldInvoke(time) {
                                var timeSinceLastCall = time - lastCallTime,
                                    timeSinceLastInvoke = time - lastInvokeTime;
                                return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait
                            }

                            function timerExpired() {
                                var time = now();
                                if (shouldInvoke(time)) {
                                    return trailingEdge(time)
                                }
                                timerId = setTimeout(timerExpired, remainingWait(time))
                            }

                            function trailingEdge(time) {
                                timerId = undefined;
                                if (trailing && lastArgs) {
                                    return invokeFunc(time)
                                }
                                lastArgs = lastThis = undefined;
                                return result
                            }

                            function cancel() {
                                if (timerId !== undefined) {
                                    clearTimeout(timerId)
                                }
                                lastInvokeTime = 0;
                                lastArgs = lastCallTime = lastThis = timerId = undefined
                            }

                            function flush() {
                                return timerId === undefined ? result : trailingEdge(now())
                            }

                            function debounced() {
                                var time = now(), isInvoking = shouldInvoke(time);
                                lastArgs = arguments;
                                lastThis = this;
                                lastCallTime = time;
                                if (isInvoking) {
                                    if (timerId === undefined) {
                                        return leadingEdge(lastCallTime)
                                    }
                                    if (maxing) {
                                        timerId = setTimeout(timerExpired, wait);
                                        return invokeFunc(lastCallTime)
                                    }
                                }
                                if (timerId === undefined) {
                                    timerId = setTimeout(timerExpired, wait)
                                }
                                return result
                            }

                            debounced.cancel = cancel;
                            debounced.flush = flush;
                            return debounced
                        }

                        var defer = baseRest(function (func, args) {
                            return baseDelay(func, 1, args)
                        });
                        var delay = baseRest(function (func, wait, args) {
                            return baseDelay(func, toNumber(wait) || 0, args)
                        });

                        function flip(func) {
                            return createWrap(func, WRAP_FLIP_FLAG)
                        }

                        function memoize(func, resolver) {
                            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            var memoized = function () {
                                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0],
                                    cache = memoized.cache;
                                if (cache.has(key)) {
                                    return cache.get(key)
                                }
                                var result = func.apply(this, args);
                                memoized.cache = cache.set(key, result) || cache;
                                return result
                            };
                            memoized.cache = new (memoize.Cache || MapCache);
                            return memoized
                        }

                        memoize.Cache = MapCache;

                        function negate(predicate) {
                            if (typeof predicate != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            return function () {
                                var args = arguments;
                                switch (args.length) {
                                    case 0:
                                        return !predicate.call(this);
                                    case 1:
                                        return !predicate.call(this, args[0]);
                                    case 2:
                                        return !predicate.call(this, args[0], args[1]);
                                    case 3:
                                        return !predicate.call(this, args[0], args[1], args[2])
                                }
                                return !predicate.apply(this, args)
                            }
                        }

                        function once(func) {
                            return before(2, func)
                        }

                        var overArgs = castRest(function (func, transforms) {
                            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                            var funcsLength = transforms.length;
                            return baseRest(function (args) {
                                var index = -1, length = nativeMin(args.length, funcsLength);
                                while (++index < length) {
                                    args[index] = transforms[index].call(this, args[index])
                                }
                                return apply(func, this, args)
                            })
                        });
                        var partial = baseRest(function (func, partials) {
                            var holders = replaceHolders(partials, getHolder(partial));
                            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders)
                        });
                        var partialRight = baseRest(function (func, partials) {
                            var holders = replaceHolders(partials, getHolder(partialRight));
                            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders)
                        });
                        var rearg = flatRest(function (func, indexes) {
                            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes)
                        });

                        function rest(func, start) {
                            if (typeof func != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            start = start === undefined ? start : toInteger(start);
                            return baseRest(func, start)
                        }

                        function spread(func, start) {
                            if (typeof func != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            start = start == null ? 0 : nativeMax(toInteger(start), 0);
                            return baseRest(function (args) {
                                var array = args[start], otherArgs = castSlice(args, 0, start);
                                if (array) {
                                    arrayPush(otherArgs, array)
                                }
                                return apply(func, this, otherArgs)
                            })
                        }

                        function throttle(func, wait, options) {
                            var leading = true, trailing = true;
                            if (typeof func != "function") {
                                throw new TypeError(FUNC_ERROR_TEXT)
                            }
                            if (isObject(options)) {
                                leading = "leading" in options ? !!options.leading : leading;
                                trailing = "trailing" in options ? !!options.trailing : trailing
                            }
                            return debounce(func, wait, {leading: leading, maxWait: wait, trailing: trailing})
                        }

                        function unary(func) {
                            return ary(func, 1)
                        }

                        function wrap(value, wrapper) {
                            return partial(castFunction(wrapper), value)
                        }

                        function castArray() {
                            if (!arguments.length) {
                                return []
                            }
                            var value = arguments[0];
                            return isArray(value) ? value : [value]
                        }

                        function clone(value) {
                            return baseClone(value, CLONE_SYMBOLS_FLAG)
                        }

                        function cloneWith(value, customizer) {
                            customizer = typeof customizer == "function" ? customizer : undefined;
                            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer)
                        }

                        function cloneDeep(value) {
                            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
                        }

                        function cloneDeepWith(value, customizer) {
                            customizer = typeof customizer == "function" ? customizer : undefined;
                            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer)
                        }

                        function conformsTo(object, source) {
                            return source == null || baseConformsTo(object, source, keys(source))
                        }

                        function eq(value, other) {
                            return value === other || value !== value && other !== other
                        }

                        var gt = createRelationalOperation(baseGt);
                        var gte = createRelationalOperation(function (value, other) {
                            return value >= other
                        });
                        var isArguments = baseIsArguments(function () {
                            return arguments
                        }()) ? baseIsArguments : function (value) {
                            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee")
                        };
                        var isArray = Array.isArray;
                        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

                        function isArrayLike(value) {
                            return value != null && isLength(value.length) && !isFunction(value)
                        }

                        function isArrayLikeObject(value) {
                            return isObjectLike(value) && isArrayLike(value)
                        }

                        function isBoolean(value) {
                            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag
                        }

                        var isBuffer = nativeIsBuffer || stubFalse;
                        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

                        function isElement(value) {
                            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value)
                        }

                        function isEmpty(value) {
                            if (value == null) {
                                return true
                            }
                            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                                return !value.length
                            }
                            var tag = getTag(value);
                            if (tag == mapTag || tag == setTag) {
                                return !value.size
                            }
                            if (isPrototype(value)) {
                                return !baseKeys(value).length
                            }
                            for (var key in value) {
                                if (hasOwnProperty.call(value, key)) {
                                    return false
                                }
                            }
                            return true
                        }

                        function isEqual(value, other) {
                            return baseIsEqual(value, other)
                        }

                        function isEqualWith(value, other, customizer) {
                            customizer = typeof customizer == "function" ? customizer : undefined;
                            var result = customizer ? customizer(value, other) : undefined;
                            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result
                        }

                        function isError(value) {
                            if (!isObjectLike(value)) {
                                return false
                            }
                            var tag = baseGetTag(value);
                            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value)
                        }

                        function isFinite(value) {
                            return typeof value == "number" && nativeIsFinite(value)
                        }

                        function isFunction(value) {
                            if (!isObject(value)) {
                                return false
                            }
                            var tag = baseGetTag(value);
                            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
                        }

                        function isInteger(value) {
                            return typeof value == "number" && value == toInteger(value)
                        }

                        function isLength(value) {
                            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
                        }

                        function isObject(value) {
                            var type = typeof value;
                            return value != null && (type == "object" || type == "function")
                        }

                        function isObjectLike(value) {
                            return value != null && typeof value == "object"
                        }

                        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

                        function isMatch(object, source) {
                            return object === source || baseIsMatch(object, source, getMatchData(source))
                        }

                        function isMatchWith(object, source, customizer) {
                            customizer = typeof customizer == "function" ? customizer : undefined;
                            return baseIsMatch(object, source, getMatchData(source), customizer)
                        }

                        function isNaN(value) {
                            return isNumber(value) && value != +value
                        }

                        function isNative(value) {
                            if (isMaskable(value)) {
                                throw new Error(CORE_ERROR_TEXT)
                            }
                            return baseIsNative(value)
                        }

                        function isNull(value) {
                            return value === null
                        }

                        function isNil(value) {
                            return value == null
                        }

                        function isNumber(value) {
                            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag
                        }

                        function isPlainObject(value) {
                            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                                return false
                            }
                            var proto = getPrototype(value);
                            if (proto === null) {
                                return true
                            }
                            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
                        }

                        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

                        function isSafeInteger(value) {
                            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER
                        }

                        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

                        function isString(value) {
                            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag
                        }

                        function isSymbol(value) {
                            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag
                        }

                        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

                        function isUndefined(value) {
                            return value === undefined
                        }

                        function isWeakMap(value) {
                            return isObjectLike(value) && getTag(value) == weakMapTag
                        }

                        function isWeakSet(value) {
                            return isObjectLike(value) && baseGetTag(value) == weakSetTag
                        }

                        var lt = createRelationalOperation(baseLt);
                        var lte = createRelationalOperation(function (value, other) {
                            return value <= other
                        });

                        function toArray(value) {
                            if (!value) {
                                return []
                            }
                            if (isArrayLike(value)) {
                                return isString(value) ? stringToArray(value) : copyArray(value)
                            }
                            if (symIterator && value[symIterator]) {
                                return iteratorToArray(value[symIterator]())
                            }
                            var tag = getTag(value),
                                func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                            return func(value)
                        }

                        function toFinite(value) {
                            if (!value) {
                                return value === 0 ? value : 0
                            }
                            value = toNumber(value);
                            if (value === INFINITY || value === -INFINITY) {
                                var sign = value < 0 ? -1 : 1;
                                return sign * MAX_INTEGER
                            }
                            return value === value ? value : 0
                        }

                        function toInteger(value) {
                            var result = toFinite(value), remainder = result % 1;
                            return result === result ? remainder ? result - remainder : result : 0
                        }

                        function toLength(value) {
                            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
                        }

                        function toNumber(value) {
                            if (typeof value == "number") {
                                return value
                            }
                            if (isSymbol(value)) {
                                return NAN
                            }
                            if (isObject(value)) {
                                var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                                value = isObject(other) ? other + "" : other
                            }
                            if (typeof value != "string") {
                                return value === 0 ? value : +value
                            }
                            value = value.replace(reTrim, "");
                            var isBinary = reIsBinary.test(value);
                            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value
                        }

                        function toPlainObject(value) {
                            return copyObject(value, keysIn(value))
                        }

                        function toSafeInteger(value) {
                            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0
                        }

                        function toString(value) {
                            return value == null ? "" : baseToString(value)
                        }

                        var assign = createAssigner(function (object, source) {
                            if (isPrototype(source) || isArrayLike(source)) {
                                copyObject(source, keys(source), object);
                                return
                            }
                            for (var key in source) {
                                if (hasOwnProperty.call(source, key)) {
                                    assignValue(object, key, source[key])
                                }
                            }
                        });
                        var assignIn = createAssigner(function (object, source) {
                            copyObject(source, keysIn(source), object)
                        });
                        var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
                            copyObject(source, keysIn(source), object, customizer)
                        });
                        var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
                            copyObject(source, keys(source), object, customizer)
                        });
                        var at = flatRest(baseAt);

                        function create(prototype, properties) {
                            var result = baseCreate(prototype);
                            return properties == null ? result : baseAssign(result, properties)
                        }

                        var defaults = baseRest(function (object, sources) {
                            object = Object(object);
                            var index = -1;
                            var length = sources.length;
                            var guard = length > 2 ? sources[2] : undefined;
                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                length = 1
                            }
                            while (++index < length) {
                                var source = sources[index];
                                var props = keysIn(source);
                                var propsIndex = -1;
                                var propsLength = props.length;
                                while (++propsIndex < propsLength) {
                                    var key = props[propsIndex];
                                    var value = object[key];
                                    if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                                        object[key] = source[key]
                                    }
                                }
                            }
                            return object
                        });
                        var defaultsDeep = baseRest(function (args) {
                            args.push(undefined, customDefaultsMerge);
                            return apply(mergeWith, undefined, args)
                        });

                        function findKey(object, predicate) {
                            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn)
                        }

                        function findLastKey(object, predicate) {
                            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight)
                        }

                        function forIn(object, iteratee) {
                            return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn)
                        }

                        function forInRight(object, iteratee) {
                            return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn)
                        }

                        function forOwn(object, iteratee) {
                            return object && baseForOwn(object, getIteratee(iteratee, 3))
                        }

                        function forOwnRight(object, iteratee) {
                            return object && baseForOwnRight(object, getIteratee(iteratee, 3))
                        }

                        function functions(object) {
                            return object == null ? [] : baseFunctions(object, keys(object))
                        }

                        function functionsIn(object) {
                            return object == null ? [] : baseFunctions(object, keysIn(object))
                        }

                        function get(object, path, defaultValue) {
                            var result = object == null ? undefined : baseGet(object, path);
                            return result === undefined ? defaultValue : result
                        }

                        function has(object, path) {
                            return object != null && hasPath(object, path, baseHas)
                        }

                        function hasIn(object, path) {
                            return object != null && hasPath(object, path, baseHasIn)
                        }

                        var invert = createInverter(function (result, value, key) {
                            if (value != null && typeof value.toString != "function") {
                                value = nativeObjectToString.call(value)
                            }
                            result[value] = key
                        }, constant(identity));
                        var invertBy = createInverter(function (result, value, key) {
                            if (value != null && typeof value.toString != "function") {
                                value = nativeObjectToString.call(value)
                            }
                            if (hasOwnProperty.call(result, value)) {
                                result[value].push(key)
                            } else {
                                result[value] = [key]
                            }
                        }, getIteratee);
                        var invoke = baseRest(baseInvoke);

                        function keys(object) {
                            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
                        }

                        function keysIn(object) {
                            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object)
                        }

                        function mapKeys(object, iteratee) {
                            var result = {};
                            iteratee = getIteratee(iteratee, 3);
                            baseForOwn(object, function (value, key, object) {
                                baseAssignValue(result, iteratee(value, key, object), value)
                            });
                            return result
                        }

                        function mapValues(object, iteratee) {
                            var result = {};
                            iteratee = getIteratee(iteratee, 3);
                            baseForOwn(object, function (value, key, object) {
                                baseAssignValue(result, key, iteratee(value, key, object))
                            });
                            return result
                        }

                        var merge = createAssigner(function (object, source, srcIndex) {
                            baseMerge(object, source, srcIndex)
                        });
                        var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
                            baseMerge(object, source, srcIndex, customizer)
                        });
                        var omit = flatRest(function (object, paths) {
                            var result = {};
                            if (object == null) {
                                return result
                            }
                            var isDeep = false;
                            paths = arrayMap(paths, function (path) {
                                path = castPath(path, object);
                                isDeep || (isDeep = path.length > 1);
                                return path
                            });
                            copyObject(object, getAllKeysIn(object), result);
                            if (isDeep) {
                                result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone)
                            }
                            var length = paths.length;
                            while (length--) {
                                baseUnset(result, paths[length])
                            }
                            return result
                        });

                        function omitBy(object, predicate) {
                            return pickBy(object, negate(getIteratee(predicate)))
                        }

                        var pick = flatRest(function (object, paths) {
                            return object == null ? {} : basePick(object, paths)
                        });

                        function pickBy(object, predicate) {
                            if (object == null) {
                                return {}
                            }
                            var props = arrayMap(getAllKeysIn(object), function (prop) {
                                return [prop]
                            });
                            predicate = getIteratee(predicate);
                            return basePickBy(object, props, function (value, path) {
                                return predicate(value, path[0])
                            })
                        }

                        function result(object, path, defaultValue) {
                            path = castPath(path, object);
                            var index = -1, length = path.length;
                            if (!length) {
                                length = 1;
                                object = undefined
                            }
                            while (++index < length) {
                                var value = object == null ? undefined : object[toKey(path[index])];
                                if (value === undefined) {
                                    index = length;
                                    value = defaultValue
                                }
                                object = isFunction(value) ? value.call(object) : value
                            }
                            return object
                        }

                        function set(object, path, value) {
                            return object == null ? object : baseSet(object, path, value)
                        }

                        function setWith(object, path, value, customizer) {
                            customizer = typeof customizer == "function" ? customizer : undefined;
                            return object == null ? object : baseSet(object, path, value, customizer)
                        }

                        var toPairs = createToPairs(keys);
                        var toPairsIn = createToPairs(keysIn);

                        function transform(object, iteratee, accumulator) {
                            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                            iteratee = getIteratee(iteratee, 4);
                            if (accumulator == null) {
                                var Ctor = object && object.constructor;
                                if (isArrLike) {
                                    accumulator = isArr ? new Ctor : []
                                } else if (isObject(object)) {
                                    accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {}
                                } else {
                                    accumulator = {}
                                }
                            }
                            (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
                                return iteratee(accumulator, value, index, object)
                            });
                            return accumulator
                        }

                        function unset(object, path) {
                            return object == null ? true : baseUnset(object, path)
                        }

                        function update(object, path, updater) {
                            return object == null ? object : baseUpdate(object, path, castFunction(updater))
                        }

                        function updateWith(object, path, updater, customizer) {
                            customizer = typeof customizer == "function" ? customizer : undefined;
                            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer)
                        }

                        function values(object) {
                            return object == null ? [] : baseValues(object, keys(object))
                        }

                        function valuesIn(object) {
                            return object == null ? [] : baseValues(object, keysIn(object))
                        }

                        function clamp(number, lower, upper) {
                            if (upper === undefined) {
                                upper = lower;
                                lower = undefined
                            }
                            if (upper !== undefined) {
                                upper = toNumber(upper);
                                upper = upper === upper ? upper : 0
                            }
                            if (lower !== undefined) {
                                lower = toNumber(lower);
                                lower = lower === lower ? lower : 0
                            }
                            return baseClamp(toNumber(number), lower, upper)
                        }

                        function inRange(number, start, end) {
                            start = toFinite(start);
                            if (end === undefined) {
                                end = start;
                                start = 0
                            } else {
                                end = toFinite(end)
                            }
                            number = toNumber(number);
                            return baseInRange(number, start, end)
                        }

                        function random(lower, upper, floating) {
                            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                                upper = floating = undefined
                            }
                            if (floating === undefined) {
                                if (typeof upper == "boolean") {
                                    floating = upper;
                                    upper = undefined
                                } else if (typeof lower == "boolean") {
                                    floating = lower;
                                    lower = undefined
                                }
                            }
                            if (lower === undefined && upper === undefined) {
                                lower = 0;
                                upper = 1
                            } else {
                                lower = toFinite(lower);
                                if (upper === undefined) {
                                    upper = lower;
                                    lower = 0
                                } else {
                                    upper = toFinite(upper)
                                }
                            }
                            if (lower > upper) {
                                var temp = lower;
                                lower = upper;
                                upper = temp
                            }
                            if (floating || lower % 1 || upper % 1) {
                                var rand = nativeRandom();
                                return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper)
                            }
                            return baseRandom(lower, upper)
                        }

                        var camelCase = createCompounder(function (result, word, index) {
                            word = word.toLowerCase();
                            return result + (index ? capitalize(word) : word)
                        });

                        function capitalize(string) {
                            return upperFirst(toString(string).toLowerCase())
                        }

                        function deburr(string) {
                            string = toString(string);
                            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "")
                        }

                        function endsWith(string, target, position) {
                            string = toString(string);
                            target = baseToString(target);
                            var length = string.length;
                            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
                            var end = position;
                            position -= target.length;
                            return position >= 0 && string.slice(position, end) == target
                        }

                        function escape(string) {
                            string = toString(string);
                            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string
                        }

                        function escapeRegExp(string) {
                            string = toString(string);
                            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string
                        }

                        var kebabCase = createCompounder(function (result, word, index) {
                            return result + (index ? "-" : "") + word.toLowerCase()
                        });
                        var lowerCase = createCompounder(function (result, word, index) {
                            return result + (index ? " " : "") + word.toLowerCase()
                        });
                        var lowerFirst = createCaseFirst("toLowerCase");

                        function pad(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);
                            var strLength = length ? stringSize(string) : 0;
                            if (!length || strLength >= length) {
                                return string
                            }
                            var mid = (length - strLength) / 2;
                            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars)
                        }

                        function padEnd(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);
                            var strLength = length ? stringSize(string) : 0;
                            return length && strLength < length ? string + createPadding(length - strLength, chars) : string
                        }

                        function padStart(string, length, chars) {
                            string = toString(string);
                            length = toInteger(length);
                            var strLength = length ? stringSize(string) : 0;
                            return length && strLength < length ? createPadding(length - strLength, chars) + string : string
                        }

                        function parseInt(string, radix, guard) {
                            if (guard || radix == null) {
                                radix = 0
                            } else if (radix) {
                                radix = +radix
                            }
                            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0)
                        }

                        function repeat(string, n, guard) {
                            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
                                n = 1
                            } else {
                                n = toInteger(n)
                            }
                            return baseRepeat(toString(string), n)
                        }

                        function replace() {
                            var args = arguments, string = toString(args[0]);
                            return args.length < 3 ? string : string.replace(args[1], args[2])
                        }

                        var snakeCase = createCompounder(function (result, word, index) {
                            return result + (index ? "_" : "") + word.toLowerCase()
                        });

                        function split(string, separator, limit) {
                            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                                separator = limit = undefined
                            }
                            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
                            if (!limit) {
                                return []
                            }
                            string = toString(string);
                            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                                separator = baseToString(separator);
                                if (!separator && hasUnicode(string)) {
                                    return castSlice(stringToArray(string), 0, limit)
                                }
                            }
                            return string.split(separator, limit)
                        }

                        var startCase = createCompounder(function (result, word, index) {
                            return result + (index ? " " : "") + upperFirst(word)
                        });

                        function startsWith(string, target, position) {
                            string = toString(string);
                            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                            target = baseToString(target);
                            return string.slice(position, position + target.length) == target
                        }

                        function template(string, options, guard) {
                            var settings = lodash.templateSettings;
                            if (guard && isIterateeCall(string, options, guard)) {
                                options = undefined
                            }
                            string = toString(string);
                            options = assignInWith({}, options, settings, customDefaultsAssignIn);
                            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
                                importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch,
                                source = "__p += '";
                            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                            var sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                                interpolateValue || (interpolateValue = esTemplateValue);
                                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                                if (escapeValue) {
                                    isEscaping = true;
                                    source += "' +\n__e(" + escapeValue + ") +\n'"
                                }
                                if (evaluateValue) {
                                    isEvaluating = true;
                                    source += "';\n" + evaluateValue + ";\n__p += '"
                                }
                                if (interpolateValue) {
                                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"
                                }
                                index = offset + match.length;
                                return match
                            });
                            source += "';\n";
                            var variable = options.variable;
                            if (!variable) {
                                source = "with (obj) {\n" + source + "\n}\n"
                            }
                            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                            var result = attempt(function () {
                                return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues)
                            });
                            result.source = source;
                            if (isError(result)) {
                                throw result
                            }
                            return result
                        }

                        function toLower(value) {
                            return toString(value).toLowerCase()
                        }

                        function toUpper(value) {
                            return toString(value).toUpperCase()
                        }

                        function trim(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrim, "")
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string
                            }
                            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars),
                                start = charsStartIndex(strSymbols, chrSymbols),
                                end = charsEndIndex(strSymbols, chrSymbols) + 1;
                            return castSlice(strSymbols, start, end).join("")
                        }

                        function trimEnd(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrimEnd, "")
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string
                            }
                            var strSymbols = stringToArray(string),
                                end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                            return castSlice(strSymbols, 0, end).join("")
                        }

                        function trimStart(string, chars, guard) {
                            string = toString(string);
                            if (string && (guard || chars === undefined)) {
                                return string.replace(reTrimStart, "")
                            }
                            if (!string || !(chars = baseToString(chars))) {
                                return string
                            }
                            var strSymbols = stringToArray(string),
                                start = charsStartIndex(strSymbols, stringToArray(chars));
                            return castSlice(strSymbols, start).join("")
                        }

                        function truncate(string, options) {
                            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                            if (isObject(options)) {
                                var separator = "separator" in options ? options.separator : separator;
                                length = "length" in options ? toInteger(options.length) : length;
                                omission = "omission" in options ? baseToString(options.omission) : omission
                            }
                            string = toString(string);
                            var strLength = string.length;
                            if (hasUnicode(string)) {
                                var strSymbols = stringToArray(string);
                                strLength = strSymbols.length
                            }
                            if (length >= strLength) {
                                return string
                            }
                            var end = length - stringSize(omission);
                            if (end < 1) {
                                return omission
                            }
                            var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                            if (separator === undefined) {
                                return result + omission
                            }
                            if (strSymbols) {
                                end += result.length - end
                            }
                            if (isRegExp(separator)) {
                                if (string.slice(end).search(separator)) {
                                    var match, substring = result;
                                    if (!separator.global) {
                                        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g")
                                    }
                                    separator.lastIndex = 0;
                                    while (match = separator.exec(substring)) {
                                        var newEnd = match.index
                                    }
                                    result = result.slice(0, newEnd === undefined ? end : newEnd)
                                }
                            } else if (string.indexOf(baseToString(separator), end) != end) {
                                var index = result.lastIndexOf(separator);
                                if (index > -1) {
                                    result = result.slice(0, index)
                                }
                            }
                            return result + omission
                        }

                        function unescape(string) {
                            string = toString(string);
                            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string
                        }

                        var upperCase = createCompounder(function (result, word, index) {
                            return result + (index ? " " : "") + word.toUpperCase()
                        });
                        var upperFirst = createCaseFirst("toUpperCase");

                        function words(string, pattern, guard) {
                            string = toString(string);
                            pattern = guard ? undefined : pattern;
                            if (pattern === undefined) {
                                return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string)
                            }
                            return string.match(pattern) || []
                        }

                        var attempt = baseRest(function (func, args) {
                            try {
                                return apply(func, undefined, args)
                            } catch (e) {
                                return isError(e) ? e : new Error(e)
                            }
                        });
                        var bindAll = flatRest(function (object, methodNames) {
                            arrayEach(methodNames, function (key) {
                                key = toKey(key);
                                baseAssignValue(object, key, bind(object[key], object))
                            });
                            return object
                        });

                        function cond(pairs) {
                            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                            pairs = !length ? [] : arrayMap(pairs, function (pair) {
                                if (typeof pair[1] != "function") {
                                    throw new TypeError(FUNC_ERROR_TEXT)
                                }
                                return [toIteratee(pair[0]), pair[1]]
                            });
                            return baseRest(function (args) {
                                var index = -1;
                                while (++index < length) {
                                    var pair = pairs[index];
                                    if (apply(pair[0], this, args)) {
                                        return apply(pair[1], this, args)
                                    }
                                }
                            })
                        }

                        function conforms(source) {
                            return baseConforms(baseClone(source, CLONE_DEEP_FLAG))
                        }

                        function constant(value) {
                            return function () {
                                return value
                            }
                        }

                        function defaultTo(value, defaultValue) {
                            return value == null || value !== value ? defaultValue : value
                        }

                        var flow = createFlow();
                        var flowRight = createFlow(true);

                        function identity(value) {
                            return value
                        }

                        function iteratee(func) {
                            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG))
                        }

                        function matches(source) {
                            return baseMatches(baseClone(source, CLONE_DEEP_FLAG))
                        }

                        function matchesProperty(path, srcValue) {
                            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG))
                        }

                        var method = baseRest(function (path, args) {
                            return function (object) {
                                return baseInvoke(object, path, args)
                            }
                        });
                        var methodOf = baseRest(function (object, args) {
                            return function (path) {
                                return baseInvoke(object, path, args)
                            }
                        });

                        function mixin(object, source, options) {
                            var props = keys(source), methodNames = baseFunctions(source, props);
                            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                                options = source;
                                source = object;
                                object = this;
                                methodNames = baseFunctions(source, keys(source))
                            }
                            var chain = !(isObject(options) && "chain" in options) || !!options.chain,
                                isFunc = isFunction(object);
                            arrayEach(methodNames, function (methodName) {
                                var func = source[methodName];
                                object[methodName] = func;
                                if (isFunc) {
                                    object.prototype[methodName] = function () {
                                        var chainAll = this.__chain__;
                                        if (chain || chainAll) {
                                            var result = object(this.__wrapped__),
                                                actions = result.__actions__ = copyArray(this.__actions__);
                                            actions.push({func: func, args: arguments, thisArg: object});
                                            result.__chain__ = chainAll;
                                            return result
                                        }
                                        return func.apply(object, arrayPush([this.value()], arguments))
                                    }
                                }
                            });
                            return object
                        }

                        function noConflict() {
                            if (root._ === this) {
                                root._ = oldDash
                            }
                            return this
                        }

                        function noop() {
                        }

                        function nthArg(n) {
                            n = toInteger(n);
                            return baseRest(function (args) {
                                return baseNth(args, n)
                            })
                        }

                        var over = createOver(arrayMap);
                        var overEvery = createOver(arrayEvery);
                        var overSome = createOver(arraySome);

                        function property(path) {
                            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
                        }

                        function propertyOf(object) {
                            return function (path) {
                                return object == null ? undefined : baseGet(object, path)
                            }
                        }

                        var range = createRange();
                        var rangeRight = createRange(true);

                        function stubArray() {
                            return []
                        }

                        function stubFalse() {
                            return false
                        }

                        function stubObject() {
                            return {}
                        }

                        function stubString() {
                            return ""
                        }

                        function stubTrue() {
                            return true
                        }

                        function times(n, iteratee) {
                            n = toInteger(n);
                            if (n < 1 || n > MAX_SAFE_INTEGER) {
                                return []
                            }
                            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                            iteratee = getIteratee(iteratee);
                            n -= MAX_ARRAY_LENGTH;
                            var result = baseTimes(length, iteratee);
                            while (++index < n) {
                                iteratee(index)
                            }
                            return result
                        }

                        function toPath(value) {
                            if (isArray(value)) {
                                return arrayMap(value, toKey)
                            }
                            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)))
                        }

                        function uniqueId(prefix) {
                            var id = ++idCounter;
                            return toString(prefix) + id
                        }

                        var add = createMathOperation(function (augend, addend) {
                            return augend + addend
                        }, 0);
                        var ceil = createRound("ceil");
                        var divide = createMathOperation(function (dividend, divisor) {
                            return dividend / divisor
                        }, 1);
                        var floor = createRound("floor");

                        function max(array) {
                            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined
                        }

                        function maxBy(array, iteratee) {
                            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined
                        }

                        function mean(array) {
                            return baseMean(array, identity)
                        }

                        function meanBy(array, iteratee) {
                            return baseMean(array, getIteratee(iteratee, 2))
                        }

                        function min(array) {
                            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined
                        }

                        function minBy(array, iteratee) {
                            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined
                        }

                        var multiply = createMathOperation(function (multiplier, multiplicand) {
                            return multiplier * multiplicand
                        }, 1);
                        var round = createRound("round");
                        var subtract = createMathOperation(function (minuend, subtrahend) {
                            return minuend - subtrahend
                        }, 0);

                        function sum(array) {
                            return array && array.length ? baseSum(array, identity) : 0
                        }

                        function sumBy(array, iteratee) {
                            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0
                        }

                        lodash.after = after;
                        lodash.ary = ary;
                        lodash.assign = assign;
                        lodash.assignIn = assignIn;
                        lodash.assignInWith = assignInWith;
                        lodash.assignWith = assignWith;
                        lodash.at = at;
                        lodash.before = before;
                        lodash.bind = bind;
                        lodash.bindAll = bindAll;
                        lodash.bindKey = bindKey;
                        lodash.castArray = castArray;
                        lodash.chain = chain;
                        lodash.chunk = chunk;
                        lodash.compact = compact;
                        lodash.concat = concat;
                        lodash.cond = cond;
                        lodash.conforms = conforms;
                        lodash.constant = constant;
                        lodash.countBy = countBy;
                        lodash.create = create;
                        lodash.curry = curry;
                        lodash.curryRight = curryRight;
                        lodash.debounce = debounce;
                        lodash.defaults = defaults;
                        lodash.defaultsDeep = defaultsDeep;
                        lodash.defer = defer;
                        lodash.delay = delay;
                        lodash.difference = difference;
                        lodash.differenceBy = differenceBy;
                        lodash.differenceWith = differenceWith;
                        lodash.drop = drop;
                        lodash.dropRight = dropRight;
                        lodash.dropRightWhile = dropRightWhile;
                        lodash.dropWhile = dropWhile;
                        lodash.fill = fill;
                        lodash.filter = filter;
                        lodash.flatMap = flatMap;
                        lodash.flatMapDeep = flatMapDeep;
                        lodash.flatMapDepth = flatMapDepth;
                        lodash.flatten = flatten;
                        lodash.flattenDeep = flattenDeep;
                        lodash.flattenDepth = flattenDepth;
                        lodash.flip = flip;
                        lodash.flow = flow;
                        lodash.flowRight = flowRight;
                        lodash.fromPairs = fromPairs;
                        lodash.functions = functions;
                        lodash.functionsIn = functionsIn;
                        lodash.groupBy = groupBy;
                        lodash.initial = initial;
                        lodash.intersection = intersection;
                        lodash.intersectionBy = intersectionBy;
                        lodash.intersectionWith = intersectionWith;
                        lodash.invert = invert;
                        lodash.invertBy = invertBy;
                        lodash.invokeMap = invokeMap;
                        lodash.iteratee = iteratee;
                        lodash.keyBy = keyBy;
                        lodash.keys = keys;
                        lodash.keysIn = keysIn;
                        lodash.map = map;
                        lodash.mapKeys = mapKeys;
                        lodash.mapValues = mapValues;
                        lodash.matches = matches;
                        lodash.matchesProperty = matchesProperty;
                        lodash.memoize = memoize;
                        lodash.merge = merge;
                        lodash.mergeWith = mergeWith;
                        lodash.method = method;
                        lodash.methodOf = methodOf;
                        lodash.mixin = mixin;
                        lodash.negate = negate;
                        lodash.nthArg = nthArg;
                        lodash.omit = omit;
                        lodash.omitBy = omitBy;
                        lodash.once = once;
                        lodash.orderBy = orderBy;
                        lodash.over = over;
                        lodash.overArgs = overArgs;
                        lodash.overEvery = overEvery;
                        lodash.overSome = overSome;
                        lodash.partial = partial;
                        lodash.partialRight = partialRight;
                        lodash.partition = partition;
                        lodash.pick = pick;
                        lodash.pickBy = pickBy;
                        lodash.property = property;
                        lodash.propertyOf = propertyOf;
                        lodash.pull = pull;
                        lodash.pullAll = pullAll;
                        lodash.pullAllBy = pullAllBy;
                        lodash.pullAllWith = pullAllWith;
                        lodash.pullAt = pullAt;
                        lodash.range = range;
                        lodash.rangeRight = rangeRight;
                        lodash.rearg = rearg;
                        lodash.reject = reject;
                        lodash.remove = remove;
                        lodash.rest = rest;
                        lodash.reverse = reverse;
                        lodash.sampleSize = sampleSize;
                        lodash.set = set;
                        lodash.setWith = setWith;
                        lodash.shuffle = shuffle;
                        lodash.slice = slice;
                        lodash.sortBy = sortBy;
                        lodash.sortedUniq = sortedUniq;
                        lodash.sortedUniqBy = sortedUniqBy;
                        lodash.split = split;
                        lodash.spread = spread;
                        lodash.tail = tail;
                        lodash.take = take;
                        lodash.takeRight = takeRight;
                        lodash.takeRightWhile = takeRightWhile;
                        lodash.takeWhile = takeWhile;
                        lodash.tap = tap;
                        lodash.throttle = throttle;
                        lodash.thru = thru;
                        lodash.toArray = toArray;
                        lodash.toPairs = toPairs;
                        lodash.toPairsIn = toPairsIn;
                        lodash.toPath = toPath;
                        lodash.toPlainObject = toPlainObject;
                        lodash.transform = transform;
                        lodash.unary = unary;
                        lodash.union = union;
                        lodash.unionBy = unionBy;
                        lodash.unionWith = unionWith;
                        lodash.uniq = uniq;
                        lodash.uniqBy = uniqBy;
                        lodash.uniqWith = uniqWith;
                        lodash.unset = unset;
                        lodash.unzip = unzip;
                        lodash.unzipWith = unzipWith;
                        lodash.update = update;
                        lodash.updateWith = updateWith;
                        lodash.values = values;
                        lodash.valuesIn = valuesIn;
                        lodash.without = without;
                        lodash.words = words;
                        lodash.wrap = wrap;
                        lodash.xor = xor;
                        lodash.xorBy = xorBy;
                        lodash.xorWith = xorWith;
                        lodash.zip = zip;
                        lodash.zipObject = zipObject;
                        lodash.zipObjectDeep = zipObjectDeep;
                        lodash.zipWith = zipWith;
                        lodash.entries = toPairs;
                        lodash.entriesIn = toPairsIn;
                        lodash.extend = assignIn;
                        lodash.extendWith = assignInWith;
                        mixin(lodash, lodash);
                        lodash.add = add;
                        lodash.attempt = attempt;
                        lodash.camelCase = camelCase;
                        lodash.capitalize = capitalize;
                        lodash.ceil = ceil;
                        lodash.clamp = clamp;
                        lodash.clone = clone;
                        lodash.cloneDeep = cloneDeep;
                        lodash.cloneDeepWith = cloneDeepWith;
                        lodash.cloneWith = cloneWith;
                        lodash.conformsTo = conformsTo;
                        lodash.deburr = deburr;
                        lodash.defaultTo = defaultTo;
                        lodash.divide = divide;
                        lodash.endsWith = endsWith;
                        lodash.eq = eq;
                        lodash.escape = escape;
                        lodash.escapeRegExp = escapeRegExp;
                        lodash.every = every;
                        lodash.find = find;
                        lodash.findIndex = findIndex;
                        lodash.findKey = findKey;
                        lodash.findLast = findLast;
                        lodash.findLastIndex = findLastIndex;
                        lodash.findLastKey = findLastKey;
                        lodash.floor = floor;
                        lodash.forEach = forEach;
                        lodash.forEachRight = forEachRight;
                        lodash.forIn = forIn;
                        lodash.forInRight = forInRight;
                        lodash.forOwn = forOwn;
                        lodash.forOwnRight = forOwnRight;
                        lodash.get = get;
                        lodash.gt = gt;
                        lodash.gte = gte;
                        lodash.has = has;
                        lodash.hasIn = hasIn;
                        lodash.head = head;
                        lodash.identity = identity;
                        lodash.includes = includes;
                        lodash.indexOf = indexOf;
                        lodash.inRange = inRange;
                        lodash.invoke = invoke;
                        lodash.isArguments = isArguments;
                        lodash.isArray = isArray;
                        lodash.isArrayBuffer = isArrayBuffer;
                        lodash.isArrayLike = isArrayLike;
                        lodash.isArrayLikeObject = isArrayLikeObject;
                        lodash.isBoolean = isBoolean;
                        lodash.isBuffer = isBuffer;
                        lodash.isDate = isDate;
                        lodash.isElement = isElement;
                        lodash.isEmpty = isEmpty;
                        lodash.isEqual = isEqual;
                        lodash.isEqualWith = isEqualWith;
                        lodash.isError = isError;
                        lodash.isFinite = isFinite;
                        lodash.isFunction = isFunction;
                        lodash.isInteger = isInteger;
                        lodash.isLength = isLength;
                        lodash.isMap = isMap;
                        lodash.isMatch = isMatch;
                        lodash.isMatchWith = isMatchWith;
                        lodash.isNaN = isNaN;
                        lodash.isNative = isNative;
                        lodash.isNil = isNil;
                        lodash.isNull = isNull;
                        lodash.isNumber = isNumber;
                        lodash.isObject = isObject;
                        lodash.isObjectLike = isObjectLike;
                        lodash.isPlainObject = isPlainObject;
                        lodash.isRegExp = isRegExp;
                        lodash.isSafeInteger = isSafeInteger;
                        lodash.isSet = isSet;
                        lodash.isString = isString;
                        lodash.isSymbol = isSymbol;
                        lodash.isTypedArray = isTypedArray;
                        lodash.isUndefined = isUndefined;
                        lodash.isWeakMap = isWeakMap;
                        lodash.isWeakSet = isWeakSet;
                        lodash.join = join;
                        lodash.kebabCase = kebabCase;
                        lodash.last = last;
                        lodash.lastIndexOf = lastIndexOf;
                        lodash.lowerCase = lowerCase;
                        lodash.lowerFirst = lowerFirst;
                        lodash.lt = lt;
                        lodash.lte = lte;
                        lodash.max = max;
                        lodash.maxBy = maxBy;
                        lodash.mean = mean;
                        lodash.meanBy = meanBy;
                        lodash.min = min;
                        lodash.minBy = minBy;
                        lodash.stubArray = stubArray;
                        lodash.stubFalse = stubFalse;
                        lodash.stubObject = stubObject;
                        lodash.stubString = stubString;
                        lodash.stubTrue = stubTrue;
                        lodash.multiply = multiply;
                        lodash.nth = nth;
                        lodash.noConflict = noConflict;
                        lodash.noop = noop;
                        lodash.now = now;
                        lodash.pad = pad;
                        lodash.padEnd = padEnd;
                        lodash.padStart = padStart;
                        lodash.parseInt = parseInt;
                        lodash.random = random;
                        lodash.reduce = reduce;
                        lodash.reduceRight = reduceRight;
                        lodash.repeat = repeat;
                        lodash.replace = replace;
                        lodash.result = result;
                        lodash.round = round;
                        lodash.runInContext = runInContext;
                        lodash.sample = sample;
                        lodash.size = size;
                        lodash.snakeCase = snakeCase;
                        lodash.some = some;
                        lodash.sortedIndex = sortedIndex;
                        lodash.sortedIndexBy = sortedIndexBy;
                        lodash.sortedIndexOf = sortedIndexOf;
                        lodash.sortedLastIndex = sortedLastIndex;
                        lodash.sortedLastIndexBy = sortedLastIndexBy;
                        lodash.sortedLastIndexOf = sortedLastIndexOf;
                        lodash.startCase = startCase;
                        lodash.startsWith = startsWith;
                        lodash.subtract = subtract;
                        lodash.sum = sum;
                        lodash.sumBy = sumBy;
                        lodash.template = template;
                        lodash.times = times;
                        lodash.toFinite = toFinite;
                        lodash.toInteger = toInteger;
                        lodash.toLength = toLength;
                        lodash.toLower = toLower;
                        lodash.toNumber = toNumber;
                        lodash.toSafeInteger = toSafeInteger;
                        lodash.toString = toString;
                        lodash.toUpper = toUpper;
                        lodash.trim = trim;
                        lodash.trimEnd = trimEnd;
                        lodash.trimStart = trimStart;
                        lodash.truncate = truncate;
                        lodash.unescape = unescape;
                        lodash.uniqueId = uniqueId;
                        lodash.upperCase = upperCase;
                        lodash.upperFirst = upperFirst;
                        lodash.each = forEach;
                        lodash.eachRight = forEachRight;
                        lodash.first = head;
                        mixin(lodash, function () {
                            var source = {};
                            baseForOwn(lodash, function (func, methodName) {
                                if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                                    source[methodName] = func
                                }
                            });
                            return source
                        }(), {chain: false});
                        lodash.VERSION = VERSION;
                        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (methodName) {
                            lodash[methodName].placeholder = lodash
                        });
                        arrayEach(["drop", "take"], function (methodName, index) {
                            LazyWrapper.prototype[methodName] = function (n) {
                                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                                var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                                if (result.__filtered__) {
                                    result.__takeCount__ = nativeMin(n, result.__takeCount__)
                                } else {
                                    result.__views__.push({
                                        size: nativeMin(n, MAX_ARRAY_LENGTH),
                                        type: methodName + (result.__dir__ < 0 ? "Right" : "")
                                    })
                                }
                                return result
                            };
                            LazyWrapper.prototype[methodName + "Right"] = function (n) {
                                return this.reverse()[methodName](n).reverse()
                            }
                        });
                        arrayEach(["filter", "map", "takeWhile"], function (methodName, index) {
                            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                            LazyWrapper.prototype[methodName] = function (iteratee) {
                                var result = this.clone();
                                result.__iteratees__.push({iteratee: getIteratee(iteratee, 3), type: type});
                                result.__filtered__ = result.__filtered__ || isFilter;
                                return result
                            }
                        });
                        arrayEach(["head", "last"], function (methodName, index) {
                            var takeName = "take" + (index ? "Right" : "");
                            LazyWrapper.prototype[methodName] = function () {
                                return this[takeName](1).value()[0]
                            }
                        });
                        arrayEach(["initial", "tail"], function (methodName, index) {
                            var dropName = "drop" + (index ? "" : "Right");
                            LazyWrapper.prototype[methodName] = function () {
                                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
                            }
                        });
                        LazyWrapper.prototype.compact = function () {
                            return this.filter(identity)
                        };
                        LazyWrapper.prototype.find = function (predicate) {
                            return this.filter(predicate).head()
                        };
                        LazyWrapper.prototype.findLast = function (predicate) {
                            return this.reverse().find(predicate)
                        };
                        LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
                            if (typeof path == "function") {
                                return new LazyWrapper(this)
                            }
                            return this.map(function (value) {
                                return baseInvoke(value, path, args)
                            })
                        });
                        LazyWrapper.prototype.reject = function (predicate) {
                            return this.filter(negate(getIteratee(predicate)))
                        };
                        LazyWrapper.prototype.slice = function (start, end) {
                            start = toInteger(start);
                            var result = this;
                            if (result.__filtered__ && (start > 0 || end < 0)) {
                                return new LazyWrapper(result)
                            }
                            if (start < 0) {
                                result = result.takeRight(-start)
                            } else if (start) {
                                result = result.drop(start)
                            }
                            if (end !== undefined) {
                                end = toInteger(end);
                                result = end < 0 ? result.dropRight(-end) : result.take(end - start)
                            }
                            return result
                        };
                        LazyWrapper.prototype.takeRightWhile = function (predicate) {
                            return this.reverse().takeWhile(predicate).reverse()
                        };
                        LazyWrapper.prototype.toArray = function () {
                            return this.take(MAX_ARRAY_LENGTH)
                        };
                        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                                isTaker = /^(?:head|last)$/.test(methodName),
                                lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName],
                                retUnwrapped = isTaker || /^find/.test(methodName);
                            if (!lodashFunc) {
                                return
                            }
                            lodash.prototype[methodName] = function () {
                                var value = this.__wrapped__, args = isTaker ? [1] : arguments,
                                    isLazy = value instanceof LazyWrapper, iteratee = args[0],
                                    useLazy = isLazy || isArray(value);
                                var interceptor = function (value) {
                                    var result = lodashFunc.apply(lodash, arrayPush([value], args));
                                    return isTaker && chainAll ? result[0] : result
                                };
                                if (useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1) {
                                    isLazy = useLazy = false
                                }
                                var chainAll = this.__chain__, isHybrid = !!this.__actions__.length,
                                    isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                                if (!retUnwrapped && useLazy) {
                                    value = onlyLazy ? value : new LazyWrapper(this);
                                    var result = func.apply(value, args);
                                    result.__actions__.push({func: thru, args: [interceptor], thisArg: undefined});
                                    return new LodashWrapper(result, chainAll)
                                }
                                if (isUnwrapped && onlyLazy) {
                                    return func.apply(this, args)
                                }
                                result = this.thru(interceptor);
                                return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result
                            }
                        });
                        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function (methodName) {
                            var func = arrayProto[methodName],
                                chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru",
                                retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                            lodash.prototype[methodName] = function () {
                                var args = arguments;
                                if (retUnwrapped && !this.__chain__) {
                                    var value = this.value();
                                    return func.apply(isArray(value) ? value : [], args)
                                }
                                return this[chainName](function (value) {
                                    return func.apply(isArray(value) ? value : [], args)
                                })
                            }
                        });
                        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                            var lodashFunc = lodash[methodName];
                            if (lodashFunc) {
                                var key = lodashFunc.name + "", names = realNames[key] || (realNames[key] = []);
                                names.push({name: methodName, func: lodashFunc})
                            }
                        });
                        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
                            name: "wrapper",
                            func: undefined
                        }];
                        LazyWrapper.prototype.clone = lazyClone;
                        LazyWrapper.prototype.reverse = lazyReverse;
                        LazyWrapper.prototype.value = lazyValue;
                        lodash.prototype.at = wrapperAt;
                        lodash.prototype.chain = wrapperChain;
                        lodash.prototype.commit = wrapperCommit;
                        lodash.prototype.next = wrapperNext;
                        lodash.prototype.plant = wrapperPlant;
                        lodash.prototype.reverse = wrapperReverse;
                        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                        lodash.prototype.first = lodash.prototype.head;
                        if (symIterator) {
                            lodash.prototype[symIterator] = wrapperToIterator
                        }
                        return lodash
                    };
                    var _ = runInContext();
                    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                        root._ = _;
                        define(function () {
                            return _
                        })
                    } else if (freeModule) {
                        (freeModule.exports = _)._ = _;
                        freeExports._ = _
                    } else {
                        root._ = _
                    }
                }).call(this)
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}],
        197: [function (require, module, exports) {
            "use strict";
            module.exports = require("./src/index-minimal")
        }, {"./src/index-minimal": 198}],
        198: [function (require, module, exports) {
            "use strict";
            var protobuf = exports;
            protobuf.build = "minimal";
            protobuf.Writer = require("./writer");
            protobuf.BufferWriter = require("./writer_buffer");
            protobuf.Reader = require("./reader");
            protobuf.BufferReader = require("./reader_buffer");
            protobuf.util = require("./util/minimal");
            protobuf.rpc = require("./rpc");
            protobuf.roots = require("./roots");
            protobuf.configure = configure;

            function configure() {
                protobuf.Reader._configure(protobuf.BufferReader);
                protobuf.util._configure()
            }

            protobuf.Writer._configure(protobuf.BufferWriter);
            configure()
        }, {
            "./reader": 199,
            "./reader_buffer": 200,
            "./roots": 201,
            "./rpc": 202,
            "./util/minimal": 205,
            "./writer": 206,
            "./writer_buffer": 207
        }],
        199: [function (require, module, exports) {
            "use strict";
            module.exports = Reader;
            var util = require("./util/minimal");
            var BufferReader;
            var LongBits = util.LongBits, utf8 = util.utf8;

            function indexOutOfRange(reader, writeLength) {
                return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len)
            }

            function Reader(buffer) {
                this.buf = buffer;
                this.pos = 0;
                this.len = buffer.length
            }

            var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
                if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
                throw Error("illegal buffer")
            } : function create_array(buffer) {
                if (Array.isArray(buffer)) return new Reader(buffer);
                throw Error("illegal buffer")
            };
            Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
                return (Reader.create = function create_buffer(buffer) {
                    return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer)
                })(buffer)
            } : create_array;
            Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
            Reader.prototype.uint32 = function read_uint32_setup() {
                var value = 4294967295;
                return function read_uint32() {
                    value = (this.buf[this.pos] & 127) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
                    if (this.buf[this.pos++] < 128) return value;
                    if ((this.pos += 5) > this.len) {
                        this.pos = this.len;
                        throw indexOutOfRange(this, 10)
                    }
                    return value
                }
            }();
            Reader.prototype.int32 = function read_int32() {
                return this.uint32() | 0
            };
            Reader.prototype.sint32 = function read_sint32() {
                var value = this.uint32();
                return value >>> 1 ^ -(value & 1) | 0
            };

            function readLongVarint() {
                var bits = new LongBits(0, 0);
                var i = 0;
                if (this.len - this.pos > 4) {
                    for (; i < 4; ++i) {
                        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                        if (this.buf[this.pos++] < 128) return bits
                    }
                    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
                    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
                    if (this.buf[this.pos++] < 128) return bits;
                    i = 0
                } else {
                    for (; i < 3; ++i) {
                        if (this.pos >= this.len) throw indexOutOfRange(this);
                        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                        if (this.buf[this.pos++] < 128) return bits
                    }
                    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
                    return bits
                }
                if (this.len - this.pos > 4) {
                    for (; i < 5; ++i) {
                        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                        if (this.buf[this.pos++] < 128) return bits
                    }
                } else {
                    for (; i < 5; ++i) {
                        if (this.pos >= this.len) throw indexOutOfRange(this);
                        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                        if (this.buf[this.pos++] < 128) return bits
                    }
                }
                throw Error("invalid varint encoding")
            }

            Reader.prototype.bool = function read_bool() {
                return this.uint32() !== 0
            };

            function readFixed32_end(buf, end) {
                return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0
            }

            Reader.prototype.fixed32 = function read_fixed32() {
                if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                return readFixed32_end(this.buf, this.pos += 4)
            };
            Reader.prototype.sfixed32 = function read_sfixed32() {
                if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                return readFixed32_end(this.buf, this.pos += 4) | 0
            };

            function readFixed64() {
                if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
                return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4))
            }

            Reader.prototype.float = function read_float() {
                if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
                var value = util.float.readFloatLE(this.buf, this.pos);
                this.pos += 4;
                return value
            };
            Reader.prototype.double = function read_double() {
                if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
                var value = util.float.readDoubleLE(this.buf, this.pos);
                this.pos += 8;
                return value
            };
            Reader.prototype.bytes = function read_bytes() {
                var length = this.uint32(), start = this.pos, end = this.pos + length;
                if (end > this.len) throw indexOutOfRange(this, length);
                this.pos += length;
                if (Array.isArray(this.buf)) return this.buf.slice(start, end);
                return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end)
            };
            Reader.prototype.string = function read_string() {
                var bytes = this.bytes();
                return utf8.read(bytes, 0, bytes.length)
            };
            Reader.prototype.skip = function skip(length) {
                if (typeof length === "number") {
                    if (this.pos + length > this.len) throw indexOutOfRange(this, length);
                    this.pos += length
                } else {
                    do {
                        if (this.pos >= this.len) throw indexOutOfRange(this)
                    } while (this.buf[this.pos++] & 128)
                }
                return this
            };
            Reader.prototype.skipType = function (wireType) {
                switch (wireType) {
                    case 0:
                        this.skip();
                        break;
                    case 1:
                        this.skip(8);
                        break;
                    case 2:
                        this.skip(this.uint32());
                        break;
                    case 3:
                        do {
                            if ((wireType = this.uint32() & 7) === 4) break;
                            this.skipType(wireType)
                        } while (true);
                        break;
                    case 5:
                        this.skip(4);
                        break;
                    default:
                        throw Error("invalid wire type " + wireType + " at offset " + this.pos)
                }
                return this
            };
            Reader._configure = function (BufferReader_) {
                BufferReader = BufferReader_;
                var fn = util.Long ? "toLong" : "toNumber";
                util.merge(Reader.prototype, {
                    int64: function read_int64() {
                        return readLongVarint.call(this)[fn](false)
                    }, uint64: function read_uint64() {
                        return readLongVarint.call(this)[fn](true)
                    }, sint64: function read_sint64() {
                        return readLongVarint.call(this).zzDecode()[fn](false)
                    }, fixed64: function read_fixed64() {
                        return readFixed64.call(this)[fn](true)
                    }, sfixed64: function read_sfixed64() {
                        return readFixed64.call(this)[fn](false)
                    }
                })
            }
        }, {"./util/minimal": 205}],
        200: [function (require, module, exports) {
            "use strict";
            module.exports = BufferReader;
            var Reader = require("./reader");
            (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
            var util = require("./util/minimal");

            function BufferReader(buffer) {
                Reader.call(this, buffer)
            }

            if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
            BufferReader.prototype.string = function read_string_buffer() {
                var len = this.uint32();
                return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
            }
        }, {"./reader": 199, "./util/minimal": 205}],
        201: [function (require, module, exports) {
            "use strict";
            module.exports = {}
        }, {}],
        202: [function (require, module, exports) {
            "use strict";
            var rpc = exports;
            rpc.Service = require("./rpc/service")
        }, {"./rpc/service": 203}],
        203: [function (require, module, exports) {
            "use strict";
            module.exports = Service;
            var util = require("../util/minimal");
            (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

            function Service(rpcImpl, requestDelimited, responseDelimited) {
                if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
                util.EventEmitter.call(this);
                this.rpcImpl = rpcImpl;
                this.requestDelimited = Boolean(requestDelimited);
                this.responseDelimited = Boolean(responseDelimited)
            }

            Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
                if (!request) throw TypeError("request must be specified");
                var self = this;
                if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);
                if (!self.rpcImpl) {
                    setTimeout(function () {
                        callback(Error("already ended"))
                    }, 0);
                    return undefined
                }
                try {
                    return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
                        if (err) {
                            self.emit("error", err, method);
                            return callback(err)
                        }
                        if (response === null) {
                            self.end(true);
                            return undefined
                        }
                        if (!(response instanceof responseCtor)) {
                            try {
                                response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response)
                            } catch (err) {
                                self.emit("error", err, method);
                                return callback(err)
                            }
                        }
                        self.emit("data", response, method);
                        return callback(null, response)
                    })
                } catch (err) {
                    self.emit("error", err, method);
                    setTimeout(function () {
                        callback(err)
                    }, 0);
                    return undefined
                }
            };
            Service.prototype.end = function end(endedByRPC) {
                if (this.rpcImpl) {
                    if (!endedByRPC) this.rpcImpl(null, null, null);
                    this.rpcImpl = null;
                    this.emit("end").off()
                }
                return this
            }
        }, {"../util/minimal": 205}],
        204: [function (require, module, exports) {
            "use strict";
            module.exports = LongBits;
            var util = require("../util/minimal");

            function LongBits(lo, hi) {
                this.lo = lo >>> 0;
                this.hi = hi >>> 0
            }

            var zero = LongBits.zero = new LongBits(0, 0);
            zero.toNumber = function () {
                return 0
            };
            zero.zzEncode = zero.zzDecode = function () {
                return this
            };
            zero.length = function () {
                return 1
            };
            var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
            LongBits.fromNumber = function fromNumber(value) {
                if (value === 0) return zero;
                var sign = value < 0;
                if (sign) value = -value;
                var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
                if (sign) {
                    hi = ~hi >>> 0;
                    lo = ~lo >>> 0;
                    if (++lo > 4294967295) {
                        lo = 0;
                        if (++hi > 4294967295) hi = 0
                    }
                }
                return new LongBits(lo, hi)
            };
            LongBits.from = function from(value) {
                if (typeof value === "number") return LongBits.fromNumber(value);
                if (util.isString(value)) {
                    if (util.Long) value = util.Long.fromString(value); else return LongBits.fromNumber(parseInt(value, 10))
                }
                return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero
            };
            LongBits.prototype.toNumber = function toNumber(unsigned) {
                if (!unsigned && this.hi >>> 31) {
                    var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
                    if (!lo) hi = hi + 1 >>> 0;
                    return -(lo + hi * 4294967296)
                }
                return this.lo + this.hi * 4294967296
            };
            LongBits.prototype.toLong = function toLong(unsigned) {
                return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
                    low: this.lo | 0,
                    high: this.hi | 0,
                    unsigned: Boolean(unsigned)
                }
            };
            var charCodeAt = String.prototype.charCodeAt;
            LongBits.fromHash = function fromHash(hash) {
                if (hash === zeroHash) return zero;
                return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0)
            };
            LongBits.prototype.toHash = function toHash() {
                return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
            };
            LongBits.prototype.zzEncode = function zzEncode() {
                var mask = this.hi >> 31;
                this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
                this.lo = (this.lo << 1 ^ mask) >>> 0;
                return this
            };
            LongBits.prototype.zzDecode = function zzDecode() {
                var mask = -(this.lo & 1);
                this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
                this.hi = (this.hi >>> 1 ^ mask) >>> 0;
                return this
            };
            LongBits.prototype.length = function length() {
                var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
                return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10
            }
        }, {"../util/minimal": 205}],
        205: [function (require, module, exports) {
            (function (global) {
                "use strict";
                var util = exports;
                util.asPromise = require("@protobufjs/aspromise");
                util.base64 = require("@protobufjs/base64");
                util.EventEmitter = require("@protobufjs/eventemitter");
                util.float = require("@protobufjs/float");
                util.inquire = require("@protobufjs/inquire");
                util.utf8 = require("@protobufjs/utf8");
                util.pool = require("@protobufjs/pool");
                util.LongBits = require("./longbits");
                util.emptyArray = Object.freeze ? Object.freeze([]) : [];
                util.emptyObject = Object.freeze ? Object.freeze({}) : {};
                util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);
                util.isInteger = Number.isInteger || function isInteger(value) {
                    return typeof value === "number" && isFinite(value) && Math.floor(value) === value
                };
                util.isString = function isString(value) {
                    return typeof value === "string" || value instanceof String
                };
                util.isObject = function isObject(value) {
                    return value && typeof value === "object"
                };
                util.isset = util.isSet = function isSet(obj, prop) {
                    var value = obj[prop];
                    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
                    return false
                };
                util.Buffer = function () {
                    try {
                        var Buffer = util.inquire("buffer").Buffer;
                        return Buffer.prototype.utf8Write ? Buffer : null
                    } catch (e) {
                        return null
                    }
                }();
                util._Buffer_from = null;
                util._Buffer_allocUnsafe = null;
                util.newBuffer = function newBuffer(sizeOrArray) {
                    return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray)
                };
                util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
                util.Long = global.dcodeIO && global.dcodeIO.Long || util.inquire("long");
                util.key2Re = /^true|false|0|1$/;
                util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
                util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
                util.longToHash = function longToHash(value) {
                    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash
                };
                util.longFromHash = function longFromHash(hash, unsigned) {
                    var bits = util.LongBits.fromHash(hash);
                    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
                    return bits.toNumber(Boolean(unsigned))
                };

                function merge(dst, src, ifNotSet) {
                    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
                    return dst
                }

                util.merge = merge;
                util.lcFirst = function lcFirst(str) {
                    return str.charAt(0).toLowerCase() + str.substring(1)
                };

                function newError(name) {
                    function CustomError(message, properties) {
                        if (!(this instanceof CustomError)) return new CustomError(message, properties);
                        Object.defineProperty(this, "message", {
                            get: function () {
                                return message
                            }
                        });
                        if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError); else Object.defineProperty(this, "stack", {value: (new Error).stack || ""});
                        if (properties) merge(this, properties)
                    }

                    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
                    Object.defineProperty(CustomError.prototype, "name", {
                        get: function () {
                            return name
                        }
                    });
                    CustomError.prototype.toString = function toString() {
                        return this.name + ": " + this.message
                    };
                    return CustomError
                }

                util.newError = newError;
                util.ProtocolError = newError("ProtocolError");
                util.oneOfGetter = function getOneOf(fieldNames) {
                    var fieldMap = {};
                    for (var i = 0; i < fieldNames.length; ++i) fieldMap[fieldNames[i]] = 1;
                    return function () {
                        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i) if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i]
                    }
                };
                util.oneOfSetter = function setOneOf(fieldNames) {
                    return function (name) {
                        for (var i = 0; i < fieldNames.length; ++i) if (fieldNames[i] !== name) delete this[fieldNames[i]]
                    }
                };
                util.toJSONOptions = {longs: String, enums: String, bytes: String, json: true};
                util._configure = function () {
                    var Buffer = util.Buffer;
                    if (!Buffer) {
                        util._Buffer_from = util._Buffer_allocUnsafe = null;
                        return
                    }
                    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || function Buffer_from(value, encoding) {
                        return new Buffer(value, encoding)
                    };
                    util._Buffer_allocUnsafe = Buffer.allocUnsafe || function Buffer_allocUnsafe(size) {
                        return new Buffer(size)
                    }
                }
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {
            "./longbits": 204,
            "@protobufjs/aspromise": 1,
            "@protobufjs/base64": 2,
            "@protobufjs/eventemitter": 3,
            "@protobufjs/float": 4,
            "@protobufjs/inquire": 5,
            "@protobufjs/pool": 6,
            "@protobufjs/utf8": 7
        }],
        206: [function (require, module, exports) {
            "use strict";
            module.exports = Writer;
            var util = require("./util/minimal");
            var BufferWriter;
            var LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;

            function Op(fn, len, val) {
                this.fn = fn;
                this.len = len;
                this.next = undefined;
                this.val = val
            }

            function noop() {
            }

            function State(writer) {
                this.head = writer.head;
                this.tail = writer.tail;
                this.len = writer.len;
                this.next = writer.states
            }

            function Writer() {
                this.len = 0;
                this.head = new Op(noop, 0, 0);
                this.tail = this.head;
                this.states = null
            }

            Writer.create = util.Buffer ? function create_buffer_setup() {
                return (Writer.create = function create_buffer() {
                    return new BufferWriter
                })()
            } : function create_array() {
                return new Writer
            };
            Writer.alloc = function alloc(size) {
                return new util.Array(size)
            };
            if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
            Writer.prototype._push = function push(fn, len, val) {
                this.tail = this.tail.next = new Op(fn, len, val);
                this.len += len;
                return this
            };

            function writeByte(val, buf, pos) {
                buf[pos] = val & 255
            }

            function writeVarint32(val, buf, pos) {
                while (val > 127) {
                    buf[pos++] = val & 127 | 128;
                    val >>>= 7
                }
                buf[pos] = val
            }

            function VarintOp(len, val) {
                this.len = len;
                this.next = undefined;
                this.val = val
            }

            VarintOp.prototype = Object.create(Op.prototype);
            VarintOp.prototype.fn = writeVarint32;
            Writer.prototype.uint32 = function write_uint32(value) {
                this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
                return this
            };
            Writer.prototype.int32 = function write_int32(value) {
                return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value)
            };
            Writer.prototype.sint32 = function write_sint32(value) {
                return this.uint32((value << 1 ^ value >> 31) >>> 0)
            };

            function writeVarint64(val, buf, pos) {
                while (val.hi) {
                    buf[pos++] = val.lo & 127 | 128;
                    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
                    val.hi >>>= 7
                }
                while (val.lo > 127) {
                    buf[pos++] = val.lo & 127 | 128;
                    val.lo = val.lo >>> 7
                }
                buf[pos++] = val.lo
            }

            Writer.prototype.uint64 = function write_uint64(value) {
                var bits = LongBits.from(value);
                return this._push(writeVarint64, bits.length(), bits)
            };
            Writer.prototype.int64 = Writer.prototype.uint64;
            Writer.prototype.sint64 = function write_sint64(value) {
                var bits = LongBits.from(value).zzEncode();
                return this._push(writeVarint64, bits.length(), bits)
            };
            Writer.prototype.bool = function write_bool(value) {
                return this._push(writeByte, 1, value ? 1 : 0)
            };

            function writeFixed32(val, buf, pos) {
                buf[pos] = val & 255;
                buf[pos + 1] = val >>> 8 & 255;
                buf[pos + 2] = val >>> 16 & 255;
                buf[pos + 3] = val >>> 24
            }

            Writer.prototype.fixed32 = function write_fixed32(value) {
                return this._push(writeFixed32, 4, value >>> 0)
            };
            Writer.prototype.sfixed32 = Writer.prototype.fixed32;
            Writer.prototype.fixed64 = function write_fixed64(value) {
                var bits = LongBits.from(value);
                return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)
            };
            Writer.prototype.sfixed64 = Writer.prototype.fixed64;
            Writer.prototype.float = function write_float(value) {
                return this._push(util.float.writeFloatLE, 4, value)
            };
            Writer.prototype.double = function write_double(value) {
                return this._push(util.float.writeDoubleLE, 8, value)
            };
            var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
                buf.set(val, pos)
            } : function writeBytes_for(val, buf, pos) {
                for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i]
            };
            Writer.prototype.bytes = function write_bytes(value) {
                var len = value.length >>> 0;
                if (!len) return this._push(writeByte, 1, 0);
                if (util.isString(value)) {
                    var buf = Writer.alloc(len = base64.length(value));
                    base64.decode(value, buf, 0);
                    value = buf
                }
                return this.uint32(len)._push(writeBytes, len, value)
            };
            Writer.prototype.string = function write_string(value) {
                var len = utf8.length(value);
                return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0)
            };
            Writer.prototype.fork = function fork() {
                this.states = new State(this);
                this.head = this.tail = new Op(noop, 0, 0);
                this.len = 0;
                return this
            };
            Writer.prototype.reset = function reset() {
                if (this.states) {
                    this.head = this.states.head;
                    this.tail = this.states.tail;
                    this.len = this.states.len;
                    this.states = this.states.next
                } else {
                    this.head = this.tail = new Op(noop, 0, 0);
                    this.len = 0
                }
                return this
            };
            Writer.prototype.ldelim = function ldelim() {
                var head = this.head, tail = this.tail, len = this.len;
                this.reset().uint32(len);
                if (len) {
                    this.tail.next = head.next;
                    this.tail = tail;
                    this.len += len
                }
                return this
            };
            Writer.prototype.finish = function finish() {
                var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
                while (head) {
                    head.fn(head.val, buf, pos);
                    pos += head.len;
                    head = head.next
                }
                return buf
            };
            Writer._configure = function (BufferWriter_) {
                BufferWriter = BufferWriter_
            }
        }, {"./util/minimal": 205}],
        207: [function (require, module, exports) {
            "use strict";
            module.exports = BufferWriter;
            var Writer = require("./writer");
            (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
            var util = require("./util/minimal");
            var Buffer = util.Buffer;

            function BufferWriter() {
                Writer.call(this)
            }

            BufferWriter.alloc = function alloc_buffer(size) {
                return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size)
            };
            var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
                buf.set(val, pos)
            } : function writeBytesBuffer_copy(val, buf, pos) {
                if (val.copy) val.copy(buf, pos, 0, val.length); else for (var i = 0; i < val.length;) buf[pos++] = val[i++]
            };
            BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
                if (util.isString(value)) value = util._Buffer_from(value, "base64");
                var len = value.length >>> 0;
                this.uint32(len);
                if (len) this._push(writeBytesBuffer, len, value);
                return this
            };

            function writeStringBuffer(val, buf, pos) {
                if (val.length < 40) util.utf8.write(val, buf, pos); else buf.utf8Write(val, pos)
            }

            BufferWriter.prototype.string = function write_string_buffer(value) {
                var len = Buffer.byteLength(value);
                this.uint32(len);
                if (len) this._push(writeStringBuffer, len, value);
                return this
            }
        }, {"./util/minimal": 205, "./writer": 206}],
        208: [function (require, module, exports) {
            (function (global) {
                (function (root) {
                    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
                    var freeModule = typeof module == "object" && module && !module.nodeType && module;
                    var freeGlobal = typeof global == "object" && global;
                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                        root = freeGlobal
                    }
                    var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700,
                        initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/,
                        regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                            overflow: "Overflow: input needs wider integers to process",
                            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                            "invalid-input": "Invalid input"
                        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;

                    function error(type) {
                        throw new RangeError(errors[type])
                    }

                    function map(array, fn) {
                        var length = array.length;
                        var result = [];
                        while (length--) {
                            result[length] = fn(array[length])
                        }
                        return result
                    }

                    function mapDomain(string, fn) {
                        var parts = string.split("@");
                        var result = "";
                        if (parts.length > 1) {
                            result = parts[0] + "@";
                            string = parts[1]
                        }
                        string = string.replace(regexSeparators, ".");
                        var labels = string.split(".");
                        var encoded = map(labels, fn).join(".");
                        return result + encoded
                    }

                    function ucs2decode(string) {
                        var output = [], counter = 0, length = string.length, value, extra;
                        while (counter < length) {
                            value = string.charCodeAt(counter++);
                            if (value >= 55296 && value <= 56319 && counter < length) {
                                extra = string.charCodeAt(counter++);
                                if ((extra & 64512) == 56320) {
                                    output.push(((value & 1023) << 10) + (extra & 1023) + 65536)
                                } else {
                                    output.push(value);
                                    counter--
                                }
                            } else {
                                output.push(value)
                            }
                        }
                        return output
                    }

                    function ucs2encode(array) {
                        return map(array, function (value) {
                            var output = "";
                            if (value > 65535) {
                                value -= 65536;
                                output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                                value = 56320 | value & 1023
                            }
                            output += stringFromCharCode(value);
                            return output
                        }).join("")
                    }

                    function basicToDigit(codePoint) {
                        if (codePoint - 48 < 10) {
                            return codePoint - 22
                        }
                        if (codePoint - 65 < 26) {
                            return codePoint - 65
                        }
                        if (codePoint - 97 < 26) {
                            return codePoint - 97
                        }
                        return base
                    }

                    function digitToBasic(digit, flag) {
                        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
                    }

                    function adapt(delta, numPoints, firstTime) {
                        var k = 0;
                        delta = firstTime ? floor(delta / damp) : delta >> 1;
                        delta += floor(delta / numPoints);
                        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                            delta = floor(delta / baseMinusTMin)
                        }
                        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew))
                    }

                    function decode(input) {
                        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias,
                            basic, j, index, oldi, w, k, digit, t, baseMinusT;
                        basic = input.lastIndexOf(delimiter);
                        if (basic < 0) {
                            basic = 0
                        }
                        for (j = 0; j < basic; ++j) {
                            if (input.charCodeAt(j) >= 128) {
                                error("not-basic")
                            }
                            output.push(input.charCodeAt(j))
                        }
                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                            for (oldi = i, w = 1, k = base; ; k += base) {
                                if (index >= inputLength) {
                                    error("invalid-input")
                                }
                                digit = basicToDigit(input.charCodeAt(index++));
                                if (digit >= base || digit > floor((maxInt - i) / w)) {
                                    error("overflow")
                                }
                                i += digit * w;
                                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                if (digit < t) {
                                    break
                                }
                                baseMinusT = base - t;
                                if (w > floor(maxInt / baseMinusT)) {
                                    error("overflow")
                                }
                                w *= baseMinusT
                            }
                            out = output.length + 1;
                            bias = adapt(i - oldi, out, oldi == 0);
                            if (floor(i / out) > maxInt - n) {
                                error("overflow")
                            }
                            n += floor(i / out);
                            i %= out;
                            output.splice(i++, 0, n)
                        }
                        return ucs2encode(output)
                    }

                    function encode(input) {
                        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [],
                            inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                        input = ucs2decode(input);
                        inputLength = input.length;
                        n = initialN;
                        delta = 0;
                        bias = initialBias;
                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue < 128) {
                                output.push(stringFromCharCode(currentValue))
                            }
                        }
                        handledCPCount = basicLength = output.length;
                        if (basicLength) {
                            output.push(delimiter)
                        }
                        while (handledCPCount < inputLength) {
                            for (m = maxInt, j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue >= n && currentValue < m) {
                                    m = currentValue
                                }
                            }
                            handledCPCountPlusOne = handledCPCount + 1;
                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                error("overflow")
                            }
                            delta += (m - n) * handledCPCountPlusOne;
                            n = m;
                            for (j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue < n && ++delta > maxInt) {
                                    error("overflow")
                                }
                                if (currentValue == n) {
                                    for (q = delta, k = base; ; k += base) {
                                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                        if (q < t) {
                                            break
                                        }
                                        qMinusT = q - t;
                                        baseMinusT = base - t;
                                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                        q = floor(qMinusT / baseMinusT)
                                    }
                                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                    delta = 0;
                                    ++handledCPCount
                                }
                            }
                            ++delta;
                            ++n
                        }
                        return output.join("")
                    }

                    function toUnicode(input) {
                        return mapDomain(input, function (string) {
                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string
                        })
                    }

                    function toASCII(input) {
                        return mapDomain(input, function (string) {
                            return regexNonASCII.test(string) ? "xn--" + encode(string) : string
                        })
                    }

                    punycode = {
                        version: "1.4.1",
                        ucs2: {decode: ucs2decode, encode: ucs2encode},
                        decode: decode,
                        encode: encode,
                        toASCII: toASCII,
                        toUnicode: toUnicode
                    };
                    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                        define("punycode", function () {
                            return punycode
                        })
                    } else if (freeExports && freeModule) {
                        if (module.exports == freeExports) {
                            freeModule.exports = punycode
                        } else {
                            for (key in punycode) {
                                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key])
                            }
                        }
                    } else {
                        root.punycode = punycode
                    }
                })(this)
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}],
        209: [function (require, module, exports) {
            "use strict";

            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop)
            }

            module.exports = function (qs, sep, eq, options) {
                sep = sep || "&";
                eq = eq || "=";
                var obj = {};
                if (typeof qs !== "string" || qs.length === 0) {
                    return obj
                }
                var regexp = /\+/g;
                qs = qs.split(sep);
                var maxKeys = 1e3;
                if (options && typeof options.maxKeys === "number") {
                    maxKeys = options.maxKeys
                }
                var len = qs.length;
                if (maxKeys > 0 && len > maxKeys) {
                    len = maxKeys
                }
                for (var i = 0; i < len; ++i) {
                    var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
                    if (idx >= 0) {
                        kstr = x.substr(0, idx);
                        vstr = x.substr(idx + 1)
                    } else {
                        kstr = x;
                        vstr = ""
                    }
                    k = decodeURIComponent(kstr);
                    v = decodeURIComponent(vstr);
                    if (!hasOwnProperty(obj, k)) {
                        obj[k] = v
                    } else if (isArray(obj[k])) {
                        obj[k].push(v)
                    } else {
                        obj[k] = [obj[k], v]
                    }
                }
                return obj
            };
            var isArray = Array.isArray || function (xs) {
                return Object.prototype.toString.call(xs) === "[object Array]"
            }
        }, {}],
        210: [function (require, module, exports) {
            "use strict";
            var stringifyPrimitive = function (v) {
                switch (typeof v) {
                    case"string":
                        return v;
                    case"boolean":
                        return v ? "true" : "false";
                    case"number":
                        return isFinite(v) ? v : "";
                    default:
                        return ""
                }
            };
            module.exports = function (obj, sep, eq, name) {
                sep = sep || "&";
                eq = eq || "=";
                if (obj === null) {
                    obj = undefined
                }
                if (typeof obj === "object") {
                    return map(objectKeys(obj), function (k) {
                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                        if (isArray(obj[k])) {
                            return map(obj[k], function (v) {
                                return ks + encodeURIComponent(stringifyPrimitive(v))
                            }).join(sep)
                        } else {
                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]))
                        }
                    }).join(sep)
                }
                if (!name) return "";
                return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj))
            };
            var isArray = Array.isArray || function (xs) {
                return Object.prototype.toString.call(xs) === "[object Array]"
            };

            function map(xs, f) {
                if (xs.map) return xs.map(f);
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                    res.push(f(xs[i], i))
                }
                return res
            }

            var objectKeys = Object.keys || function (obj) {
                var res = [];
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key)
                }
                return res
            }
        }, {}],
        211: [function (require, module, exports) {
            "use strict";
            exports.decode = exports.parse = require("./decode");
            exports.encode = exports.stringify = require("./encode")
        }, {"./decode": 209, "./encode": 210}],
        212: [function (require, module, exports) {
            var alea = require("./lib/alea");
            var xor128 = require("./lib/xor128");
            var xorwow = require("./lib/xorwow");
            var xorshift7 = require("./lib/xorshift7");
            var xor4096 = require("./lib/xor4096");
            var tychei = require("./lib/tychei");
            var sr = require("./seedrandom");
            sr.alea = alea;
            sr.xor128 = xor128;
            sr.xorwow = xorwow;
            sr.xorshift7 = xorshift7;
            sr.xor4096 = xor4096;
            sr.tychei = tychei;
            module.exports = sr
        }, {
            "./lib/alea": 213,
            "./lib/tychei": 214,
            "./lib/xor128": 215,
            "./lib/xor4096": 216,
            "./lib/xorshift7": 217,
            "./lib/xorwow": 218,
            "./seedrandom": 219
        }],
        213: [function (require, module, exports) {
            (function (global, module, define) {
                function Alea(seed) {
                    var me = this, mash = Mash();
                    me.next = function () {
                        var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10;
                        me.s0 = me.s1;
                        me.s1 = me.s2;
                        return me.s2 = t - (me.c = t | 0)
                    };
                    me.c = 1;
                    me.s0 = mash(" ");
                    me.s1 = mash(" ");
                    me.s2 = mash(" ");
                    me.s0 -= mash(seed);
                    if (me.s0 < 0) {
                        me.s0 += 1
                    }
                    me.s1 -= mash(seed);
                    if (me.s1 < 0) {
                        me.s1 += 1
                    }
                    me.s2 -= mash(seed);
                    if (me.s2 < 0) {
                        me.s2 += 1
                    }
                    mash = null
                }

                function copy(f, t) {
                    t.c = f.c;
                    t.s0 = f.s0;
                    t.s1 = f.s1;
                    t.s2 = f.s2;
                    return t
                }

                function impl(seed, opts) {
                    var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
                    prng.int32 = function () {
                        return xg.next() * 4294967296 | 0
                    };
                    prng.double = function () {
                        return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32
                    };
                    prng.quick = prng;
                    if (state) {
                        if (typeof state == "object") copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {})
                        }
                    }
                    return prng
                }

                function Mash() {
                    var n = 4022871197;
                    var mash = function (data) {
                        data = data.toString();
                        for (var i = 0; i < data.length; i++) {
                            n += data.charCodeAt(i);
                            var h = .02519603282416938 * n;
                            n = h >>> 0;
                            h -= n;
                            h *= n;
                            n = h >>> 0;
                            h -= n;
                            n += h * 4294967296
                        }
                        return (n >>> 0) * 2.3283064365386963e-10
                    };
                    return mash
                }

                if (module && module.exports) {
                    module.exports = impl
                } else if (define && define.amd) {
                    define(function () {
                        return impl
                    })
                } else {
                    this.alea = impl
                }
            })(this, typeof module == "object" && module, typeof define == "function" && define)
        }, {}],
        214: [function (require, module, exports) {
            (function (global, module, define) {
                function XorGen(seed) {
                    var me = this, strseed = "";
                    me.next = function () {
                        var b = me.b, c = me.c, d = me.d, a = me.a;
                        b = b << 25 ^ b >>> 7 ^ c;
                        c = c - d | 0;
                        d = d << 24 ^ d >>> 8 ^ a;
                        a = a - b | 0;
                        me.b = b = b << 20 ^ b >>> 12 ^ c;
                        me.c = c = c - d | 0;
                        me.d = d << 16 ^ c >>> 16 ^ a;
                        return me.a = a - b | 0
                    };
                    me.a = 0;
                    me.b = 0;
                    me.c = 2654435769 | 0;
                    me.d = 1367130551;
                    if (seed === Math.floor(seed)) {
                        me.a = seed / 4294967296 | 0;
                        me.b = seed | 0
                    } else {
                        strseed += seed
                    }
                    for (var k = 0; k < strseed.length + 20; k++) {
                        me.b ^= strseed.charCodeAt(k) | 0;
                        me.next()
                    }
                }

                function copy(f, t) {
                    t.a = f.a;
                    t.b = f.b;
                    t.c = f.c;
                    t.d = f.d;
                    return t
                }

                function impl(seed, opts) {
                    var xg = new XorGen(seed), state = opts && opts.state, prng = function () {
                        return (xg.next() >>> 0) / 4294967296
                    };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296,
                                result = (top + bot) / (1 << 21)
                        } while (result === 0);
                        return result
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (typeof state == "object") copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {})
                        }
                    }
                    return prng
                }

                if (module && module.exports) {
                    module.exports = impl
                } else if (define && define.amd) {
                    define(function () {
                        return impl
                    })
                } else {
                    this.tychei = impl
                }
            })(this, typeof module == "object" && module, typeof define == "function" && define)
        }, {}],
        215: [function (require, module, exports) {
            (function (global, module, define) {
                function XorGen(seed) {
                    var me = this, strseed = "";
                    me.x = 0;
                    me.y = 0;
                    me.z = 0;
                    me.w = 0;
                    me.next = function () {
                        var t = me.x ^ me.x << 11;
                        me.x = me.y;
                        me.y = me.z;
                        me.z = me.w;
                        return me.w ^= me.w >>> 19 ^ t ^ t >>> 8
                    };
                    if (seed === (seed | 0)) {
                        me.x = seed
                    } else {
                        strseed += seed
                    }
                    for (var k = 0; k < strseed.length + 64; k++) {
                        me.x ^= strseed.charCodeAt(k) | 0;
                        me.next()
                    }
                }

                function copy(f, t) {
                    t.x = f.x;
                    t.y = f.y;
                    t.z = f.z;
                    t.w = f.w;
                    return t
                }

                function impl(seed, opts) {
                    var xg = new XorGen(seed), state = opts && opts.state, prng = function () {
                        return (xg.next() >>> 0) / 4294967296
                    };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296,
                                result = (top + bot) / (1 << 21)
                        } while (result === 0);
                        return result
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (typeof state == "object") copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {})
                        }
                    }
                    return prng
                }

                if (module && module.exports) {
                    module.exports = impl
                } else if (define && define.amd) {
                    define(function () {
                        return impl
                    })
                } else {
                    this.xor128 = impl
                }
            })(this, typeof module == "object" && module, typeof define == "function" && define)
        }, {}],
        216: [function (require, module, exports) {
            (function (global, module, define) {
                function XorGen(seed) {
                    var me = this;
                    me.next = function () {
                        var w = me.w, X = me.X, i = me.i, t, v;
                        me.w = w = w + 1640531527 | 0;
                        v = X[i + 34 & 127];
                        t = X[i = i + 1 & 127];
                        v ^= v << 13;
                        t ^= t << 17;
                        v ^= v >>> 15;
                        t ^= t >>> 12;
                        v = X[i] = v ^ t;
                        me.i = i;
                        return v + (w ^ w >>> 16) | 0
                    };

                    function init(me, seed) {
                        var t, v, i, j, w, X = [], limit = 128;
                        if (seed === (seed | 0)) {
                            v = seed;
                            seed = null
                        } else {
                            seed = seed + "\0";
                            v = 0;
                            limit = Math.max(limit, seed.length)
                        }
                        for (i = 0, j = -32; j < limit; ++j) {
                            if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
                            if (j === 0) w = v;
                            v ^= v << 10;
                            v ^= v >>> 15;
                            v ^= v << 4;
                            v ^= v >>> 13;
                            if (j >= 0) {
                                w = w + 1640531527 | 0;
                                t = X[j & 127] ^= v + w;
                                i = 0 == t ? i + 1 : 0
                            }
                        }
                        if (i >= 128) {
                            X[(seed && seed.length || 0) & 127] = -1
                        }
                        i = 127;
                        for (j = 4 * 128; j > 0; --j) {
                            v = X[i + 34 & 127];
                            t = X[i = i + 1 & 127];
                            v ^= v << 13;
                            t ^= t << 17;
                            v ^= v >>> 15;
                            t ^= t >>> 12;
                            X[i] = v ^ t
                        }
                        me.w = w;
                        me.X = X;
                        me.i = i
                    }

                    init(me, seed)
                }

                function copy(f, t) {
                    t.i = f.i;
                    t.w = f.w;
                    t.X = f.X.slice();
                    return t
                }

                function impl(seed, opts) {
                    if (seed == null) seed = +new Date;
                    var xg = new XorGen(seed), state = opts && opts.state, prng = function () {
                        return (xg.next() >>> 0) / 4294967296
                    };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296,
                                result = (top + bot) / (1 << 21)
                        } while (result === 0);
                        return result
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (state.X) copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {})
                        }
                    }
                    return prng
                }

                if (module && module.exports) {
                    module.exports = impl
                } else if (define && define.amd) {
                    define(function () {
                        return impl
                    })
                } else {
                    this.xor4096 = impl
                }
            })(this, typeof module == "object" && module, typeof define == "function" && define)
        }, {}],
        217: [function (require, module, exports) {
            (function (global, module, define) {
                function XorGen(seed) {
                    var me = this;
                    me.next = function () {
                        var X = me.x, i = me.i, t, v, w;
                        t = X[i];
                        t ^= t >>> 7;
                        v = t ^ t << 24;
                        t = X[i + 1 & 7];
                        v ^= t ^ t >>> 10;
                        t = X[i + 3 & 7];
                        v ^= t ^ t >>> 3;
                        t = X[i + 4 & 7];
                        v ^= t ^ t << 7;
                        t = X[i + 7 & 7];
                        t = t ^ t << 13;
                        v ^= t ^ t << 9;
                        X[i] = v;
                        me.i = i + 1 & 7;
                        return v
                    };

                    function init(me, seed) {
                        var j, w, X = [];
                        if (seed === (seed | 0)) {
                            w = X[0] = seed
                        } else {
                            seed = "" + seed;
                            for (j = 0; j < seed.length; ++j) {
                                X[j & 7] = X[j & 7] << 15 ^ seed.charCodeAt(j) + X[j + 1 & 7] << 13
                            }
                        }
                        while (X.length < 8) X.push(0);
                        for (j = 0; j < 8 && X[j] === 0; ++j) ;
                        if (j == 8) w = X[7] = -1; else w = X[j];
                        me.x = X;
                        me.i = 0;
                        for (j = 256; j > 0; --j) {
                            me.next()
                        }
                    }

                    init(me, seed)
                }

                function copy(f, t) {
                    t.x = f.x.slice();
                    t.i = f.i;
                    return t
                }

                function impl(seed, opts) {
                    if (seed == null) seed = +new Date;
                    var xg = new XorGen(seed), state = opts && opts.state, prng = function () {
                        return (xg.next() >>> 0) / 4294967296
                    };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296,
                                result = (top + bot) / (1 << 21)
                        } while (result === 0);
                        return result
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (state.x) copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {})
                        }
                    }
                    return prng
                }

                if (module && module.exports) {
                    module.exports = impl
                } else if (define && define.amd) {
                    define(function () {
                        return impl
                    })
                } else {
                    this.xorshift7 = impl
                }
            })(this, typeof module == "object" && module, typeof define == "function" && define)
        }, {}],
        218: [function (require, module, exports) {
            (function (global, module, define) {
                function XorGen(seed) {
                    var me = this, strseed = "";
                    me.next = function () {
                        var t = me.x ^ me.x >>> 2;
                        me.x = me.y;
                        me.y = me.z;
                        me.z = me.w;
                        me.w = me.v;
                        return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0
                    };
                    me.x = 0;
                    me.y = 0;
                    me.z = 0;
                    me.w = 0;
                    me.v = 0;
                    if (seed === (seed | 0)) {
                        me.x = seed
                    } else {
                        strseed += seed
                    }
                    for (var k = 0; k < strseed.length + 64; k++) {
                        me.x ^= strseed.charCodeAt(k) | 0;
                        if (k == strseed.length) {
                            me.d = me.x << 10 ^ me.x >>> 4
                        }
                        me.next()
                    }
                }

                function copy(f, t) {
                    t.x = f.x;
                    t.y = f.y;
                    t.z = f.z;
                    t.w = f.w;
                    t.v = f.v;
                    t.d = f.d;
                    return t
                }

                function impl(seed, opts) {
                    var xg = new XorGen(seed), state = opts && opts.state, prng = function () {
                        return (xg.next() >>> 0) / 4294967296
                    };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296,
                                result = (top + bot) / (1 << 21)
                        } while (result === 0);
                        return result
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (typeof state == "object") copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {})
                        }
                    }
                    return prng
                }

                if (module && module.exports) {
                    module.exports = impl
                } else if (define && define.amd) {
                    define(function () {
                        return impl
                    })
                } else {
                    this.xorwow = impl
                }
            })(this, typeof module == "object" && module, typeof define == "function" && define)
        }, {}],
        219: [function (require, module, exports) {
            (function (pool, math) {
                var global = this, width = 256, chunks = 6, digits = 52, rngname = "random",
                    startdenom = math.pow(width, chunks), significance = math.pow(2, digits),
                    overflow = significance * 2, mask = width - 1, nodecrypto;

                function seedrandom(seed, options, callback) {
                    var key = [];
                    options = options == true ? {entropy: true} : options || {};
                    var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed, 3), key);
                    var arc4 = new ARC4(key);
                    var prng = function () {
                        var n = arc4.g(chunks), d = startdenom, x = 0;
                        while (n < significance) {
                            n = (n + x) * width;
                            d *= width;
                            x = arc4.g(1)
                        }
                        while (n >= overflow) {
                            n /= 2;
                            d /= 2;
                            x >>>= 1
                        }
                        return (n + x) / d
                    };
                    prng.int32 = function () {
                        return arc4.g(4) | 0
                    };
                    prng.quick = function () {
                        return arc4.g(4) / 4294967296
                    };
                    prng.double = prng;
                    mixkey(tostring(arc4.S), pool);
                    return (options.pass || callback || function (prng, seed, is_math_call, state) {
                        if (state) {
                            if (state.S) {
                                copy(state, arc4)
                            }
                            prng.state = function () {
                                return copy(arc4, {})
                            }
                        }
                        if (is_math_call) {
                            math[rngname] = prng;
                            return seed
                        } else return prng
                    })(prng, shortseed, "global" in options ? options.global : this == math, options.state)
                }

                math["seed" + rngname] = seedrandom;

                function ARC4(key) {
                    var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
                    if (!keylen) {
                        key = [keylen++]
                    }
                    while (i < width) {
                        s[i] = i++
                    }
                    for (i = 0; i < width; i++) {
                        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
                        s[j] = t
                    }
                    (me.g = function (count) {
                        var t, r = 0, i = me.i, j = me.j, s = me.S;
                        while (count--) {
                            t = s[i = mask & i + 1];
                            r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)]
                        }
                        me.i = i;
                        me.j = j;
                        return r
                    })(width)
                }

                function copy(f, t) {
                    t.i = f.i;
                    t.j = f.j;
                    t.S = f.S.slice();
                    return t
                }

                function flatten(obj, depth) {
                    var result = [], typ = typeof obj, prop;
                    if (depth && typ == "object") {
                        for (prop in obj) {
                            try {
                                result.push(flatten(obj[prop], depth - 1))
                            } catch (e) {
                            }
                        }
                    }
                    return result.length ? result : typ == "string" ? obj : obj + "\0"
                }

                function mixkey(seed, key) {
                    var stringseed = seed + "", smear, j = 0;
                    while (j < stringseed.length) {
                        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++)
                    }
                    return tostring(key)
                }

                function autoseed() {
                    try {
                        var out;
                        if (nodecrypto && (out = nodecrypto.randomBytes)) {
                            out = out(width)
                        } else {
                            out = new Uint8Array(width);
                            (global.crypto || global.msCrypto).getRandomValues(out)
                        }
                        return tostring(out)
                    } catch (e) {
                        var browser = global.navigator, plugins = browser && browser.plugins;
                        return [+new Date, global, plugins, global.screen, tostring(pool)]
                    }
                }

                function tostring(a) {
                    return String.fromCharCode.apply(0, a)
                }

                mixkey(math.random(), pool);
                if (typeof module == "object" && module.exports) {
                    module.exports = seedrandom;
                    try {
                        nodecrypto = require("crypto")
                    } catch (ex) {
                    }
                } else if (typeof define == "function" && define.amd) {
                    define(function () {
                        return seedrandom
                    })
                }
            })([], Math)
        }, {crypto: 195}],
        220: [function (require, module, exports) {
            "use strict";
            var punycode = require("punycode");
            var util = require("./util");
            exports.parse = urlParse;
            exports.resolve = urlResolve;
            exports.resolveObject = urlResolveObject;
            exports.format = urlFormat;
            exports.Url = Url;

            function Url() {
                this.protocol = null;
                this.slashes = null;
                this.auth = null;
                this.host = null;
                this.port = null;
                this.hostname = null;
                this.hash = null;
                this.search = null;
                this.query = null;
                this.pathname = null;
                this.path = null;
                this.href = null
            }

            var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/,
                simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
                delims = ["<", ">", '"', "`", " ", "\r", "\n", "\t"],
                unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise),
                nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"],
                hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
                hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
                unsafeProtocol = {javascript: true, "javascript:": true},
                hostlessProtocol = {javascript: true, "javascript:": true}, slashedProtocol = {
                    http: true,
                    https: true,
                    ftp: true,
                    gopher: true,
                    file: true,
                    "http:": true,
                    "https:": true,
                    "ftp:": true,
                    "gopher:": true,
                    "file:": true
                }, querystring = require("querystring");

            function urlParse(url, parseQueryString, slashesDenoteHost) {
                if (url && util.isObject(url) && url instanceof Url) return url;
                var u = new Url;
                u.parse(url, parseQueryString, slashesDenoteHost);
                return u
            }

            Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
                if (!util.isString(url)) {
                    throw new TypeError("Parameter 'url' must be a string, not " + typeof url)
                }
                var queryIndex = url.indexOf("?"),
                    splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#",
                    uSplit = url.split(splitter), slashRegex = /\\/g;
                uSplit[0] = uSplit[0].replace(slashRegex, "/");
                url = uSplit.join(splitter);
                var rest = url;
                rest = rest.trim();
                if (!slashesDenoteHost && url.split("#").length === 1) {
                    var simplePath = simplePathPattern.exec(rest);
                    if (simplePath) {
                        this.path = rest;
                        this.href = rest;
                        this.pathname = simplePath[1];
                        if (simplePath[2]) {
                            this.search = simplePath[2];
                            if (parseQueryString) {
                                this.query = querystring.parse(this.search.substr(1))
                            } else {
                                this.query = this.search.substr(1)
                            }
                        } else if (parseQueryString) {
                            this.search = "";
                            this.query = {}
                        }
                        return this
                    }
                }
                var proto = protocolPattern.exec(rest);
                if (proto) {
                    proto = proto[0];
                    var lowerProto = proto.toLowerCase();
                    this.protocol = lowerProto;
                    rest = rest.substr(proto.length)
                }
                if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                    var slashes = rest.substr(0, 2) === "//";
                    if (slashes && !(proto && hostlessProtocol[proto])) {
                        rest = rest.substr(2);
                        this.slashes = true
                    }
                }
                if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                    var hostEnd = -1;
                    for (var i = 0; i < hostEndingChars.length; i++) {
                        var hec = rest.indexOf(hostEndingChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec
                    }
                    var auth, atSign;
                    if (hostEnd === -1) {
                        atSign = rest.lastIndexOf("@")
                    } else {
                        atSign = rest.lastIndexOf("@", hostEnd)
                    }
                    if (atSign !== -1) {
                        auth = rest.slice(0, atSign);
                        rest = rest.slice(atSign + 1);
                        this.auth = decodeURIComponent(auth)
                    }
                    hostEnd = -1;
                    for (var i = 0; i < nonHostChars.length; i++) {
                        var hec = rest.indexOf(nonHostChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec
                    }
                    if (hostEnd === -1) hostEnd = rest.length;
                    this.host = rest.slice(0, hostEnd);
                    rest = rest.slice(hostEnd);
                    this.parseHost();
                    this.hostname = this.hostname || "";
                    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                    if (!ipv6Hostname) {
                        var hostparts = this.hostname.split(/\./);
                        for (var i = 0, l = hostparts.length; i < l; i++) {
                            var part = hostparts[i];
                            if (!part) continue;
                            if (!part.match(hostnamePartPattern)) {
                                var newpart = "";
                                for (var j = 0, k = part.length; j < k; j++) {
                                    if (part.charCodeAt(j) > 127) {
                                        newpart += "x"
                                    } else {
                                        newpart += part[j]
                                    }
                                }
                                if (!newpart.match(hostnamePartPattern)) {
                                    var validParts = hostparts.slice(0, i);
                                    var notHost = hostparts.slice(i + 1);
                                    var bit = part.match(hostnamePartStart);
                                    if (bit) {
                                        validParts.push(bit[1]);
                                        notHost.unshift(bit[2])
                                    }
                                    if (notHost.length) {
                                        rest = "/" + notHost.join(".") + rest
                                    }
                                    this.hostname = validParts.join(".");
                                    break
                                }
                            }
                        }
                    }
                    if (this.hostname.length > hostnameMaxLen) {
                        this.hostname = ""
                    } else {
                        this.hostname = this.hostname.toLowerCase()
                    }
                    if (!ipv6Hostname) {
                        this.hostname = punycode.toASCII(this.hostname)
                    }
                    var p = this.port ? ":" + this.port : "";
                    var h = this.hostname || "";
                    this.host = h + p;
                    this.href += this.host;
                    if (ipv6Hostname) {
                        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                        if (rest[0] !== "/") {
                            rest = "/" + rest
                        }
                    }
                }
                if (!unsafeProtocol[lowerProto]) {
                    for (var i = 0, l = autoEscape.length; i < l; i++) {
                        var ae = autoEscape[i];
                        if (rest.indexOf(ae) === -1) continue;
                        var esc = encodeURIComponent(ae);
                        if (esc === ae) {
                            esc = escape(ae)
                        }
                        rest = rest.split(ae).join(esc)
                    }
                }
                var hash = rest.indexOf("#");
                if (hash !== -1) {
                    this.hash = rest.substr(hash);
                    rest = rest.slice(0, hash)
                }
                var qm = rest.indexOf("?");
                if (qm !== -1) {
                    this.search = rest.substr(qm);
                    this.query = rest.substr(qm + 1);
                    if (parseQueryString) {
                        this.query = querystring.parse(this.query)
                    }
                    rest = rest.slice(0, qm)
                } else if (parseQueryString) {
                    this.search = "";
                    this.query = {}
                }
                if (rest) this.pathname = rest;
                if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                    this.pathname = "/"
                }
                if (this.pathname || this.search) {
                    var p = this.pathname || "";
                    var s = this.search || "";
                    this.path = p + s
                }
                this.href = this.format();
                return this
            };

            function urlFormat(obj) {
                if (util.isString(obj)) obj = urlParse(obj);
                if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
                return obj.format()
            }

            Url.prototype.format = function () {
                var auth = this.auth || "";
                if (auth) {
                    auth = encodeURIComponent(auth);
                    auth = auth.replace(/%3A/i, ":");
                    auth += "@"
                }
                var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "",
                    host = false, query = "";
                if (this.host) {
                    host = auth + this.host
                } else if (this.hostname) {
                    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
                    if (this.port) {
                        host += ":" + this.port
                    }
                }
                if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
                    query = querystring.stringify(this.query)
                }
                var search = this.search || query && "?" + query || "";
                if (protocol && protocol.substr(-1) !== ":") protocol += ":";
                if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
                    host = "//" + (host || "");
                    if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname
                } else if (!host) {
                    host = ""
                }
                if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
                if (search && search.charAt(0) !== "?") search = "?" + search;
                pathname = pathname.replace(/[?#]/g, function (match) {
                    return encodeURIComponent(match)
                });
                search = search.replace("#", "%23");
                return protocol + host + pathname + search + hash
            };

            function urlResolve(source, relative) {
                return urlParse(source, false, true).resolve(relative)
            }

            Url.prototype.resolve = function (relative) {
                return this.resolveObject(urlParse(relative, false, true)).format()
            };

            function urlResolveObject(source, relative) {
                if (!source) return relative;
                return urlParse(source, false, true).resolveObject(relative)
            }

            Url.prototype.resolveObject = function (relative) {
                if (util.isString(relative)) {
                    var rel = new Url;
                    rel.parse(relative, false, true);
                    relative = rel
                }
                var result = new Url;
                var tkeys = Object.keys(this);
                for (var tk = 0; tk < tkeys.length; tk++) {
                    var tkey = tkeys[tk];
                    result[tkey] = this[tkey]
                }
                result.hash = relative.hash;
                if (relative.href === "") {
                    result.href = result.format();
                    return result
                }
                if (relative.slashes && !relative.protocol) {
                    var rkeys = Object.keys(relative);
                    for (var rk = 0; rk < rkeys.length; rk++) {
                        var rkey = rkeys[rk];
                        if (rkey !== "protocol") result[rkey] = relative[rkey]
                    }
                    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                        result.path = result.pathname = "/"
                    }
                    result.href = result.format();
                    return result
                }
                if (relative.protocol && relative.protocol !== result.protocol) {
                    if (!slashedProtocol[relative.protocol]) {
                        var keys = Object.keys(relative);
                        for (var v = 0; v < keys.length; v++) {
                            var k = keys[v];
                            result[k] = relative[k]
                        }
                        result.href = result.format();
                        return result
                    }
                    result.protocol = relative.protocol;
                    if (!relative.host && !hostlessProtocol[relative.protocol]) {
                        var relPath = (relative.pathname || "").split("/");
                        while (relPath.length && !(relative.host = relPath.shift())) ;
                        if (!relative.host) relative.host = "";
                        if (!relative.hostname) relative.hostname = "";
                        if (relPath[0] !== "") relPath.unshift("");
                        if (relPath.length < 2) relPath.unshift("");
                        result.pathname = relPath.join("/")
                    } else {
                        result.pathname = relative.pathname
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    result.host = relative.host || "";
                    result.auth = relative.auth;
                    result.hostname = relative.hostname || relative.host;
                    result.port = relative.port;
                    if (result.pathname || result.search) {
                        var p = result.pathname || "";
                        var s = result.search || "";
                        result.path = p + s
                    }
                    result.slashes = result.slashes || relative.slashes;
                    result.href = result.format();
                    return result
                }
                var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/",
                    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/",
                    mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
                    removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [],
                    relPath = relative.pathname && relative.pathname.split("/") || [],
                    psychotic = result.protocol && !slashedProtocol[result.protocol];
                if (psychotic) {
                    result.hostname = "";
                    result.port = null;
                    if (result.host) {
                        if (srcPath[0] === "") srcPath[0] = result.host; else srcPath.unshift(result.host)
                    }
                    result.host = "";
                    if (relative.protocol) {
                        relative.hostname = null;
                        relative.port = null;
                        if (relative.host) {
                            if (relPath[0] === "") relPath[0] = relative.host; else relPath.unshift(relative.host)
                        }
                        relative.host = null
                    }
                    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "")
                }
                if (isRelAbs) {
                    result.host = relative.host || relative.host === "" ? relative.host : result.host;
                    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
                    result.search = relative.search;
                    result.query = relative.query;
                    srcPath = relPath
                } else if (relPath.length) {
                    if (!srcPath) srcPath = [];
                    srcPath.pop();
                    srcPath = srcPath.concat(relPath);
                    result.search = relative.search;
                    result.query = relative.query
                } else if (!util.isNullOrUndefined(relative.search)) {
                    if (psychotic) {
                        result.hostname = result.host = srcPath.shift();
                        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                        if (authInHost) {
                            result.auth = authInHost.shift();
                            result.host = result.hostname = authInHost.shift()
                        }
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")
                    }
                    result.href = result.format();
                    return result
                }
                if (!srcPath.length) {
                    result.pathname = null;
                    if (result.search) {
                        result.path = "/" + result.search
                    } else {
                        result.path = null
                    }
                    result.href = result.format();
                    return result
                }
                var last = srcPath.slice(-1)[0];
                var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
                var up = 0;
                for (var i = srcPath.length; i >= 0; i--) {
                    last = srcPath[i];
                    if (last === ".") {
                        srcPath.splice(i, 1)
                    } else if (last === "..") {
                        srcPath.splice(i, 1);
                        up++
                    } else if (up) {
                        srcPath.splice(i, 1);
                        up--
                    }
                }
                if (!mustEndAbs && !removeAllDots) {
                    for (; up--; up) {
                        srcPath.unshift("..")
                    }
                }
                if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
                    srcPath.unshift("")
                }
                if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                    srcPath.push("")
                }
                var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
                if (psychotic) {
                    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift()
                    }
                }
                mustEndAbs = mustEndAbs || result.host && srcPath.length;
                if (mustEndAbs && !isAbsolute) {
                    srcPath.unshift("")
                }
                if (!srcPath.length) {
                    result.pathname = null;
                    result.path = null
                } else {
                    result.pathname = srcPath.join("/")
                }
                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")
                }
                result.auth = relative.auth || result.auth;
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result
            };
            Url.prototype.parseHost = function () {
                var host = this.host;
                var port = portPattern.exec(host);
                if (port) {
                    port = port[0];
                    if (port !== ":") {
                        this.port = port.substr(1)
                    }
                    host = host.substr(0, host.length - port.length)
                }
                if (host) this.hostname = host
            }
        }, {"./util": 221, punycode: 208, querystring: 211}],
        221: [function (require, module, exports) {
            "use strict";
            module.exports = {
                isString: function (arg) {
                    return typeof arg === "string"
                }, isObject: function (arg) {
                    return typeof arg === "object" && arg !== null
                }, isNull: function (arg) {
                    return arg === null
                }, isNullOrUndefined: function (arg) {
                    return arg == null
                }
            }
        }, {}],
        222: [function (require, module, exports) {
            var v1 = require("./v1");
            var v4 = require("./v4");
            var uuid = v4;
            uuid.v1 = v1;
            uuid.v4 = v4;
            module.exports = uuid
        }, {"./v1": 225, "./v4": 226}],
        223: [function (require, module, exports) {
            var byteToHex = [];
            for (var i = 0; i < 256; ++i) {
                byteToHex[i] = (i + 256).toString(16).substr(1)
            }

            function bytesToUuid(buf, offset) {
                var i = offset || 0;
                var bth = byteToHex;
                return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]]
            }

            module.exports = bytesToUuid
        }, {}],
        224: [function (require, module, exports) {
            var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && msCrypto.getRandomValues.bind(msCrypto);
            if (getRandomValues) {
                var rnds8 = new Uint8Array(16);
                module.exports = function whatwgRNG() {
                    getRandomValues(rnds8);
                    return rnds8
                }
            } else {
                var rnds = new Array(16);
                module.exports = function mathRNG() {
                    for (var i = 0, r; i < 16; i++) {
                        if ((i & 3) === 0) r = Math.random() * 4294967296;
                        rnds[i] = r >>> ((i & 3) << 3) & 255
                    }
                    return rnds
                }
            }
        }, {}],
        225: [function (require, module, exports) {
            var rng = require("./lib/rng");
            var bytesToUuid = require("./lib/bytesToUuid");
            var _nodeId;
            var _clockseq;
            var _lastMSecs = 0;
            var _lastNSecs = 0;

            function v1(options, buf, offset) {
                var i = buf && offset || 0;
                var b = buf || [];
                options = options || {};
                var node = options.node || _nodeId;
                var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
                if (node == null || clockseq == null) {
                    var seedBytes = rng();
                    if (node == null) {
                        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]]
                    }
                    if (clockseq == null) {
                        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383
                    }
                }
                var msecs = options.msecs !== undefined ? options.msecs : (new Date).getTime();
                var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
                var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
                if (dt < 0 && options.clockseq === undefined) {
                    clockseq = clockseq + 1 & 16383
                }
                if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
                    nsecs = 0
                }
                if (nsecs >= 1e4) {
                    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
                }
                _lastMSecs = msecs;
                _lastNSecs = nsecs;
                _clockseq = clockseq;
                msecs += 122192928e5;
                var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
                b[i++] = tl >>> 24 & 255;
                b[i++] = tl >>> 16 & 255;
                b[i++] = tl >>> 8 & 255;
                b[i++] = tl & 255;
                var tmh = msecs / 4294967296 * 1e4 & 268435455;
                b[i++] = tmh >>> 8 & 255;
                b[i++] = tmh & 255;
                b[i++] = tmh >>> 24 & 15 | 16;
                b[i++] = tmh >>> 16 & 255;
                b[i++] = clockseq >>> 8 | 128;
                b[i++] = clockseq & 255;
                for (var n = 0; n < 6; ++n) {
                    b[i + n] = node[n]
                }
                return buf ? buf : bytesToUuid(b)
            }

            module.exports = v1
        }, {"./lib/bytesToUuid": 223, "./lib/rng": 224}],
        226: [function (require, module, exports) {
            var rng = require("./lib/rng");
            var bytesToUuid = require("./lib/bytesToUuid");

            function v4(options, buf, offset) {
                var i = buf && offset || 0;
                if (typeof options == "string") {
                    buf = options === "binary" ? new Array(16) : null;
                    options = null
                }
                options = options || {};
                var rnds = options.random || (options.rng || rng)();
                rnds[6] = rnds[6] & 15 | 64;
                rnds[8] = rnds[8] & 63 | 128;
                if (buf) {
                    for (var ii = 0; ii < 16; ++ii) {
                        buf[i + ii] = rnds[ii]
                    }
                }
                return buf || bytesToUuid(rnds)
            }

            module.exports = v4
        }, {"./lib/bytesToUuid": 223, "./lib/rng": 224}],
        227: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var model_1 = require("./reimprove/model");
            exports.Model = model_1.Model;
            exports.LayerType = model_1.LayerType;
            var academy_1 = require("./reimprove/academy");
            exports.Academy = academy_1.Academy;
            var networks_1 = require("./reimprove/networks");
            exports.NeuralNetwork = networks_1.NeuralNetwork;
            exports.ConvolutionalNeuralNetwork = networks_1.ConvolutionalNeuralNetwork;
            var tfjs_1 = require("@tensorflow/tfjs");
            exports.setBackend = tfjs_1.setBackend
        }, {
            "./reimprove/academy": 228,
            "./reimprove/model": 233,
            "./reimprove/networks": 234,
            "@tensorflow/tfjs": 193
        }],
        228: [function (require, module, exports) {
            "use strict";
            var __assign = this && this.__assign || Object.assign || function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var agent_1 = require("./agent");
            var teacher_1 = require("./teacher");
            var uuid_1 = require("uuid");
            var learning_data_logger_1 = require("./misc/learning_data_logger");
            var DEFAULT_ACADEMY_CONFIG = {parentLogsElement: null, agentsLogs: false, memoryLogs: false};
            var Academy = function () {
                function Academy(config) {
                    this.config = __assign({}, DEFAULT_ACADEMY_CONFIG, config);
                    this.agents = new Map;
                    this.teachers = new Map;
                    this.assigments = new Map;
                    if (this.config.parentLogsElement) {
                        this.createLogger(this.config.parentLogsElement)
                    }
                }

                Academy.prototype.addAgent = function (config, name) {
                    var agent = new agent_1.Agent(config.model, config.agentConfig, name);
                    if (!agent.Name) agent.Name = uuid_1.v4();
                    this.agents.set(agent.Name, agent);
                    return agent.Name
                };
                Academy.prototype.addTeacher = function (config, name) {
                    var teacher = new teacher_1.Teacher(config, name);
                    if (!teacher.Name) teacher.Name = uuid_1.v4();
                    this.teachers.set(teacher.Name, teacher);
                    return teacher.Name
                };
                Academy.prototype.assignTeacherToAgent = function (agentName, teacherName) {
                    if (!this.agents.has(agentName)) throw new Error("No such agent has been registered");
                    if (!this.teachers.has(teacherName)) throw new Error("No such teacher has been registered");
                    this.assigments.set(agentName, teacherName);
                    this.teachers.get(teacherName).affectStudent(this.agents.get(agentName))
                };
                Academy.prototype.step = function (inputs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var actions, finalInput, _i, finalInput_1, input, agentsActions;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    actions = new Map;
                                    finalInput = inputs instanceof Array ? inputs : [inputs];
                                    _i = 0, finalInput_1 = finalInput;
                                    _a.label = 1;
                                case 1:
                                    if (!(_i < finalInput_1.length)) return [3, 4];
                                    input = finalInput_1[_i];
                                    if (!this.teachers.has(input.teacherName)) {
                                        throw new Error("No teacher has name " + input.teacherName)
                                    }
                                    return [4, this.teachers.get(input.teacherName).teach(input.agentsInput)];
                                case 2:
                                    agentsActions = _a.sent();
                                    agentsActions.forEach(function (value, key) {
                                        if (actions.has(key)) throw new Error("Agent " + key + " has already registered an action.");
                                        actions.set(key, value)
                                    });
                                    _a.label = 3;
                                case 3:
                                    _i++;
                                    return [3, 1];
                                case 4:
                                    if (this.logger) this.logger.updateTables(true);
                                    return [2, actions]
                            }
                        })
                    })
                };
                Academy.prototype.addRewardToAgent = function (name, reward) {
                    if (this.agents.has(name)) this.agents.get(name).addReward(reward)
                };
                Academy.prototype.setRewardOfAgent = function (name, reward) {
                    if (this.agents.has(name)) this.agents.get(name).setReward(reward)
                };
                Academy.prototype.OnLearningLessonEnded = function (teacherName, callback) {
                    if (this.teachers.has(teacherName)) this.teachers.get(teacherName).onLearningLessonEnded = callback
                };
                Academy.prototype.OnLessonEnded = function (teacherName, callback) {
                    if (this.teachers.has(teacherName)) this.teachers.get(teacherName).onLessonEnded = callback
                };
                Academy.prototype.OnTeachingEnded = function (teacherName, callback) {
                    if (this.teachers.has(teacherName)) this.teachers.get(teacherName).onTeachingEnded = callback
                };
                Academy.prototype.resetTeachersAndAgents = function () {
                    this.teachers.forEach(function (t) {
                        return t.reset()
                    });
                    this.agents.forEach(function (a) {
                        return a.reset()
                    })
                };
                Academy.prototype.reset = function () {
                    this.resetTeachersAndAgents();
                    this.teachers.clear();
                    this.agents.clear()
                };
                Academy.prototype.resetTeacherLesson = function (teacherName) {
                    this.teachers.get(teacherName).resetLesson()
                };
                Object.defineProperty(Academy.prototype, "Teachers", {
                    get: function () {
                        return Array.from(this.teachers.keys())
                    }, enumerable: true, configurable: true
                });
                Academy.prototype.getTeacherData = function (name) {
                    return this.teachers.get(name).getData()
                };
                Academy.prototype.createLogger = function (parent) {
                    if (this.logger) this.logger.dispose();
                    this.config.parentLogsElement = parent;
                    this.logger = new learning_data_logger_1.LearningDataLogger(parent, this)
                };
                Academy.prototype.toggleLogs = function (memory) {
                    if (memory === void 0) {
                        memory = false
                    }
                    var status = this.config.agentsLogs;
                    this.config.agentsLogs = !status;
                    if (status) this.config.memoryLogs = memory
                };
                return Academy
            }();
            exports.Academy = Academy
        }, {"./agent": 229, "./misc/learning_data_logger": 231, "./teacher": 235, uuid: 222}],
        229: [function (require, module, exports) {
            "use strict";
            var __assign = this && this.__assign || Object.assign || function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var memory_1 = require("./memory");
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var lodash_1 = require("lodash");
            var typed_window_1 = require("./misc/typed_window");
            var MEM_WINDOW_MIN_SIZE = 2;
            var HIST_WINDOW_SIZE = 100;
            var HIST_WINDOW_MIN_SIZE = 0;
            var DEFAULT_AGENT_CONFIG = {memorySize: 3e4, batchSize: 32, temporalWindow: 1};
            var Agent = function () {
                function Agent(model, agentConfig, name) {
                    this.model = model;
                    this.name = name;
                    this.agentConfig = __assign({}, DEFAULT_AGENT_CONFIG, agentConfig);
                    this.done = false;
                    this.currentReward = 0;
                    this.lossesHistory = new typed_window_1.TypedWindow(HIST_WINDOW_SIZE, HIST_WINDOW_MIN_SIZE, -1);
                    this.rewardsHistory = new typed_window_1.TypedWindow(HIST_WINDOW_SIZE, HIST_WINDOW_MIN_SIZE, null);
                    this.memory = new memory_1.Memory({size: this.agentConfig.memorySize});
                    this.netInputWindowSize = Math.max(this.agentConfig.temporalWindow, MEM_WINDOW_MIN_SIZE);
                    this.actionsBuffer = new Array(this.netInputWindowSize);
                    this.inputsBuffer = new Array(this.netInputWindowSize);
                    this.statesBuffer = new Array(this.netInputWindowSize);
                    this.forwardPasses = 0
                }

                Agent.prototype.createNeuralNetInput = function (input) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var finalInput = input.clone();
                        var _loop_1 = function (i) {
                            finalInput = finalInput.concat(_this.statesBuffer[_this.netInputWindowSize - 1 - i], 1);
                            var ten = tfjs_core_1.tensor([lodash_1.range(0, _this.model.OutputSize).map(function (val) {
                                return val == _this.actionsBuffer[_this.netInputWindowSize - 1 - i] ? 1 : 0
                            })]);
                            finalInput = finalInput.concat(ten, 1)
                        };
                        for (var i = 0; i < _this.agentConfig.temporalWindow; ++i) {
                            _loop_1(i)
                        }
                        return finalInput
                    })
                };
                Agent.prototype.policy = function (input) {
                    return this.model.predict(input).getAction()
                };
                Agent.prototype.forward = function (input, epsilon, keepTensors) {
                    if (keepTensors === void 0) {
                        keepTensors = true
                    }
                    this.forwardPasses += 1;
                    var action;
                    var netInput;
                    var tensorInput = tfjs_core_1.tensor2d(input, [1, input.length]);
                    if (this.forwardPasses > this.agentConfig.temporalWindow) {
                        netInput = this.createNeuralNetInput(tensorInput);
                        if (lodash_1.random(0, 1, true) < epsilon) {
                            action = this.model.randomOutput()
                        } else {
                            action = this.policy(netInput)
                        }
                    } else {
                        action = this.model.randomOutput();
                        netInput = tfjs_core_1.tensor([])
                    }
                    if (keepTensors) {
                        this.actionsBuffer.shift();
                        var stateShift = this.statesBuffer.shift();
                        if (stateShift) stateShift.dispose();
                        this.inputsBuffer.shift();
                        this.actionsBuffer.push(action);
                        this.statesBuffer.push(tensorInput);
                        this.inputsBuffer.push({tensor: netInput, references: 0})
                    } else {
                        tensorInput.dispose();
                        netInput.dispose()
                    }
                    return action
                };
                Agent.prototype.memorize = function () {
                    this.rewardsHistory.add(this.currentReward);
                    if (this.forwardPasses <= this.agentConfig.temporalWindow + 1) return;
                    this.memory.remember({
                        action: this.actionsBuffer[this.netInputWindowSize - MEM_WINDOW_MIN_SIZE],
                        reward: this.currentReward,
                        state: this.inputsBuffer[this.netInputWindowSize - MEM_WINDOW_MIN_SIZE],
                        nextState: this.inputsBuffer[this.netInputWindowSize - 1]
                    })
                };
                Agent.prototype.createTrainingDataFromMemento = function (memento, gamma) {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        var target = memento.reward;
                        if (!_this.done) {
                            target = memento.reward + gamma * _this.model.predict(memento.nextState.tensor).getHighestValue()
                        }
                        var future_target = _this.model.predict(memento.state.tensor).getValue();
                        future_target[memento.action] = target;
                        return {
                            x: memento.state.tensor.clone(),
                            y: tfjs_core_1.tensor2d(future_target, [1, _this.model.OutputSize])
                        }
                    })
                };
                Agent.prototype.listen = function (input, epsilon) {
                    var action = this.forward(input, epsilon, true);
                    this.memorize();
                    this.setReward(0);
                    return action
                };
                Agent.prototype.learn = function (gamma) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var trainData, history, loss;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    trainData = this.memory.sample(this.agentConfig.batchSize).map(function (memento) {
                                        return _this.createTrainingDataFromMemento(memento, gamma)
                                    }).reduce(function (previousValue, currentValue) {
                                        var res = {
                                            x: previousValue.x.concat(currentValue.x),
                                            y: previousValue.y.concat(currentValue.y)
                                        };
                                        previousValue.x.dispose();
                                        previousValue.y.dispose();
                                        currentValue.x.dispose();
                                        currentValue.y.dispose();
                                        return res
                                    });
                                    return [4, this.model.fit(trainData.x, trainData.y)];
                                case 1:
                                    history = _a.sent();
                                    loss = history.history.loss[0];
                                    this.lossesHistory.add(loss);
                                    trainData.x.dispose();
                                    trainData.y.dispose();
                                    return [2]
                            }
                        })
                    })
                };
                Agent.prototype.addReward = function (value) {
                    this.currentReward += value
                };
                Agent.prototype.setReward = function (value) {
                    this.currentReward = value
                };
                Agent.prototype.reset = function () {
                    this.memory.reset();
                    this.inputsBuffer.forEach(function (i) {
                        return i.tensor.dispose()
                    });
                    this.statesBuffer.forEach(function (s) {
                        return s.dispose()
                    });
                    this.forwardPasses = 0
                };
                Object.defineProperty(Agent.prototype, "Config", {
                    get: function () {
                        return this.agentConfig
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Agent.prototype, "Name", {
                    get: function () {
                        return this.name
                    }, set: function (name) {
                        this.name = name
                    }, enumerable: true, configurable: true
                });
                Agent.prototype.getTrackingInformation = function () {
                    return {
                        averageReward: this.rewardsHistory.mean(),
                        averageLoss: this.lossesHistory.mean(),
                        name: this.name
                    }
                };
                return Agent
            }();
            exports.Agent = Agent
        }, {"./memory": 230, "./misc/typed_window": 232, "@tensorflow/tfjs-core": 50, lodash: 196}],
        230: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var lodash_1 = require("lodash");
            var Memory = function () {
                function Memory(config) {
                    this.config = config;
                    this.memory = new Array(this.config.size);
                    this.currentSize = 0
                }

                Memory.prototype.remember = function (memento, replaceIfFull) {
                    if (replaceIfFull === void 0) {
                        replaceIfFull = true
                    }
                    memento.state.references += 1;
                    memento.nextState.references += 1;
                    if (this.currentSize < this.config.size) {
                        this.memory[this.currentSize++] = memento
                    } else if (replaceIfFull) {
                        var randPos = lodash_1.random(0, this.memory.length - 1);
                        Memory.freeMemento(this.memory[randPos]);
                        this.memory[randPos] = memento
                    }
                };
                Memory.prototype.sample = function (batchSize, unique) {
                    if (unique === void 0) {
                        unique = true
                    }
                    var memslice = this.memory.slice(0, this.currentSize);
                    if (unique) return lodash_1.sampleSize(memslice, batchSize); else return lodash_1.range(batchSize).map(function () {
                        return lodash_1.sample(memslice)
                    })
                };
                Object.defineProperty(Memory.prototype, "CurrentSize", {
                    get: function () {
                        return this.currentSize
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Memory.prototype, "Size", {
                    get: function () {
                        return this.memory.length
                    }, enumerable: true, configurable: true
                });
                Memory.freeMemento = function (memento) {
                    memento.nextState.references -= 1;
                    memento.state.references -= 1;
                    if (memento.nextState.references <= 0) memento.nextState.tensor.dispose();
                    if (memento.state.references <= 0) memento.state.tensor.dispose()
                };
                Memory.prototype.reset = function () {
                    this.memory.forEach(function (memento) {
                        memento.state.tensor.dispose();
                        memento.nextState.tensor.dispose()
                    });
                    this.memory = new Array(this.config.size);
                    this.currentSize = 0
                };
                Memory.prototype.merge = function (other) {
                    var _this = this;
                    other.memory.forEach(function (memento) {
                        return _this.remember(memento)
                    })
                };
                return Memory
            }();
            exports.Memory = Memory
        }, {lodash: 196}],
        231: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var LearningDataLogger = function () {
                function LearningDataLogger(element, academy) {
                    var _this = this;
                    this.academy = academy;
                    if (typeof element == "string") {
                        this.parent = document.getElementById(element)
                    } else {
                        this.parent = element
                    }
                    this.tables = [];
                    this.academy.Teachers.forEach(function (name) {
                        return _this.createTeacherTable(name)
                    });
                    this.tables.forEach(function (val) {
                        return _this.parent.appendChild(val.table)
                    });
                    this.createMemoryTable();
                    this.parent.appendChild(this.memory)
                }

                LearningDataLogger.prototype.createMemoryTable = function () {
                    this.memory = document.createElement("table");
                    var thead = this.memory.createTHead();
                    var tbody = this.memory.createTBody();
                    var hrow = thead.insertRow(0);
                    hrow.insertCell(0).innerHTML = "Bytes allocated (undisposed)";
                    hrow.insertCell(1).innerHTML = "Unique tensors allocated";
                    hrow.insertCell(2).innerHTML = "Data buffers allocated";
                    hrow.insertCell(3).innerHTML = "Unreliable";
                    var brow = tbody.insertRow(0);
                    brow.insertCell(0).innerHTML = "";
                    brow.insertCell(1).innerHTML = "";
                    brow.insertCell(2).innerHTML = "";
                    brow.insertCell(3).innerHTML = "";
                    LearningDataLogger.tableStyle(this.memory)
                };
                LearningDataLogger.prototype.createTeacherTable = function (teacherName) {
                    var table = document.createElement("table");
                    var thead = table.createTHead();
                    var tbody = table.createTBody();
                    var hrow = thead.insertRow(0);
                    hrow.insertCell(0).innerHTML = "Name";
                    hrow.insertCell(1).innerHTML = "Q loss average";
                    hrow.insertCell(2).innerHTML = "Average reward";
                    hrow.insertCell(3).innerHTML = "Epsilon";
                    hrow.insertCell(4).innerHTML = "Lesson number";
                    var studentsQuantity = this.academy.getTeacherData(teacherName).students.length;
                    for (var i = 0; i < studentsQuantity; ++i) {
                        var brow = tbody.insertRow(i);
                        brow.insertCell(0).innerHTML = "";
                        brow.insertCell(1).innerHTML = "";
                        brow.insertCell(2).innerHTML = "";
                        brow.insertCell(3).innerHTML = "";
                        brow.insertCell(4).innerHTML = ""
                    }
                    LearningDataLogger.tableStyle(table);
                    this.tables.push({teacherName: teacherName, table: table})
                };
                LearningDataLogger.prototype.updateTables = function (showMemory) {
                    var _this = this;
                    if (showMemory === void 0) {
                        showMemory = false
                    }
                    this.tables.forEach(function (table) {
                        var tData = _this.academy.getTeacherData(table.teacherName);
                        tData.students.forEach(function (data, index) {
                            table.table.tBodies.item(0).rows.item(index).cells.item(0).innerHTML = data.name;
                            table.table.tBodies.item(0).rows.item(index).cells.item(1).innerHTML = data.averageLoss.toString().substr(0, 5);
                            table.table.tBodies.item(0).rows.item(index).cells.item(2).innerHTML = data.averageReward.toString().substr(0, 5);
                            table.table.tBodies.item(0).rows.item(index).cells.item(3).innerHTML = tData.epsilon.toString().substr(0, 5);
                            table.table.tBodies.item(0).rows.item(index).cells.item(4).innerHTML = tData.lessonNumber.toString()
                        })
                    });
                    if (showMemory) {
                        var tfMemory = tfjs_core_1.memory();
                        this.memory.tBodies.item(0).rows.item(0).cells.item(0).innerHTML = tfMemory.numBytes.toString();
                        this.memory.tBodies.item(0).rows.item(0).cells.item(1).innerHTML = tfMemory.numTensors.toString();
                        this.memory.tBodies.item(0).rows.item(0).cells.item(2).innerHTML = tfMemory.numDataBuffers.toString();
                        this.memory.tBodies.item(0).rows.item(0).cells.item(3).innerHTML = tfMemory.unreliable.toString()
                    }
                };
                LearningDataLogger.prototype.dispose = function () {
                    var _this = this;
                    this.tables.forEach(function (table) {
                        _this.parent.removeChild(table.table)
                    })
                };
                LearningDataLogger.tableStyle = function (table) {
                    table.style.border = "medium solid #6495ed";
                    table.style.borderCollapse = "collapse";
                    table.tHead.style.fontFamily = "monospace";
                    table.tHead.style.border = "thin solid #6495ed";
                    table.tHead.style.padding = "5px";
                    table.tHead.style.backgroundColor = "#d0e3fa";
                    table.tHead.style.textAlign = "center";
                    table.tHead.style.margin = "8px";
                    for (var i = 0; i < table.tBodies.length; ++i) {
                        var item = table.tBodies.item(i);
                        item.style.fontFamily = "sans-serif";
                        item.style.border = "thin solid #6495ed";
                        item.style.padding = "5px";
                        item.style.textAlign = "center";
                        item.style.backgroundColor = "#ffffff";
                        item.style.margin = "3px"
                    }
                };
                return LearningDataLogger
            }();
            exports.LearningDataLogger = LearningDataLogger
        }, {"@tensorflow/tfjs-core": 50}],
        232: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var lodash_1 = require("lodash");
            var TypedWindow = function () {
                function TypedWindow(size, minSize, nullValue) {
                    this.size = size;
                    this.minSize = minSize;
                    this.nullValue = nullValue;
                    this.window = []
                }

                TypedWindow.prototype.add = function (value) {
                    if (value == this.nullValue) return;
                    this.window.push(value);
                    if (this.window.length > this.size) this.window.shift()
                };
                TypedWindow.prototype.mean = function () {
                    if (this.window.length < this.minSize) {
                        return -1
                    } else {
                        return lodash_1.mean(this.window)
                    }
                };
                Object.defineProperty(TypedWindow.prototype, "Window", {
                    get: function () {
                        return this.window
                    }, enumerable: true, configurable: true
                });
                return TypedWindow
            }();
            exports.TypedWindow = TypedWindow
        }, {lodash: 196}],
        233: [function (require, module, exports) {
            "use strict";
            var __assign = this && this.__assign || Object.assign || function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            var __importStar = this && this.__importStar || function (mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
                result["default"] = mod;
                return result
            };
            var __importDefault = this && this.__importDefault || function (mod) {
                return mod && mod.__esModule ? mod : {default: mod}
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tflayers = __importStar(require("@tensorflow/tfjs-layers"));
            var tfjs_core_1 = require("@tensorflow/tfjs-core");
            var lodash_1 = require("lodash");
            var v4_1 = __importDefault(require("uuid/v4"));
            var DEFAULT_MODEL_FIT_CONFIG = {epochs: 10, stepsPerEpoch: 200};
            var LayerType;
            (function (LayerType) {
                LayerType["DENSE"] = "DENSE";
                LayerType["CONV2D"] = "CONV2D";
                LayerType["FLATTEN"] = "FLATTEN"
            })(LayerType = exports.LayerType || (exports.LayerType = {}));
            var DEFAULT_LAYER_CONFIG = {units: 32, activation: "relu", useBias: false};
            var Model = function () {
                function Model(config, fitConfig) {
                    this.model = new tflayers.Sequential(config);
                    this.fitConfig = __assign({}, DEFAULT_MODEL_FIT_CONFIG, fitConfig)
                }

                Model.prototype.loadFromFile = function (file) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = this;
                                    return [4, tflayers.loadModel(file)];
                                case 1:
                                    _a.model = _b.sent();
                                    return [2]
                            }
                        })
                    })
                };
                Model.prototype.addLayer = function (type, config) {
                    if (this.model instanceof tflayers.Sequential) {
                        var conf = DEFAULT_LAYER_CONFIG;
                        if (config.inputShape) conf.inputShape = config.inputShape;
                        switch (type) {
                            case LayerType.DENSE:
                                conf.units = config.units;
                                conf.activation = config.activation;
                                this.model.add(tflayers.layers.dense(conf));
                                break;
                            case LayerType.CONV2D:
                                conf.filters = config.units;
                                conf.activation = config.activation;
                                conf.useBias = config.useBias;
                                this.model.add(tflayers.layers.conv2d(conf));
                                break;
                            case LayerType.FLATTEN:
                                conf = {};
                                this.model.add(tflayers.layers.flatten(conf));
                                break
                        }
                    } else {
                        throw new Error("Unable to add a layer to an already created model managed by tensorflowjs")
                    }
                };
                Model.prototype.compile = function (config) {
                    this.model.compile(config);
                    return this
                };
                Model.prototype.predict = function (x, config) {
                    return new Result(this.model.predict(x, config))
                };
                Model.prototype.fit = function (x, y) {
                    return this.model.fit(x, y, this.fitConfig)
                };
                Model.prototype.randomOutput = function () {
                    return lodash_1.random(0, this.OutputSize)
                };
                Object.defineProperty(Model.prototype, "OutputSize", {
                    get: function () {
                        return this.model.getOutputAt(0).shape[1]
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Model.prototype, "InputSize", {
                    get: function () {
                        return this.model.layers[0].batchInputShape[1]
                    }, enumerable: true, configurable: true
                });
                Model.FromNetwork = function (network, fitConfig, name) {
                    if (name === void 0) {
                        name = v4_1.default()
                    }
                    return new Model({name: name, layers: network.createLayers()}, fitConfig)
                };
                return Model
            }();
            exports.Model = Model;
            var Result = function () {
                function Result(result) {
                    this.result = result
                }

                Result.prototype.getResultAndDispose = function (t) {
                    this.result.dispose();
                    return t.dataSync()
                };
                Result.prototype.getHighestValue = function () {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        return _this.getResultAndDispose(_this.result.as1D().max())[0]
                    })
                };
                Result.prototype.getAction = function () {
                    var _this = this;
                    return tfjs_core_1.tidy(function () {
                        return _this.getResultAndDispose(_this.result.as1D().argMax())[0]
                    })
                };
                Result.prototype.getValue = function () {
                    var resTensor = this.result.as1D();
                    var result = resTensor.dataSync();
                    resTensor.dispose();
                    this.result.dispose();
                    return result
                };
                return Result
            }();
            exports.Result = Result
        }, {"@tensorflow/tfjs-core": 50, "@tensorflow/tfjs-layers": 167, lodash: 196, "uuid/v4": 226}],
        234: [function (require, module, exports) {
            "use strict";
            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (d, b) {
                    d.__proto__ = b
                } || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
                };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
                }
            }();
            var __assign = this && this.__assign || Object.assign || function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var tfjs_1 = require("@tensorflow/tfjs");
            var NeuralNetwork = function () {
                function NeuralNetwork() {
                    this.neuralNetworkLayers = [];
                    this.inputShape = [0]
                }

                NeuralNetwork.prototype.addNeuralNetworkLayer = function (layer) {
                    if (typeof layer == "number") {
                        this.neuralNetworkLayers.push({
                            units: layer,
                            activation: NeuralNetwork.DEFAULT_LAYER.activation,
                            type: "dense"
                        })
                    } else {
                        this.neuralNetworkLayers.push(__assign({}, NeuralNetwork.DEFAULT_LAYER, layer))
                    }
                };
                NeuralNetwork.prototype.addNeuralNetworkLayers = function (layers) {
                    var _this = this;
                    layers.forEach(function (l) {
                        return _this.addNeuralNetworkLayer(l)
                    })
                };
                Object.defineProperty(NeuralNetwork.prototype, "InputShape", {
                    set: function (shape) {
                        this.inputShape = shape
                    }, enumerable: true, configurable: true
                });
                NeuralNetwork.prototype.createLayers = function (includeInputShape) {
                    if (includeInputShape === void 0) {
                        includeInputShape = true
                    }
                    var genLayers = [];
                    if (includeInputShape) this.neuralNetworkLayers[0].inputShape = this.inputShape;
                    for (var _i = 0, _a = this.neuralNetworkLayers; _i < _a.length; _i++) {
                        var layer = _a[_i];
                        genLayers.push(layer.type == "dense" ? tfjs_1.layers.dense(layer) : tfjs_1.layers.dropout(layer))
                    }
                    return genLayers
                };
                NeuralNetwork.prototype.getLayers = function () {
                    return this.neuralNetworkLayers
                };
                NeuralNetwork.DEFAULT_LAYER = {units: 32, activation: "relu", type: "dense"};
                return NeuralNetwork
            }();
            exports.NeuralNetwork = NeuralNetwork;
            var ConvolutionalNeuralNetwork = function (_super) {
                __extends(ConvolutionalNeuralNetwork, _super);

                function ConvolutionalNeuralNetwork() {
                    var _this = _super.call(this) || this;
                    _this.convolutionalLayers = [];
                    _this.flattenLayer = {type: "flatten"};
                    return _this
                }

                ConvolutionalNeuralNetwork.prototype.addMaxPooling2DLayer = function (layer) {
                    this.convolutionalLayers.push(__assign({}, ConvolutionalNeuralNetwork.DEFAULT_POOLING_LAYER, layer))
                };
                ConvolutionalNeuralNetwork.prototype.addConvolutionalLayer = function (layer) {
                    if (typeof layer == "number") {
                        this.convolutionalLayers.push({
                            filters: layer,
                            activation: ConvolutionalNeuralNetwork.DEFAULT_CONV_LAYER.activation,
                            type: "convolutional",
                            kernelSize: ConvolutionalNeuralNetwork.DEFAULT_CONV_LAYER.kernelSize
                        })
                    } else {
                        this.convolutionalLayers.push(__assign({}, ConvolutionalNeuralNetwork.DEFAULT_CONV_LAYER, layer))
                    }
                };
                ConvolutionalNeuralNetwork.prototype.addConvolutionalLayers = function (layers) {
                    var _this = this;
                    layers.forEach(function (l) {
                        return _this.addConvolutionalLayer(l)
                    })
                };
                ConvolutionalNeuralNetwork.prototype.createLayers = function (includeInputShape) {
                    if (includeInputShape === void 0) {
                        includeInputShape = true
                    }
                    var genLayers = [];
                    this.convolutionalLayers[0].inputShape = this.inputShape;
                    for (var _i = 0, _a = this.convolutionalLayers; _i < _a.length; _i++) {
                        var layer = _a[_i];
                        genLayers.push(layer.type == "convolutional" ? tfjs_1.layers.conv2d(layer) : tfjs_1.layers.maxPooling2d(layer))
                    }
                    genLayers.push(tfjs_1.layers.flatten(this.flattenLayer));
                    return genLayers.concat(_super.prototype.createLayers.call(this, false))
                };
                Object.defineProperty(ConvolutionalNeuralNetwork.prototype, "FlattenLayer", {
                    set: function (layer) {
                        this.flattenLayer = layer
                    }, enumerable: true, configurable: true
                });
                ConvolutionalNeuralNetwork.prototype.getLayers = function () {
                    return this.convolutionalLayers.concat(this.flattenLayer, _super.prototype.getLayers.call(this))
                };
                ConvolutionalNeuralNetwork.DEFAULT_CONV_LAYER = {
                    filters: 32,
                    kernelSize: 3,
                    activation: "relu",
                    type: "convolutional"
                };
                ConvolutionalNeuralNetwork.DEFAULT_POOLING_LAYER = {poolSize: 2, strides: null, type: "maxpooling"};
                return ConvolutionalNeuralNetwork
            }(NeuralNetwork);
            exports.ConvolutionalNeuralNetwork = ConvolutionalNeuralNetwork
        }, {"@tensorflow/tfjs": 193}],
        235: [function (require, module, exports) {
            "use strict";
            var __assign = this && this.__assign || Object.assign || function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
                }
                return t
            };
            var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value))
                        } catch (e) {
                            reject(e)
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value)
                        }).then(fulfilled, rejected)
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next())
                })
            };
            var __generator = this && this.__generator || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1]
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v])
                    }
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue
                                }
                                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                    _.label = op[1];
                                    break
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue
                        }
                        op = body.call(thisArg, _)
                    } catch (e) {
                        op = [6, e];
                        y = 0
                    } finally {
                        f = t = 0
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true}
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var DEFAULT_TEACHING_CONFIG = {
                lessonLength: 1e3,
                lessonsQuantity: 30,
                lessonsWithRandom: 2,
                epsilon: 1,
                epsilonMin: .05,
                epsilonDecay: .95,
                gamma: .9
            };
            var TeachingState;
            (function (TeachingState) {
                TeachingState[TeachingState["EXPERIENCING"] = 0] = "EXPERIENCING";
                TeachingState[TeachingState["LEARNING"] = 1] = "LEARNING";
                TeachingState[TeachingState["TESTING"] = 2] = "TESTING";
                TeachingState[TeachingState["NONE"] = -1] = "NONE";
                TeachingState[TeachingState["STOPPED"] = -2] = "STOPPED"
            })(TeachingState = exports.TeachingState || (exports.TeachingState = {}));
            var Teacher = function () {
                function Teacher(config, name) {
                    this.config = __assign({}, DEFAULT_TEACHING_CONFIG, config);
                    this.agents = new Set;
                    this.currentLessonLength = 0;
                    this.lessonsTaught = 0;
                    this.state = TeachingState.NONE;
                    this.currentEpsilon = this.config.epsilon;
                    this.onLessonEnded = null;
                    this.onLearningLessonEnded = null;
                    this.onTeachingEnded = null;
                    this.name = name
                }

                Teacher.prototype.affectStudent = function (agent) {
                    this.agents.add(agent)
                };
                Teacher.prototype.removeStudent = function (agent) {
                    return this.agents.delete(agent)
                };
                Teacher.prototype.start = function () {
                    this.lessonsTaught = 0;
                    this.currentLessonLength = 0;
                    this.state = TeachingState.EXPERIENCING
                };
                Teacher.prototype.teach = function (inputs) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var actions, _i, _a, agent;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.state == TeachingState.STOPPED) return [2, null];
                                    if (this.state == TeachingState.NONE) {
                                        this.start()
                                    }
                                    actions = new Map;
                                    if (this.state == TeachingState.TESTING) {
                                        this.agents.forEach(function (a) {
                                            return actions.set(a.Name, a.forward(inputs, _this.currentEpsilon, false))
                                        });
                                        return [2, actions]
                                    }
                                    this.currentLessonLength += 1;
                                    if (this.currentLessonLength >= this.config.lessonLength) this.state = TeachingState.LEARNING;
                                    if (!(this.state == TeachingState.EXPERIENCING)) return [3, 1];
                                    this.agents.forEach(function (a) {
                                        return actions.set(a.Name, a.listen(inputs, _this.currentEpsilon))
                                    });
                                    return [3, 6];
                                case 1:
                                    if (!(this.state == TeachingState.LEARNING)) return [3, 6];
                                    if (this.onLessonEnded) this.onLessonEnded(this.name, this.lessonsTaught);
                                    _i = 0, _a = Array.from(this.agents.keys());
                                    _b.label = 2;
                                case 2:
                                    if (!(_i < _a.length)) return [3, 5];
                                    agent = _a[_i];
                                    return [4, agent.learn(this.config.gamma)];
                                case 3:
                                    _b.sent();
                                    _b.label = 4;
                                case 4:
                                    _i++;
                                    return [3, 2];
                                case 5:
                                    this.updateParameters();
                                    this.lessonsTaught += 1;
                                    this.currentLessonLength = 0;
                                    if (this.lessonsTaught >= this.config.lessonsQuantity) {
                                        this.state = TeachingState.TESTING;
                                        if (this.onTeachingEnded) this.onTeachingEnded(this.name)
                                    } else {
                                        this.state = TeachingState.EXPERIENCING
                                    }
                                    this.agents.forEach(function (a) {
                                        return actions.set(a.Name, a.listen(inputs, _this.currentEpsilon))
                                    });
                                    if (this.onLearningLessonEnded) this.onLearningLessonEnded(this.name);
                                    _b.label = 6;
                                case 6:
                                    return [2, actions]
                            }
                        })
                    })
                };
                Teacher.prototype.updateParameters = function () {
                    if (this.lessonsTaught > this.config.lessonsWithRandom && this.currentEpsilon > this.config.epsilonMin) {
                        this.currentEpsilon *= this.config.epsilonDecay;
                        if (this.currentEpsilon < this.config.epsilonMin) this.currentEpsilon = this.config.epsilonMin
                    }
                };
                Teacher.prototype.getData = function () {
                    var data = [];
                    this.agents.forEach(function (agent) {
                        return data.push(agent.getTrackingInformation())
                    });
                    return {
                        epsilon: this.currentEpsilon,
                        gamma: this.config.gamma,
                        lessonNumber: this.lessonsTaught,
                        currentLessonLength: this.currentLessonLength,
                        maxLessons: this.config.lessonsQuantity,
                        name: this.name,
                        students: data
                    }
                };
                Teacher.prototype.resetLesson = function () {
                    this.currentLessonLength = 0;
                    this.state = TeachingState.EXPERIENCING
                };
                Teacher.prototype.reset = function () {
                    this.lessonsTaught = 0;
                    this.currentLessonLength = 0;
                    this.state = TeachingState.NONE
                };
                Teacher.prototype.stop = function () {
                    this.state = TeachingState.STOPPED
                };
                Object.defineProperty(Teacher.prototype, "OnLearningLessonEnded", {
                    set: function (callback) {
                        this.onLearningLessonEnded = callback
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Teacher.prototype, "OnLessonEnded", {
                    set: function (callback) {
                        this.onLessonEnded = callback
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Teacher.prototype, "OnTeachingEnded", {
                    set: function (callback) {
                        this.onTeachingEnded = callback
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Teacher.prototype, "Name", {
                    get: function () {
                        return this.name
                    }, set: function (name) {
                        this.name = name
                    }, enumerable: true, configurable: true
                });
                Object.defineProperty(Teacher.prototype, "State", {
                    get: function () {
                        return this.state
                    }, enumerable: true, configurable: true
                });
                return Teacher
            }();
            exports.Teacher = Teacher
        }, {}]
    }, {}, [227])(227)
});
